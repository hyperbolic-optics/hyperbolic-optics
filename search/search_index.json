{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hyperbolic Optics Documentation","text":"<p>A comprehensive Python package for simulating the reflective properties of hyperbolic materials and anisotropic structures using the 4\u00d74 transfer matrix method.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Transfer Matrix Method: Accurate 4\u00d74 transfer matrix implementation for anisotropic media</li> <li>Multiple Scenarios: Support for incident angle sweeps, azimuthal rotations, dispersion analysis, and single-point calculations</li> <li>Materials Library: Pre-configured materials including Quartz, Calcite, Sapphire, and Gallium Oxide</li> <li>Mueller Matrix Analysis: Complete Stokes parameter and polarization analysis capabilities</li> <li>Custom Materials: Define arbitrary materials with custom permittivity and permeability tensors</li> <li>Visualization: Publication-quality plotting functions</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.mueller import Mueller\n\n# Define a simple structure\npayload = {\n    \"ScenarioData\": {\n        \"type\": \"Simple\",\n        \"incidentAngle\": 45.0,\n        \"azimuthal_angle\": 0.0,\n        \"frequency\": 1460.0\n    },\n    \"Layers\": [\n        {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.1},\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Calcite\",\n            \"rotationX\": 0,\n            \"rotationY\": 90,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\n# Run simulation\nstructure = Structure()\nstructure.execute(payload)\n\n# Calculate reflectivities\nR_pp = abs(structure.r_pp)**2\nR_ss = abs(structure.r_ss)**2\n\nprint(f\"p-polarized reflectivity: {R_pp:.4f}\")\nprint(f\"s-polarized reflectivity: {R_ss:.4f}\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install hyperbolic-optics\n</code></pre> <p>Or using uv (recommended):</p> <pre><code>uv add hyperbolic-optics\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Detailed installation instructions</li> <li>Quick Start - Get up and running quickly</li> <li>User Guide - Learn about core concepts</li> <li>API Reference - Detailed API documentation</li> <li>Examples - See more examples</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use this package in your research, please cite:</p> <pre><code>@software{cunningham2025hyperbolic,\n  title={Hyperbolic Optics Simulation Package},\n  author={Mark Cunningham},\n  year={2025},\n  version={0.1.8},\n  doi={10.5281/zenodo.14946556},\n  url={https://pypi.org/project/hyperbolic-optics/}\n}\n</code></pre>"},{"location":"#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Repository: GitHub Repository</li> </ul>"},{"location":"citation/","title":"Citation","text":"<p>If you use this package in your research, please cite:</p>"},{"location":"citation/#software-citation","title":"Software Citation","text":"<pre><code>@software{cunningham2025hyperbolic,\n  title={Hyperbolic Optics Simulation Package},\n  author={Mark Cunningham},\n  year={2025},\n  version={0.1.8},\n  doi={10.5281/zenodo.14946556},\n  url={https://pypi.org/project/hyperbolic-optics/},\n  howpublished={PyPI},\n  note={Python package for 4\u00d74 transfer matrix method simulations}\n}\n</code></pre>"},{"location":"citation/#related-publications","title":"Related Publications","text":"<p>This package was developed as part of research on hyperbolic polaritons and was used to generate results in:</p> <p>M. Cunningham et al., \"Optical footprint of ghost and leaky hyperbolic polaritons,\" Photonics Research, vol. 13, no. 8, pp. 2291-2305 (2025). DOI: 10.1364/PRJ.558334</p>"},{"location":"citation/#bibtex-entry-for-publication","title":"BibTeX Entry for Publication","text":"<pre><code>@article{cunningham2025optical,\n  title={Optical footprint of ghost and leaky hyperbolic polaritons},\n  author={Cunningham, Mark and others},\n  journal={Photonics Research},\n  volume={13},\n  number={8},\n  pages={2291--2305},\n  year={2025},\n  doi={10.1364/PRJ.558334}\n}\n</code></pre>"},{"location":"citation/#zenodo-doi","title":"Zenodo DOI","text":"<p>Permanent archive: 10.5281/zenodo.14946556</p>"},{"location":"citation/#citing-specific-versions","title":"Citing Specific Versions","text":"<p>If you need to cite a specific version:</p> <pre><code>@software{cunningham2025hyperbolic_v018,\n  title={Hyperbolic Optics Simulation Package},\n  author={Mark Cunningham},\n  year={2025},\n  version={0.1.8},\n  doi={10.5281/zenodo.14946556},\n  url={https://pypi.org/project/hyperbolic-optics/0.1.8/}\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":"<p>This work builds upon the theoretical framework established by:</p> <ul> <li>N. C. Passler and A. Paarmann, \"Generalized 4 \u00d7 4 matrix formalism for light propagation in anisotropic stratified media,\" J. Opt. Soc. Am. B 34, 2128-2139 (2017)</li> <li>P. Yeh, \"Electromagnetic propagation in birefringent layered media,\" J. Opt. Soc. Am. 69, 742-756 (1979)</li> <li>N. C. Passler et al., \"Layer-resolved resonance intensity of evanescent polariton modes in anisotropic multilayers,\" Phys. Rev. B 107, 235426 (2023)</li> </ul>"},{"location":"citation/#copyright-and-license","title":"Copyright and License","text":"<p>Copyright (c) 2025 Mark Cunningham</p> <p>Licensed under the MIT License. See LICENSE for details.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to the Hyperbolic Optics package! This guide will help you get started.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Report bugs via GitHub Issues</li> <li>Request features or enhancements</li> <li>Improve documentation (fix typos, add examples, clarify explanations)</li> <li>Submit bug fixes or new features via Pull Requests</li> <li>Add new materials to the materials library</li> <li>Share your research that uses this package</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> <li>uv package manager (recommended)</li> <li>Git</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork and clone the repository</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/hyperbolic_optics.git\ncd hyperbolic_optics\n</code></pre> <ol> <li>Install dependencies</li> </ol> <pre><code># Using uv (recommended)\nuv sync --all-extras\n\n# Or using pip\npip install -e \".[dev]\"\n</code></pre> <ol> <li>Verify installation</li> </ol> <pre><code># Run tests\nuv run pytest\n\n# Check code works\npython examples/calcite.py\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"contributing/#2-make-your-changes","title":"2. Make Your Changes","text":"<p>Edit the code in your favorite editor. The main package is in <code>hyperbolic_optics/</code>.</p>"},{"location":"contributing/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=hyperbolic_optics --cov-report=html\n\n# Run specific test file\nuv run pytest tests/test_structure.py\n\n# Run specific test\nuv run pytest tests/test_structure.py::TestStructureBasicFunctionality::test_simple_scenario_execution\n</code></pre>"},{"location":"contributing/#4-check-code-quality","title":"4. Check Code Quality","text":"<pre><code># Format code with black\nuv run black hyperbolic_optics tests\n\n# Sort imports with isort\nuv run isort hyperbolic_optics tests\n\n# Lint with flake8\nuv run flake8 hyperbolic_optics tests --max-line-length=100 --extend-ignore=E203,W503\n</code></pre>"},{"location":"contributing/#5-update-documentation","title":"5. Update Documentation","text":"<p>If you added new features:</p> <ul> <li>Add docstrings to your functions/classes (they auto-generate API docs!)</li> <li>Update relevant user guide pages in <code>docs/</code></li> <li>Add examples if appropriate</li> </ul> <p>Build docs locally to preview:</p> <pre><code>uv run mkdocs serve\n# Visit http://127.0.0.1:8000\n</code></pre>"},{"location":"contributing/#6-commit-your-changes","title":"6. Commit Your Changes","text":"<pre><code>git add .\ngit commit -m \"Brief description of your changes\"\n</code></pre> <p>Write clear commit messages: - Use present tense (\"Add feature\" not \"Added feature\") - Be descriptive but concise - Reference issue numbers if applicable (#123)</p>"},{"location":"contributing/#7-push-and-create-pull-request","title":"7. Push and Create Pull Request","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then open a Pull Request on GitHub with: - Clear title and description - Reference to related issues - Summary of changes made - Any breaking changes noted</p>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"contributing/#python-code","title":"Python Code","text":"<ul> <li>Follow PEP 8 style guide</li> <li>Use type hints where appropriate</li> <li>Maximum line length: 100 characters</li> <li>Use descriptive variable names</li> </ul>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def example_function(param1, param2):\n    \"\"\"Brief description of function.\n\n    More detailed description if needed, explaining what the\n    function does and any important details.\n\n    Args:\n        param1 (float): Description of param1.\n        param2 (np.ndarray): Description of param2.\n\n    Returns:\n        dict: Description of return value.\n\n    Raises:\n        ValueError: When param1 is negative.\n\n    Example:\n        &gt;&gt;&gt; result = example_function(1.0, np.array([1, 2, 3]))\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#test-guidelines","title":"Test Guidelines","text":"<ul> <li>Write tests for all new features</li> <li>Aim for &gt;90% code coverage</li> <li>Use descriptive test names</li> <li>Group related tests in classes</li> <li>Use fixtures for common setup</li> </ul> <pre><code>def test_structure_executes_simple_scenario(simple_payload):\n    \"\"\"Test that structure executes simple scenario correctly.\"\"\"\n    structure = Structure()\n    structure.execute(simple_payload)\n\n    assert structure.r_pp is not None\n    assert structure.r_ss is not None\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>hyperbolic_optics/\n\u251c\u2500\u2500 hyperbolic_optics/          # Main package\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 structure.py            # Structure class\n\u2502   \u251c\u2500\u2500 materials.py            # Material definitions\n\u2502   \u251c\u2500\u2500 layers.py               # Layer classes\n\u2502   \u251c\u2500\u2500 mueller.py              # Mueller matrix calculations\n\u2502   \u251c\u2500\u2500 scenario.py             # Scenario types\n\u2502   \u251c\u2500\u2500 waves.py                # Wave calculations\n\u2502   \u251c\u2500\u2500 plots.py                # Plotting functions\n\u2502   \u2514\u2500\u2500 material_params.json    # Material parameters\n\u251c\u2500\u2500 tests/                      # Test suite\n\u2502   \u251c\u2500\u2500 conftest.py            # Pytest fixtures\n\u2502   \u251c\u2500\u2500 test_structure.py\n\u2502   \u251c\u2500\u2500 test_materials.py\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 examples/                   # Example scripts\n\u251c\u2500\u2500 docs/                       # Documentation\n\u251c\u2500\u2500 .github/workflows/          # CI/CD pipelines\n\u251c\u2500\u2500 pyproject.toml             # Project configuration\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"contributing/#adding-a-new-material","title":"Adding a New Material","text":"<ol> <li>Add material parameters to <code>hyperbolic_optics/material_params.json</code></li> <li>Create material class in <code>hyperbolic_optics/materials.py</code></li> <li>Add tests in <code>tests/test_materials.py</code></li> <li>Update documentation in <code>docs/user-guide/materials.md</code></li> </ol>"},{"location":"contributing/#adding-new-layer-types","title":"Adding New Layer Types","text":"<ol> <li>Create layer class in <code>hyperbolic_optics/layers.py</code></li> <li>Register in <code>LayerFactory.layer_classes</code></li> <li>Add tests in <code>tests/test_layers.py</code></li> <li>Update documentation</li> </ol>"},{"location":"contributing/#running-cicd-locally","title":"Running CI/CD Locally","text":"<p>The project uses GitHub Actions for CI/CD. You can test similar checks locally:</p> <pre><code># Run tests (like CI does)\nuv run pytest --cov=hyperbolic_optics --cov-report=xml --cov-report=term\n\n# Check formatting\nuv run black --check hyperbolic_optics tests\nuv run isort --check-only hyperbolic_optics tests\nuv run flake8 hyperbolic_optics tests --max-line-length=100 --extend-ignore=E203,W503\n</code></pre>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting bugs, please include:</p> <ul> <li>Python version (<code>python --version</code>)</li> <li>Package version (<code>pip show hyperbolic-optics</code>)</li> <li>Operating system</li> <li>Minimal code to reproduce the issue</li> <li>Full error traceback</li> <li>Expected vs actual behavior</li> </ul> <p>Example:</p> <pre><code>## Bug Description\nBrief description of the bug\n\n## To Reproduce\n\\```python\n# Minimal code to reproduce\n\\```\n\n## Expected Behavior\nWhat you expected to happen\n\n## Actual Behavior\nWhat actually happened\n\n## Environment\n- OS: macOS 14.2\n- Python: 3.12.1\n- Package version: 0.1.8\n</code></pre>"},{"location":"contributing/#code-review-process","title":"Code Review Process","text":"<ol> <li>All submissions require review</li> <li>Maintainers will provide feedback</li> <li>Address review comments by pushing new commits</li> <li>Once approved, maintainers will merge your PR</li> </ol>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open a Discussion for questions</li> <li>Check existing Issues</li> <li>Email: m.cunningham.2@research.gla.ac.uk</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Thank you for considering contributing to Hyperbolic Optics! Every contribution helps make the package better for everyone.</p>"},{"location":"api/layers/","title":"Layers API","text":""},{"location":"api/layers/#hyperbolic_optics.layers","title":"<code>hyperbolic_optics.layers</code>","text":"<p>Layers module for constructing individual layers in the device. NumPy implementation - Stage 2 Refactor: Updated to properly handle both eps and mu tensors from materials</p>"},{"location":"api/layers/#hyperbolic_optics.layers.AirGapLayer","title":"<code>AirGapLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>The airgap/isotropic middle layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AirGapLayer(Layer):\n    \"\"\"The airgap/isotropic middle layer.\"\"\"\n\n    def __init__(self, data, scenario, kx, k0):\n        super().__init__(data, scenario, kx, k0)\n\n        # Handle complex permittivity input\n        perm = data.get(\"permittivity\", 1.0)\n        if isinstance(perm, dict):\n            if \"real\" in perm or \"imag\" in perm:\n                self.permittivity = complex(perm.get(\"real\", 0), perm.get(\"imag\", 0))\n            else:\n                # Handle nested permittivity structure if present\n                self.permittivity = {\n                    k: (complex(v.get(\"real\", 0), v.get(\"imag\", 0)) if isinstance(v, dict) else v)\n                    for k, v in perm.items()\n                }\n        else:\n            self.permittivity = complex(perm, 0)\n\n        # CHANGED: Handle magnetic permeability input\n        mu = data.get(\"permeability\", 1.0)\n        if isinstance(mu, dict):\n            if \"real\" in mu or \"imag\" in mu:\n                self.permeability = complex(mu.get(\"real\", 0), mu.get(\"imag\", 0))\n            else:\n                # Handle nested permeability structure if present\n                self.permeability = {\n                    k: (complex(v.get(\"real\", 0), v.get(\"imag\", 0)) if isinstance(v, dict) else v)\n                    for k, v in mu.items()\n                }\n        else:\n            self.permeability = complex(mu, 0)\n\n        # CHANGED: Create the isotropic material with both eps and mu\n        self.isotropic_material = Air(\n            permittivity=self.permittivity, permeability=self.permeability\n        )\n\n        # CHANGED: Get both tensors from the material\n        self.eps_tensor = self.isotropic_material.fetch_permittivity_tensor()\n        self.mu_tensor = self.isotropic_material.fetch_magnetic_tensor()\n\n        self.calculate_mode()\n        self.create()\n\n    def calculate_mode(self):\n        \"\"\"Determine the mode of the airgap/isotropic layer.\"\"\"\n        if self.scenario == \"Incident\":\n            self.mode = \"airgap\"\n        elif self.scenario == \"Azimuthal\":\n            self.mode = \"azimuthal_airgap\"\n        elif self.scenario == \"Dispersion\":\n            self.mode = \"simple_airgap\"\n        elif self.scenario == \"Simple\":\n            self.mode = \"simple_scalar_airgap\"\n\n    def create(self):\n        # CHANGED: Pass both tensors instead of duplicating the eps tensor\n        self.profile, self.matrix = Wave(\n            self.kx,\n            self.eps_tensor,\n            self.mu_tensor,  # Now passing the actual magnetic tensor\n            self.mode,\n            k_0=self.k0,\n            thickness=self.thickness,\n        ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AirGapLayer.calculate_mode","title":"<code>calculate_mode()</code>","text":"<p>Determine the mode of the airgap/isotropic layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_mode(self):\n    \"\"\"Determine the mode of the airgap/isotropic layer.\"\"\"\n    if self.scenario == \"Incident\":\n        self.mode = \"airgap\"\n    elif self.scenario == \"Azimuthal\":\n        self.mode = \"azimuthal_airgap\"\n    elif self.scenario == \"Dispersion\":\n        self.mode = \"simple_airgap\"\n    elif self.scenario == \"Simple\":\n        self.mode = \"simple_scalar_airgap\"\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium","title":"<code>AmbientExitMedium</code>","text":"<p>               Bases: <code>AmbientMedium</code></p> <p>Class representing the ambient exit medium. Moved from material_params.py to better organize layer-related functionality.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AmbientExitMedium(AmbientMedium):\n    \"\"\"\n    Class representing the ambient exit medium.\n    Moved from material_params.py to better organize layer-related functionality.\n    \"\"\"\n\n    def __init__(self, incident_angle, permittivity_incident, permittivity_exit):\n        \"\"\"\n        Initialize the AmbientExitMedium class.\n\n        Args:\n            incident_angle (float): The incident angle.\n            permittivity_incident (float): The permittivity of the incident medium.\n            permittivity_exit (float): The permittivity of the exit medium.\n        \"\"\"\n        super().__init__()\n        self.theta_incident = incident_angle\n        self.N_exit = np.sqrt(permittivity_exit)\n        self.N_incident = np.sqrt(permittivity_incident)\n\n    def construct_tensor(self):\n        \"\"\"\n        Construct the tensor for the ambient exit medium.\n\n        Returns:\n            np.ndarray: The constructed tensor.\n        \"\"\"\n        return self._construct_tensor()\n\n    def _construct_tensor(self):\n        sin_theta_incident = np.sin(self.theta_incident)\n        expr_inside_sqrt = 1.0 - ((self.N_incident / self.N_exit) * sin_theta_incident) ** 2.0\n        expr_inside_sqrt_complex = expr_inside_sqrt.astype(np.complex128)\n        cos_theta_f = np.sqrt(expr_inside_sqrt_complex)\n        N_exit = self.N_exit.astype(np.complex128)\n        Nf_cos_theta_f = N_exit * cos_theta_f\n\n        element1 = np.stack(\n            [\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n                cos_theta_f,\n                -cos_theta_f,\n            ],\n            axis=-1,\n        )\n\n        element2 = np.stack(\n            [\n                np.ones_like(cos_theta_f),\n                np.ones_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n            ],\n            axis=-1,\n        )\n\n        element3 = np.stack(\n            [\n                -Nf_cos_theta_f,\n                Nf_cos_theta_f,\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n            ],\n            axis=-1,\n        )\n\n        element4 = np.stack(\n            [\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n                N_exit * np.ones_like(cos_theta_f),\n                N_exit * np.ones_like(cos_theta_f),\n            ],\n            axis=-1,\n        )\n\n        matrix = np.stack([element1, element2, element3, element4], axis=1)\n        return matrix.astype(np.complex128)\n\n    def construct_tensor_singular(self):\n        \"\"\"\n        Construct the singular tensor for the ambient exit medium.\n\n        Returns:\n            np.ndarray: The constructed singular tensor.\n        \"\"\"\n        return self._construct_tensor_singular()\n\n    def _construct_tensor_singular(self):\n        sin_theta_incident = np.sin(self.theta_incident)\n        expr_inside_sqrt = 1.0 - ((self.N_incident / self.N_exit) * sin_theta_incident) ** 2.0\n        expr_inside_sqrt_complex = np.complex128(expr_inside_sqrt)\n        cos_theta_f = np.sqrt(expr_inside_sqrt_complex)\n        N_exit = np.complex128(self.N_exit)\n        Nf_cos_theta_f = N_exit * cos_theta_f\n\n        element1 = np.array([0.0, 0.0, cos_theta_f, -cos_theta_f])\n        element2 = np.array([1.0, 1.0, 0.0, 0.0])\n        element3 = np.array([-Nf_cos_theta_f, Nf_cos_theta_f, 0.0, 0.0])\n        element4 = np.array([0.0, 0.0, N_exit, N_exit])\n\n        matrix = np.stack([element1, element2, element3, element4], axis=0)\n        return matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium.__init__","title":"<code>__init__(incident_angle, permittivity_incident, permittivity_exit)</code>","text":"<p>Initialize the AmbientExitMedium class.</p> <p>Parameters:</p> Name Type Description Default <code>incident_angle</code> <code>float</code> <p>The incident angle.</p> required <code>permittivity_incident</code> <code>float</code> <p>The permittivity of the incident medium.</p> required <code>permittivity_exit</code> <code>float</code> <p>The permittivity of the exit medium.</p> required Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(self, incident_angle, permittivity_incident, permittivity_exit):\n    \"\"\"\n    Initialize the AmbientExitMedium class.\n\n    Args:\n        incident_angle (float): The incident angle.\n        permittivity_incident (float): The permittivity of the incident medium.\n        permittivity_exit (float): The permittivity of the exit medium.\n    \"\"\"\n    super().__init__()\n    self.theta_incident = incident_angle\n    self.N_exit = np.sqrt(permittivity_exit)\n    self.N_incident = np.sqrt(permittivity_incident)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium.construct_tensor","title":"<code>construct_tensor()</code>","text":"<p>Construct the tensor for the ambient exit medium.</p> <p>Returns:</p> Type Description <p>np.ndarray: The constructed tensor.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor(self):\n    \"\"\"\n    Construct the tensor for the ambient exit medium.\n\n    Returns:\n        np.ndarray: The constructed tensor.\n    \"\"\"\n    return self._construct_tensor()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium.construct_tensor_singular","title":"<code>construct_tensor_singular()</code>","text":"<p>Construct the singular tensor for the ambient exit medium.</p> <p>Returns:</p> Type Description <p>np.ndarray: The constructed singular tensor.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor_singular(self):\n    \"\"\"\n    Construct the singular tensor for the ambient exit medium.\n\n    Returns:\n        np.ndarray: The constructed singular tensor.\n    \"\"\"\n    return self._construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium","title":"<code>AmbientIncidentMedium</code>","text":"<p>               Bases: <code>AmbientMedium</code></p> <p>Class representing the ambient incident medium. Moved from material_params.py to better organize layer-related functionality.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AmbientIncidentMedium(AmbientMedium):\n    \"\"\"\n    Class representing the ambient incident medium.\n    Moved from material_params.py to better organize layer-related functionality.\n    \"\"\"\n\n    def __init__(self, permittivity, kx):\n        \"\"\"\n        Initialize the AmbientIncidentMedium class.\n\n        Args:\n            permittivity (float): The permittivity of the ambient incident medium.\n            kx (float): The x-component of the wavevector.\n        \"\"\"\n        super().__init__()\n        self.permittivity = permittivity\n        self.theta = np.arcsin(kx / np.sqrt(permittivity)).astype(np.float64)\n\n    def construct_tensor(self):\n        \"\"\"\n        Construct the tensor for the ambient incident medium.\n\n        Returns:\n            np.ndarray: The constructed tensor.\n        \"\"\"\n        return self._construct_tensor()\n\n    def _construct_tensor(self):\n        n = np.sqrt(self.permittivity)\n        cos_theta = np.cos(self.theta)\n        n_cos_theta = n * cos_theta\n\n        # Combine updates into a single tensor with shape [180, 4, 4]\n        element1 = np.stack(\n            [\n                np.zeros_like(self.theta),\n                np.ones_like(self.theta),\n                -1.0 / n_cos_theta,\n                np.zeros_like(self.theta),\n            ],\n            axis=-1,\n        )\n        element2 = np.stack(\n            [\n                np.zeros_like(self.theta),\n                np.ones_like(self.theta),\n                1.0 / n_cos_theta,\n                np.zeros_like(self.theta),\n            ],\n            axis=-1,\n        )\n        element3 = np.stack(\n            [\n                1.0 / cos_theta,\n                np.zeros_like(self.theta),\n                np.zeros_like(self.theta),\n                1.0 / n * np.ones_like(self.theta),\n            ],\n            axis=-1,\n        )\n        element4 = np.stack(\n            [\n                -1.0 / cos_theta,\n                np.zeros_like(self.theta),\n                np.zeros_like(self.theta),\n                1.0 / n * np.ones_like(self.theta),\n            ],\n            axis=-1,\n        )\n\n        matrix = np.stack([element1, element2, element3, element4], axis=1)\n        return 0.5 * matrix.astype(np.complex128)\n\n    def construct_tensor_singular(self):\n        \"\"\"\n        Construct the singular tensor for the ambient incident medium.\n\n        Returns:\n            np.ndarray: The constructed singular tensor.\n        \"\"\"\n        return self._construct_tensor_singular()\n\n    def _construct_tensor_singular(self):\n        n = np.sqrt(self.permittivity)\n        cos_theta = np.cos(self.theta)\n        n_cos_theta = n * cos_theta\n\n        element1 = np.stack([0.0, 1.0, -1.0 / n_cos_theta, 0.0])\n        element2 = np.stack([0.0, 1.0, 1.0 / n_cos_theta, 0.0])\n        element3 = np.stack([1.0 / cos_theta, 0.0, 0.0, 1.0 / n])\n        element4 = np.stack([-1.0 / cos_theta, 0.0, 0.0, 1.0 / n])\n\n        matrix = np.stack([element1, element2, element3, element4], axis=0)\n        return 0.5 * matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium.__init__","title":"<code>__init__(permittivity, kx)</code>","text":"<p>Initialize the AmbientIncidentMedium class.</p> <p>Parameters:</p> Name Type Description Default <code>permittivity</code> <code>float</code> <p>The permittivity of the ambient incident medium.</p> required <code>kx</code> <code>float</code> <p>The x-component of the wavevector.</p> required Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(self, permittivity, kx):\n    \"\"\"\n    Initialize the AmbientIncidentMedium class.\n\n    Args:\n        permittivity (float): The permittivity of the ambient incident medium.\n        kx (float): The x-component of the wavevector.\n    \"\"\"\n    super().__init__()\n    self.permittivity = permittivity\n    self.theta = np.arcsin(kx / np.sqrt(permittivity)).astype(np.float64)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium.construct_tensor","title":"<code>construct_tensor()</code>","text":"<p>Construct the tensor for the ambient incident medium.</p> <p>Returns:</p> Type Description <p>np.ndarray: The constructed tensor.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor(self):\n    \"\"\"\n    Construct the tensor for the ambient incident medium.\n\n    Returns:\n        np.ndarray: The constructed tensor.\n    \"\"\"\n    return self._construct_tensor()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium.construct_tensor_singular","title":"<code>construct_tensor_singular()</code>","text":"<p>Construct the singular tensor for the ambient incident medium.</p> <p>Returns:</p> Type Description <p>np.ndarray: The constructed singular tensor.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor_singular(self):\n    \"\"\"\n    Construct the singular tensor for the ambient incident medium.\n\n    Returns:\n        np.ndarray: The constructed singular tensor.\n    \"\"\"\n    return self._construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientMedium","title":"<code>AmbientMedium</code>","text":"<p>Base class for ambient mediums (incident and exit).</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AmbientMedium:\n    \"\"\"Base class for ambient mediums (incident and exit).\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the ambient medium.\"\"\"\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientMedium.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the ambient medium.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the ambient medium.\"\"\"\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.CrystalLayer","title":"<code>CrystalLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Anisotropic crystal of arbitrary orientation and thickness.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class CrystalLayer(Layer):\n    \"\"\"Anisotropic crystal of arbitrary orientation and thickness.\"\"\"\n\n    def __init__(self, data, scenario, kx, k0):\n        super().__init__(data, scenario, kx, k0)\n        # CHANGED: Use the new unified tensor calculation methods\n        self.calculate_tensors()  # Get both eps and mu tensors\n        self.calculate_z_rotation()\n        self.rotate_tensors()  # Rotate both tensors\n        self.create()\n\n    def create(self):\n        # CHANGED: Pass both tensors to Wave\n        self.profile, self.matrix = Wave(\n            self.kx,\n            self.eps_tensor,\n            self.mu_tensor,  # Now using the actual magnetic tensor from material\n            self.scenario,\n            k_0=self.k0,\n            thickness=self.thickness,\n        ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.IsotropicSemiInfiniteLayer","title":"<code>IsotropicSemiInfiniteLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Isotropic semi-infinite layer with a given permittivity.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class IsotropicSemiInfiniteLayer(Layer):\n    \"\"\"Isotropic semi-infinite layer with a given permittivity.\"\"\"\n\n    def __init__(self, data, scenario, kx, k0):\n        super().__init__(data, scenario, kx, k0)\n        self.eps_incident = (kx.astype(np.float64) / np.sin(self.incident_angle)) ** 2\n        self.eps_exit = np.float64(data.get(\"permittivity\"))\n\n        if self.eps_exit is None:\n            raise ValueError(\"No exit permittivity provided for isotropic semi-infinite layer\")\n\n        self.create()\n\n    def create(self):\n        exit_medium = AmbientExitMedium(self.incident_angle, self.eps_incident, self.eps_exit)\n\n        if self.scenario == \"Incident\":\n            self.matrix = exit_medium.construct_tensor()\n        elif self.scenario == \"Azimuthal\":\n            self.matrix = exit_medium.construct_tensor()[np.newaxis, np.newaxis, ...]\n        elif self.scenario == \"Dispersion\":\n            self.matrix = exit_medium.construct_tensor()[:, np.newaxis, ...]\n        elif self.scenario == \"Simple\":\n            # For simple scenario, just get the scalar tensor without additional dimensions\n            self.matrix = exit_medium.construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer","title":"<code>Layer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for a layer in the device.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class Layer(ABC):\n    \"\"\"Abstract base class for a layer in the device.\"\"\"\n\n    def __init__(self, data, scenario, kx, k0):\n        self.type = data.get(\"type\")\n        self.material = data.get(\"material\", None)\n        self.rotationX = np.float64(m.radians(data.get(\"rotationX\", 0)))\n        self.rotationY = np.float64(m.radians(data.get(\"rotationY\", 0))) + 1e-8\n        self.rotationZ = np.float64(m.radians(data.get(\"rotationZ\", 0))) + 1.0e-9\n        self.rotationZ_type = data.get(\"rotationZType\", \"relative\")\n        self.kx = kx\n        self.k0 = k0\n        self.frequency = scenario.frequency\n        self.scenario = scenario.type\n        self.incident_angle = scenario.incident_angle\n        self.azimuthal_angle = scenario.azimuthal_angle\n\n        # CHANGED: Remove the default non_magnetic_tensor assignment\n        # We'll get both tensors from materials now\n        self.eps_tensor = None\n        self.mu_tensor = None\n\n        self.thickness = data.get(\"thickness\", None)\n        if self.thickness:\n            self.thickness = float(self.thickness) * 1e-4\n\n    def material_factory(self):\n        \"\"\"Create the material object based on the material name or specifications.\n\n        This method handles both predefined materials (like Quartz, Sapphire) and\n        arbitrary materials specified via a dictionary of parameters.\n\n        Returns:\n            Material object: An instance of a material class with the specified properties\n        \"\"\"\n        if isinstance(self.material, dict):\n            # Create an ArbitraryMaterial instance instead of returning the dict\n            self.material = ArbitraryMaterial(self.material)\n        elif self.material == \"Quartz\":\n            self.material = Quartz()\n        elif self.material == \"Sapphire\":\n            self.material = Sapphire()\n        elif self.material == \"Calcite\":\n            self.material = CalciteUpper()\n        elif self.material == \"CalciteLower\":\n            self.material = CalciteLower()\n        elif self.material == \"GalliumOxide\":\n            self.material = GalliumOxide()\n        else:\n            raise NotImplementedError(f\"Material {self.material} not implemented\")\n\n    def calculate_z_rotation(self):\n        \"\"\"\n        Calculate the rotation of the layer in the z direction.\n\n        If the scenario is dispersion, azimuthal, or simple, the rotation is relative to\n        the azimuthal angle, but can be defined to be static while all other\n        layers are rotated. If it's relative, the rotation is added to the\n        azimuthal angle as it has been 'shifted'.\n        \"\"\"\n        if self.scenario in [\"Dispersion\", \"Azimuthal\", \"Simple\"]:\n            if self.rotationZ_type == \"relative\":\n                self.rotationZ = self.azimuthal_angle + self.rotationZ\n            elif self.rotationZ_type == \"static\":\n                if self.scenario == \"Simple\":\n                    # For simple scenario, keep as scalar\n                    self.rotationZ = self.rotationZ\n                else:\n                    self.rotationZ = self.rotationZ * np.ones_like(self.azimuthal_angle)\n\n    def calculate_tensors(self):\n        \"\"\"Calculate both permittivity and magnetic tensors for the layer.\"\"\"\n        self.material_factory()\n\n        if self.scenario in [\"Incident\", \"Azimuthal\"]:\n            self.eps_tensor = self.material.fetch_permittivity_tensor().astype(np.complex128)\n            self.mu_tensor = self.material.fetch_magnetic_tensor().astype(np.complex128)\n        elif self.scenario in [\"Dispersion\", \"Simple\"]:\n            self.eps_tensor = self.material.fetch_permittivity_tensor_for_freq(\n                self.frequency\n            ).astype(np.complex128)\n            self.mu_tensor = self.material.fetch_magnetic_tensor_for_freq(self.frequency).astype(\n                np.complex128\n            )\n\n    def rotate_tensors(self):\n        \"\"\"Rotate both permittivity and magnetic tensors according to the rotation angles.\"\"\"\n        if self.scenario in [\"Incident\", \"Dispersion\"]:\n            rotation_func = anisotropy_rotation_one_value\n        elif self.scenario == \"Azimuthal\":\n            rotation_func = anisotropy_rotation_one_axis\n        elif self.scenario == \"Simple\":\n            rotation_func = anisotropy_rotation_one_value\n\n        self.eps_tensor = rotation_func(\n            self.eps_tensor, self.rotationX, self.rotationY, self.rotationZ\n        )\n        self.mu_tensor = rotation_func(\n            self.mu_tensor, self.rotationX, self.rotationY, self.rotationZ\n        )\n\n    # DEPRECATED: Remove this method in favor of calculate_tensors()\n    def calculate_eps_tensor(self):\n        \"\"\"Calculate the permittivity tensor for the layer. DEPRECATED - use calculate_tensors().\"\"\"\n        import warnings\n\n        warnings.warn(\n            \"calculate_eps_tensor() is deprecated. Use calculate_tensors() instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.calculate_tensors()\n\n    # DEPRECATED: Remove this method in favor of rotate_tensors()\n    def rotate_tensor(self):\n        \"\"\"Rotate the permittivity tensor according to the rotation angles.\n        DEPRECATED - use rotate_tensors().\"\"\"\n        import warnings\n\n        warnings.warn(\n            \"rotate_tensor() is deprecated. Use rotate_tensors() instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.rotate_tensors()\n\n    @abstractmethod\n    def create(self):\n        pass\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.calculate_eps_tensor","title":"<code>calculate_eps_tensor()</code>","text":"<p>Calculate the permittivity tensor for the layer. DEPRECATED - use calculate_tensors().</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_eps_tensor(self):\n    \"\"\"Calculate the permittivity tensor for the layer. DEPRECATED - use calculate_tensors().\"\"\"\n    import warnings\n\n    warnings.warn(\n        \"calculate_eps_tensor() is deprecated. Use calculate_tensors() instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    self.calculate_tensors()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.calculate_tensors","title":"<code>calculate_tensors()</code>","text":"<p>Calculate both permittivity and magnetic tensors for the layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_tensors(self):\n    \"\"\"Calculate both permittivity and magnetic tensors for the layer.\"\"\"\n    self.material_factory()\n\n    if self.scenario in [\"Incident\", \"Azimuthal\"]:\n        self.eps_tensor = self.material.fetch_permittivity_tensor().astype(np.complex128)\n        self.mu_tensor = self.material.fetch_magnetic_tensor().astype(np.complex128)\n    elif self.scenario in [\"Dispersion\", \"Simple\"]:\n        self.eps_tensor = self.material.fetch_permittivity_tensor_for_freq(\n            self.frequency\n        ).astype(np.complex128)\n        self.mu_tensor = self.material.fetch_magnetic_tensor_for_freq(self.frequency).astype(\n            np.complex128\n        )\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.calculate_z_rotation","title":"<code>calculate_z_rotation()</code>","text":"<p>Calculate the rotation of the layer in the z direction.</p> <p>If the scenario is dispersion, azimuthal, or simple, the rotation is relative to the azimuthal angle, but can be defined to be static while all other layers are rotated. If it's relative, the rotation is added to the azimuthal angle as it has been 'shifted'.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_z_rotation(self):\n    \"\"\"\n    Calculate the rotation of the layer in the z direction.\n\n    If the scenario is dispersion, azimuthal, or simple, the rotation is relative to\n    the azimuthal angle, but can be defined to be static while all other\n    layers are rotated. If it's relative, the rotation is added to the\n    azimuthal angle as it has been 'shifted'.\n    \"\"\"\n    if self.scenario in [\"Dispersion\", \"Azimuthal\", \"Simple\"]:\n        if self.rotationZ_type == \"relative\":\n            self.rotationZ = self.azimuthal_angle + self.rotationZ\n        elif self.rotationZ_type == \"static\":\n            if self.scenario == \"Simple\":\n                # For simple scenario, keep as scalar\n                self.rotationZ = self.rotationZ\n            else:\n                self.rotationZ = self.rotationZ * np.ones_like(self.azimuthal_angle)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.material_factory","title":"<code>material_factory()</code>","text":"<p>Create the material object based on the material name or specifications.</p> <p>This method handles both predefined materials (like Quartz, Sapphire) and arbitrary materials specified via a dictionary of parameters.</p> <p>Returns:</p> Type Description <p>Material object: An instance of a material class with the specified properties</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def material_factory(self):\n    \"\"\"Create the material object based on the material name or specifications.\n\n    This method handles both predefined materials (like Quartz, Sapphire) and\n    arbitrary materials specified via a dictionary of parameters.\n\n    Returns:\n        Material object: An instance of a material class with the specified properties\n    \"\"\"\n    if isinstance(self.material, dict):\n        # Create an ArbitraryMaterial instance instead of returning the dict\n        self.material = ArbitraryMaterial(self.material)\n    elif self.material == \"Quartz\":\n        self.material = Quartz()\n    elif self.material == \"Sapphire\":\n        self.material = Sapphire()\n    elif self.material == \"Calcite\":\n        self.material = CalciteUpper()\n    elif self.material == \"CalciteLower\":\n        self.material = CalciteLower()\n    elif self.material == \"GalliumOxide\":\n        self.material = GalliumOxide()\n    else:\n        raise NotImplementedError(f\"Material {self.material} not implemented\")\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.rotate_tensor","title":"<code>rotate_tensor()</code>","text":"<p>Rotate the permittivity tensor according to the rotation angles. DEPRECATED - use rotate_tensors().</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def rotate_tensor(self):\n    \"\"\"Rotate the permittivity tensor according to the rotation angles.\n    DEPRECATED - use rotate_tensors().\"\"\"\n    import warnings\n\n    warnings.warn(\n        \"rotate_tensor() is deprecated. Use rotate_tensors() instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    self.rotate_tensors()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.rotate_tensors","title":"<code>rotate_tensors()</code>","text":"<p>Rotate both permittivity and magnetic tensors according to the rotation angles.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def rotate_tensors(self):\n    \"\"\"Rotate both permittivity and magnetic tensors according to the rotation angles.\"\"\"\n    if self.scenario in [\"Incident\", \"Dispersion\"]:\n        rotation_func = anisotropy_rotation_one_value\n    elif self.scenario == \"Azimuthal\":\n        rotation_func = anisotropy_rotation_one_axis\n    elif self.scenario == \"Simple\":\n        rotation_func = anisotropy_rotation_one_value\n\n    self.eps_tensor = rotation_func(\n        self.eps_tensor, self.rotationX, self.rotationY, self.rotationZ\n    )\n    self.mu_tensor = rotation_func(\n        self.mu_tensor, self.rotationX, self.rotationY, self.rotationZ\n    )\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.LayerFactory","title":"<code>LayerFactory</code>","text":"<p>Factory class for creating layers.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class LayerFactory:\n    \"\"\"Factory class for creating layers.\"\"\"\n\n    def __init__(self):\n        self.layer_classes = {\n            \"Ambient Incident Layer\": PrismLayer,\n            \"Isotropic Middle-Stack Layer\": AirGapLayer,\n            \"Crystal Layer\": CrystalLayer,\n            \"Semi Infinite Anisotropic Layer\": SemiInfiniteCrystalLayer,\n            \"Semi Infinite Isotropic Layer\": IsotropicSemiInfiniteLayer,\n        }\n\n    def create_layer(self, layer_data, scenario, kx, k0):\n        \"\"\"Create a layer from the layer data.\"\"\"\n        layer_class = self.layer_classes.get(layer_data[\"type\"])\n        if layer_class is not None:\n            return layer_class(layer_data, scenario, kx, k0)\n        else:\n            raise ValueError(f\"Invalid layer type {layer_data['type']}\")\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.LayerFactory.create_layer","title":"<code>create_layer(layer_data, scenario, kx, k0)</code>","text":"<p>Create a layer from the layer data.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create_layer(self, layer_data, scenario, kx, k0):\n    \"\"\"Create a layer from the layer data.\"\"\"\n    layer_class = self.layer_classes.get(layer_data[\"type\"])\n    if layer_class is not None:\n        return layer_class(layer_data, scenario, kx, k0)\n    else:\n        raise ValueError(f\"Invalid layer type {layer_data['type']}\")\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.PrismLayer","title":"<code>PrismLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>The incident coupling prism layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class PrismLayer(Layer):\n    \"\"\"The incident coupling prism layer.\"\"\"\n\n    def __init__(self, data, scenario, kx, k0):\n        super().__init__(data, scenario, kx, k0)\n        self.eps_prism = np.float64(data.get(\"permittivity\", 5.5))\n        self.create()\n\n    def create(self):\n        prism = AmbientIncidentMedium(self.eps_prism, self.kx)\n\n        if self.scenario == \"Incident\":\n            self.matrix = prism.construct_tensor()\n        elif self.scenario == \"Azimuthal\":\n            self.matrix = prism.construct_tensor_singular()[np.newaxis, np.newaxis, ...]\n        elif self.scenario == \"Dispersion\":\n            self.matrix = prism.construct_tensor()[:, np.newaxis, ...]\n        elif self.scenario == \"Simple\":\n            self.matrix = prism.construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.SemiInfiniteCrystalLayer","title":"<code>SemiInfiniteCrystalLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Anisotropic semi-infinite crystal layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class SemiInfiniteCrystalLayer(Layer):\n    \"\"\"Anisotropic semi-infinite crystal layer.\"\"\"\n\n    def __init__(self, data, scenario, kx, k0):\n        super().__init__(data, scenario, kx, k0)\n        self.calculate_z_rotation()\n        # CHANGED: Use the new unified tensor calculation methods\n        self.calculate_tensors()  # Get both eps and mu tensors\n        self.rotate_tensors()  # Rotate both tensors\n        self.create()\n\n    def create(self):\n        # CHANGED: Pass both tensors to Wave\n        self.profile, self.matrix = Wave(\n            self.kx,\n            self.eps_tensor,\n            self.mu_tensor,  # Now using the actual magnetic tensor from material\n            self.scenario,\n            semi_infinite=True,\n        ).execute()\n</code></pre>"},{"location":"api/materials/","title":"Materials API","text":""},{"location":"api/materials/#hyperbolic_optics.materials","title":"<code>hyperbolic_optics.materials</code>","text":""},{"location":"api/materials/#hyperbolic_optics.materials.Air","title":"<code>Air</code>","text":"<p>               Bases: <code>IsotropicMaterial</code></p> <p>Air material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Air(IsotropicMaterial):\n    \"\"\"Air material implementation.\"\"\"\n\n    def __init__(self, permittivity=None, permeability=None):\n        if permittivity is None:\n            params = load_material_parameters()[\"isotropic_materials\"][\"air\"]\n            permittivity = params[\"permittivity\"]\n\n        if permeability is None:\n            permeability = 1.0\n\n        super().__init__(permittivity=permittivity, permeability=permeability)\n        self.name = \"Air\"\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial","title":"<code>ArbitraryMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Material with arbitrary permittivity and permeability tensor components.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class ArbitraryMaterial(BaseMaterial):\n    \"\"\"Material with arbitrary permittivity and permeability tensor components.\"\"\"\n\n    def __init__(self, material_data=None):\n        super().__init__()\n        self.name = \"Arbitrary Material\"\n\n        if material_data is None:\n            material_data = load_material_parameters()[\"arbitrary_materials\"][\"default\"]\n\n        self._init_tensor_components(material_data)\n\n    def _to_complex(self, value):\n        \"\"\"Convert various input formats to complex numbers.\"\"\"\n        if value is None:\n            return complex(0, 0)\n        if isinstance(value, dict):\n            return complex(value.get(\"real\", 0), value.get(\"imag\", 0))\n        if isinstance(value, str):\n            try:\n                return complex(value.replace(\" \", \"\"))\n            except ValueError:\n                return complex(0, 0)\n        return complex(value, 0)\n\n    def _init_tensor_components(self, material_data):\n        \"\"\"Initialize tensor components from material data.\"\"\"\n        # Permittivity components\n        eps_components = {\n            \"eps_xx\": 1.0,\n            \"eps_yy\": 1.0,\n            \"eps_zz\": 1.0,\n            \"eps_xy\": 0.0,\n            \"eps_xz\": 0.0,\n            \"eps_yz\": 0.0,\n        }\n\n        # Magnetic permeability components\n        mu_components = {\n            \"mu_xx\": 1.0,\n            \"mu_yy\": 1.0,\n            \"mu_zz\": 1.0,\n            \"mu_xy\": 0.0,\n            \"mu_xz\": 0.0,\n            \"mu_yz\": 0.0,\n        }\n\n        all_components = {**eps_components, **mu_components}\n\n        for key, default in all_components.items():\n            value = material_data.get(key, default)\n            setattr(self, key, self._to_complex(value))\n\n        # Backward compatibility: if only mu_r is specified\n        if \"mu_r\" in material_data:\n            mu_r_val = self._to_complex(material_data[\"mu_r\"])\n            self.mu_xx = self.mu_yy = self.mu_zz = mu_r_val\n\n    def fetch_permittivity_tensor(self):\n        \"\"\"Construct and return the complete permittivity tensor.\"\"\"\n        tensor_elements = [\n            [self.eps_xx, self.eps_xy, self.eps_xz],\n            [self.eps_xy, self.eps_yy, self.eps_yz],\n            [self.eps_xz, self.eps_yz, self.eps_zz],\n        ]\n        return np.array(tensor_elements, dtype=np.complex128)\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n        \"\"\"Return frequency-independent permittivity tensor.\"\"\"\n        return self.fetch_permittivity_tensor()\n\n    def fetch_magnetic_tensor(self):\n        \"\"\"Construct and return the complete magnetic permeability tensor.\"\"\"\n        tensor_elements = [\n            [self.mu_xx, self.mu_xy, self.mu_xz],\n            [self.mu_xy, self.mu_yy, self.mu_yz],\n            [self.mu_xz, self.mu_yz, self.mu_zz],\n        ]\n        return np.array(tensor_elements, dtype=np.complex128)\n\n    def fetch_magnetic_tensor_for_freq(self, requested_frequency):\n        \"\"\"Return frequency-independent magnetic tensor.\"\"\"\n        return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_magnetic_tensor","title":"<code>fetch_magnetic_tensor()</code>","text":"<p>Construct and return the complete magnetic permeability tensor.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor(self):\n    \"\"\"Construct and return the complete magnetic permeability tensor.\"\"\"\n    tensor_elements = [\n        [self.mu_xx, self.mu_xy, self.mu_xz],\n        [self.mu_xy, self.mu_yy, self.mu_yz],\n        [self.mu_xz, self.mu_yz, self.mu_zz],\n    ]\n    return np.array(tensor_elements, dtype=np.complex128)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_magnetic_tensor_for_freq","title":"<code>fetch_magnetic_tensor_for_freq(requested_frequency)</code>","text":"<p>Return frequency-independent magnetic tensor.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor_for_freq(self, requested_frequency):\n    \"\"\"Return frequency-independent magnetic tensor.\"\"\"\n    return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Construct and return the complete permittivity tensor.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self):\n    \"\"\"Construct and return the complete permittivity tensor.\"\"\"\n    tensor_elements = [\n        [self.eps_xx, self.eps_xy, self.eps_xz],\n        [self.eps_xy, self.eps_yy, self.eps_yz],\n        [self.eps_xz, self.eps_yz, self.eps_zz],\n    ]\n    return np.array(tensor_elements, dtype=np.complex128)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Return frequency-independent permittivity tensor.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n    \"\"\"Return frequency-independent permittivity tensor.\"\"\"\n    return self.fetch_permittivity_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial","title":"<code>BaseMaterial</code>","text":"<p>Base class for all materials providing common functionality.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class BaseMaterial:\n    \"\"\"Base class for all materials providing common functionality.\"\"\"\n\n    def __init__(self, frequency_length=410):\n        self.frequency_length = frequency_length\n        self.name = \"Base Material\"\n        self.frequency = None\n        self.mu_r = 1.0  # Default magnetic permeability\n\n    def _initialize_frequency_range(self, params, freq_min=None, freq_max=None):\n        \"\"\"Initialize frequency range based on params or defaults.\"\"\"\n        if \"frequency_range\" not in params:\n            return\n\n        freq_range = params[\"frequency_range\"]\n        if freq_min is None:\n            freq_min = freq_range[\"default_min\"]\n        if freq_max is None:\n            freq_max = freq_range[\"default_max\"]\n\n        self.frequency = np.linspace(freq_min, freq_max, self.frequency_length, dtype=np.float64)\n\n    def _create_isotropic_mu_tensor_like(self, eps_tensor):\n        \"\"\"Create isotropic magnetic tensor with same shape as eps_tensor.\"\"\"\n        # Create identity matrix with same shape as eps_tensor\n        shape = eps_tensor.shape[:-2] + (3, 3)\n        mu_tensor = np.zeros(shape, dtype=np.complex128)\n\n        # Fill diagonal with mu_r\n        if len(shape) == 2:  # Simple 3x3 case\n            np.fill_diagonal(mu_tensor, self.mu_r)\n        else:  # Handle batch dimensions\n            # Reshape to 2D, fill diagonal, reshape back\n            original_shape = mu_tensor.shape\n            n_matrices = np.prod(original_shape[:-2])\n            mu_tensor_2d = mu_tensor.reshape(n_matrices, 3, 3)\n            for i in range(n_matrices):\n                np.fill_diagonal(mu_tensor_2d[i], self.mu_r)\n            mu_tensor = mu_tensor_2d.reshape(original_shape)\n\n        return mu_tensor.astype(np.complex128)\n\n    def fetch_magnetic_tensor(self):\n        \"\"\"Fetch magnetic permeability tensor. Default is isotropic.\"\"\"\n        eps_tensor = self.fetch_permittivity_tensor()\n        return self._create_isotropic_mu_tensor_like(eps_tensor)\n\n    def fetch_magnetic_tensor_for_freq(self, requested_frequency):\n        \"\"\"Fetch magnetic tensor for specific frequency. Default is isotropic.\"\"\"\n        eps_tensor = self.fetch_permittivity_tensor_for_freq(requested_frequency)\n        return self._create_isotropic_mu_tensor_like(eps_tensor)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial.fetch_magnetic_tensor","title":"<code>fetch_magnetic_tensor()</code>","text":"<p>Fetch magnetic permeability tensor. Default is isotropic.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor(self):\n    \"\"\"Fetch magnetic permeability tensor. Default is isotropic.\"\"\"\n    eps_tensor = self.fetch_permittivity_tensor()\n    return self._create_isotropic_mu_tensor_like(eps_tensor)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial.fetch_magnetic_tensor_for_freq","title":"<code>fetch_magnetic_tensor_for_freq(requested_frequency)</code>","text":"<p>Fetch magnetic tensor for specific frequency. Default is isotropic.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor_for_freq(self, requested_frequency):\n    \"\"\"Fetch magnetic tensor for specific frequency. Default is isotropic.\"\"\"\n    eps_tensor = self.fetch_permittivity_tensor_for_freq(requested_frequency)\n    return self._create_isotropic_mu_tensor_like(eps_tensor)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Calcite","title":"<code>Calcite</code>","text":"<p>               Bases: <code>ParameterizedUniaxialMaterial</code></p> <p>Calcite material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Calcite(ParameterizedUniaxialMaterial):\n    \"\"\"Calcite material implementation.\"\"\"\n\n    def __init__(self, freq_min=None, freq_max=None, variant=None, mu_r=1.0):\n        if variant is None:\n            raise ValueError(\n                \"Calcite material must be instantiated with a variant ('lower' or 'upper')\"\n            )\n\n        calcite_config = load_material_parameters()[\"uniaxial_materials\"][\"calcite\"]\n        super().__init__(\"calcite\", freq_min, freq_max, mu_r)\n\n        if variant not in calcite_config[\"variants\"]:\n            raise ValueError(\"Calcite variant must be either 'lower' or 'upper'\")\n\n        variant_params = calcite_config[\"variants\"][variant]\n        self.name = variant_params.get(\"name\", self.name)\n        self._initialize_frequency_range(variant_params, freq_min, freq_max)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.CalciteLower","title":"<code>CalciteLower</code>","text":"<p>               Bases: <code>Calcite</code></p> <p>Lower frequency range Calcite implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class CalciteLower(Calcite):\n    \"\"\"Lower frequency range Calcite implementation.\"\"\"\n\n    def __init__(self, freq_min=None, freq_max=None, mu_r=1.0):\n        super().__init__(freq_min, freq_max, variant=\"lower\", mu_r=mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.CalciteUpper","title":"<code>CalciteUpper</code>","text":"<p>               Bases: <code>Calcite</code></p> <p>Upper frequency range Calcite implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class CalciteUpper(Calcite):\n    \"\"\"Upper frequency range Calcite implementation.\"\"\"\n\n    def __init__(self, freq_min=None, freq_max=None, mu_r=1.0):\n        super().__init__(freq_min, freq_max, variant=\"upper\", mu_r=mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide","title":"<code>GalliumOxide</code>","text":"<p>               Bases: <code>MonoclinicMaterial</code></p> <p>Gallium Oxide implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class GalliumOxide(MonoclinicMaterial):\n    \"\"\"Gallium Oxide implementation.\"\"\"\n\n    def __init__(self, freq_min=None, freq_max=None, mu_r=1.0):\n        super().__init__()\n        params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"]\n        self.name = params[\"name\"]\n        self.mu_r = mu_r\n        self._initialize_frequency_range(params, freq_min, freq_max)\n\n    def permittivity_parameters(self):\n        \"\"\"Get Gallium Oxide permittivity parameters.\"\"\"\n        params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"][\"parameters\"]\n        # Convert all numeric values to numpy arrays\n        result = {}\n        for mode, mode_params in params.items():\n            result[mode] = {}\n            for key, value in mode_params.items():\n                if isinstance(value, dict):\n                    result[mode][key] = value  # Keep high_freq dict as is\n                elif isinstance(value, list):\n                    result[mode][key] = np.array(value, dtype=np.complex128)\n                else:\n                    result[mode][key] = np.complex128(value)\n        return result\n\n    def _create_permittivity_tensor(self, eps_xx, eps_yy, eps_zz, eps_xy):\n        \"\"\"Create the full permittivity tensor.\"\"\"\n        zeros = np.zeros_like(eps_xx)\n        tensor = np.array(\n            [[eps_xx, eps_xy, zeros], [eps_xy, eps_yy, zeros], [zeros, zeros, eps_zz]],\n            dtype=np.complex128,\n        )\n\n        # Move frequency axis to first dimension if needed\n        if tensor.shape[-1] != 3:\n            tensor = np.moveaxis(tensor, -1, 0)\n\n        return tensor\n\n    def permittivity_calc(self):\n        \"\"\"Calculate all permittivity components.\"\"\"\n        parameters = self.permittivity_parameters()\n        frequency = self.frequency[:, np.newaxis]\n\n        eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n        eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n        eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu\n        eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu\n        eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu\n        eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au\n\n        return eps_xx, eps_yy, eps_zz, eps_xy\n\n    def fetch_permittivity_tensor(self):\n        \"\"\"Get the full permittivity tensor.\"\"\"\n        eps_xx, eps_yy, eps_zz, eps_xy = self.permittivity_calc()\n        return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n        \"\"\"Get permittivity tensor for a specific frequency.\"\"\"\n        parameters = self.permittivity_parameters()\n        frequency = np.array([[requested_frequency]], dtype=np.float64)\n\n        eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n        eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n        eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu[0]\n        eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu[0]\n        eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu[0]\n        eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au[0]\n\n        return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Get the full permittivity tensor.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self):\n    \"\"\"Get the full permittivity tensor.\"\"\"\n    eps_xx, eps_yy, eps_zz, eps_xy = self.permittivity_calc()\n    return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Get permittivity tensor for a specific frequency.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n    \"\"\"Get permittivity tensor for a specific frequency.\"\"\"\n    parameters = self.permittivity_parameters()\n    frequency = np.array([[requested_frequency]], dtype=np.float64)\n\n    eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n    eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n    eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu[0]\n    eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu[0]\n    eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu[0]\n    eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au[0]\n\n    return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.permittivity_calc","title":"<code>permittivity_calc()</code>","text":"<p>Calculate all permittivity components.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_calc(self):\n    \"\"\"Calculate all permittivity components.\"\"\"\n    parameters = self.permittivity_parameters()\n    frequency = self.frequency[:, np.newaxis]\n\n    eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n    eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n    eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu\n    eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu\n    eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu\n    eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au\n\n    return eps_xx, eps_yy, eps_zz, eps_xy\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.permittivity_parameters","title":"<code>permittivity_parameters()</code>","text":"<p>Get Gallium Oxide permittivity parameters.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_parameters(self):\n    \"\"\"Get Gallium Oxide permittivity parameters.\"\"\"\n    params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"][\"parameters\"]\n    # Convert all numeric values to numpy arrays\n    result = {}\n    for mode, mode_params in params.items():\n        result[mode] = {}\n        for key, value in mode_params.items():\n            if isinstance(value, dict):\n                result[mode][key] = value  # Keep high_freq dict as is\n            elif isinstance(value, list):\n                result[mode][key] = np.array(value, dtype=np.complex128)\n            else:\n                result[mode][key] = np.complex128(value)\n    return result\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial","title":"<code>IsotropicMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Base class for isotropic materials like air.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class IsotropicMaterial(BaseMaterial):\n    \"\"\"Base class for isotropic materials like air.\"\"\"\n\n    def __init__(self, permittivity=None, permeability=None):\n        super().__init__()\n        self.permittivity = self._process_permittivity(permittivity)\n        self.permeability = (\n            self._process_permittivity(permeability)\n            if permeability is not None\n            else complex(1.0, 0.0)\n        )\n\n    def _process_permittivity(self, permittivity):\n        \"\"\"Convert permittivity input to complex number.\"\"\"\n        if permittivity is None:\n            return complex(1.0, 0.0)\n\n        if isinstance(permittivity, dict):\n            return complex(permittivity.get(\"real\", 0), permittivity.get(\"imag\", 0))\n        if isinstance(permittivity, (int, float, complex)):\n            return complex(permittivity)\n        return permittivity\n\n    def construct_tensor_singular(self):\n        \"\"\"Create diagonal tensor with permittivity value.\"\"\"\n        return np.array(\n            [\n                [self.permittivity, 0.0, 0.0],\n                [0.0, self.permittivity, 0.0],\n                [0.0, 0.0, self.permittivity],\n            ],\n            dtype=np.complex128,\n        )\n\n    def fetch_permittivity_tensor(self):\n        \"\"\"Get permittivity tensor for isotropic material.\"\"\"\n        return self.construct_tensor_singular()\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n        \"\"\"Get permittivity tensor for specific frequency (frequency-independent).\"\"\"\n        return self.construct_tensor_singular()\n\n    def fetch_magnetic_tensor(self):\n        \"\"\"Get magnetic tensor for isotropic material.\"\"\"\n        return np.array(\n            [\n                [self.permeability, 0.0, 0.0],\n                [0.0, self.permeability, 0.0],\n                [0.0, 0.0, self.permeability],\n            ],\n            dtype=np.complex128,\n        )\n\n    def fetch_magnetic_tensor_for_freq(self, requested_frequency):\n        \"\"\"Get magnetic tensor for specific frequency (frequency-independent).\"\"\"\n        return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.construct_tensor_singular","title":"<code>construct_tensor_singular()</code>","text":"<p>Create diagonal tensor with permittivity value.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def construct_tensor_singular(self):\n    \"\"\"Create diagonal tensor with permittivity value.\"\"\"\n    return np.array(\n        [\n            [self.permittivity, 0.0, 0.0],\n            [0.0, self.permittivity, 0.0],\n            [0.0, 0.0, self.permittivity],\n        ],\n        dtype=np.complex128,\n    )\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_magnetic_tensor","title":"<code>fetch_magnetic_tensor()</code>","text":"<p>Get magnetic tensor for isotropic material.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor(self):\n    \"\"\"Get magnetic tensor for isotropic material.\"\"\"\n    return np.array(\n        [\n            [self.permeability, 0.0, 0.0],\n            [0.0, self.permeability, 0.0],\n            [0.0, 0.0, self.permeability],\n        ],\n        dtype=np.complex128,\n    )\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_magnetic_tensor_for_freq","title":"<code>fetch_magnetic_tensor_for_freq(requested_frequency)</code>","text":"<p>Get magnetic tensor for specific frequency (frequency-independent).</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor_for_freq(self, requested_frequency):\n    \"\"\"Get magnetic tensor for specific frequency (frequency-independent).\"\"\"\n    return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Get permittivity tensor for isotropic material.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self):\n    \"\"\"Get permittivity tensor for isotropic material.\"\"\"\n    return self.construct_tensor_singular()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Get permittivity tensor for specific frequency (frequency-independent).</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n    \"\"\"Get permittivity tensor for specific frequency (frequency-independent).\"\"\"\n    return self.construct_tensor_singular()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.MonoclinicMaterial","title":"<code>MonoclinicMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Base class for monoclinic materials with more complex permittivity tensors.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class MonoclinicMaterial(BaseMaterial):\n    \"\"\"Base class for monoclinic materials with more complex permittivity tensors.\"\"\"\n\n    def _calculate_bu_components(self, parameters, frequency):\n        \"\"\"Calculate Bu mode components of permittivity.\"\"\"\n        partial_calc_tn_bu = parameters[\"Bu\"][\"amplitude\"] ** 2.0 / (\n            parameters[\"Bu\"][\"omega_tn\"] ** 2.0\n            - frequency**2.0\n            - 1j * frequency * parameters[\"Bu\"][\"gamma_tn\"]\n        )\n\n        alpha_rad = parameters[\"Bu\"][\"alpha_tn\"] * np.pi / 180.0\n        cos_alpha = np.cos(alpha_rad)\n        sin_alpha = np.sin(alpha_rad)\n\n        eps_xx_bu = np.sum(partial_calc_tn_bu * cos_alpha**2.0, axis=1)\n        eps_xy_bu = np.sum(partial_calc_tn_bu * sin_alpha * cos_alpha, axis=1)\n        eps_yy_bu = np.sum(partial_calc_tn_bu * sin_alpha**2.0, axis=1)\n\n        return eps_xx_bu, eps_xy_bu, eps_yy_bu\n\n    def _calculate_au_component(self, parameters, frequency):\n        \"\"\"Calculate Au mode component of permittivity.\"\"\"\n        partial_calc_tn_au = parameters[\"Au\"][\"amplitude\"] ** 2.0 / (\n            parameters[\"Au\"][\"omega_tn\"] ** 2.0\n            - frequency**2.0\n            - 1j * frequency * parameters[\"Au\"][\"gamma_tn\"]\n        )\n        return np.sum(partial_calc_tn_au, axis=1)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ParameterizedUniaxialMaterial","title":"<code>ParameterizedUniaxialMaterial</code>","text":"<p>               Bases: <code>UniaxialMaterial</code></p> <p>Base class for uniaxial materials with parameters from configuration.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class ParameterizedUniaxialMaterial(UniaxialMaterial):\n    \"\"\"Base class for uniaxial materials with parameters from configuration.\"\"\"\n\n    def __init__(self, material_type, freq_min=None, freq_max=None, mu_r=1.0):\n        super().__init__()\n        params = load_material_parameters()[\"uniaxial_materials\"][material_type]\n        self.name = params.get(\"name\", \"Unnamed Material\")\n        self.material_type = material_type\n        self.mu_r = mu_r\n\n        if \"frequency_range\" in params:\n            self._initialize_frequency_range(params, freq_min, freq_max)\n        else:\n            self.frequency = None\n\n    def permittivity_parameters(self):\n        \"\"\"Get permittivity parameters from configuration.\"\"\"\n        params = load_material_parameters()[\"uniaxial_materials\"][self.material_type][\"parameters\"]\n        return {\n            axis: {key: np.array(value, dtype=np.complex128) for key, value in axis_params.items()}\n            for axis, axis_params in params.items()\n        }\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ParameterizedUniaxialMaterial.permittivity_parameters","title":"<code>permittivity_parameters()</code>","text":"<p>Get permittivity parameters from configuration.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_parameters(self):\n    \"\"\"Get permittivity parameters from configuration.\"\"\"\n    params = load_material_parameters()[\"uniaxial_materials\"][self.material_type][\"parameters\"]\n    return {\n        axis: {key: np.array(value, dtype=np.complex128) for key, value in axis_params.items()}\n        for axis, axis_params in params.items()\n    }\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Quartz","title":"<code>Quartz</code>","text":"<p>               Bases: <code>ParameterizedUniaxialMaterial</code></p> <p>Quartz material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Quartz(ParameterizedUniaxialMaterial):\n    \"\"\"Quartz material implementation.\"\"\"\n\n    def __init__(self, freq_min=None, freq_max=None, mu_r=1.0):\n        super().__init__(\"quartz\", freq_min, freq_max, mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Sapphire","title":"<code>Sapphire</code>","text":"<p>               Bases: <code>ParameterizedUniaxialMaterial</code></p> <p>Sapphire material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Sapphire(ParameterizedUniaxialMaterial):\n    \"\"\"Sapphire material implementation.\"\"\"\n\n    def __init__(self, freq_min=None, freq_max=None, mu_r=1.0):\n        super().__init__(\"sapphire\", freq_min, freq_max, mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial","title":"<code>UniaxialMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Base class for anisotropic materials with a single optical axis.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class UniaxialMaterial(BaseMaterial):\n    \"\"\"Base class for anisotropic materials with a single optical axis.\"\"\"\n\n    def permittivity_calc_for_freq(\n        self, frequency, high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln\n    ):\n        \"\"\"Calculate permittivity for a given frequency using provided parameters.\"\"\"\n        frequency = np.array([frequency], dtype=np.float64)\n\n        # Convert parameters to numpy arrays\n        omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n        gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n        omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n        gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n        # Expand dimensions for broadcasting\n        omega_ln_expanded = omega_ln[:, np.newaxis]\n        gamma_ln_expanded = gamma_ln[:, np.newaxis]\n        omega_tn_expanded = omega_tn[:, np.newaxis]\n        gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n        top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n        bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n        result = top_line / bottom_line\n\n        return (high_freq * np.prod(result, axis=0))[0]\n\n    def permittivity_calc(self, high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln):\n        \"\"\"Calculate permittivity over the frequency range.\"\"\"\n        frequency = np.expand_dims(self.frequency, 0)\n\n        # Convert parameters to numpy arrays\n        omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n        gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n        omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n        gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n        omega_ln_expanded = omega_ln[:, np.newaxis]\n        gamma_ln_expanded = gamma_ln[:, np.newaxis]\n        omega_tn_expanded = omega_tn[:, np.newaxis]\n        gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n        top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n        bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n        result = top_line / bottom_line\n\n        return high_freq * np.prod(result, axis=0)\n\n    def _create_permittivity_tensor(self, eps_ext, eps_ord):\n        \"\"\"Create permittivity tensor from extraordinary and ordinary values.\"\"\"\n        if np.isscalar(eps_ext):\n            # Single frequency case\n            return np.diag([eps_ord, eps_ord, eps_ext]).astype(np.complex128)\n        else:\n            # Multiple frequency case\n            diag_tensors = np.stack([eps_ord, eps_ord, eps_ext], axis=-1)\n            # Create diagonal matrices\n            result = np.zeros(diag_tensors.shape[:-1] + (3, 3), dtype=np.complex128)\n            for i in range(result.shape[0]):\n                result[i] = np.diag(diag_tensors[i])\n            return result\n\n    def fetch_permittivity_tensor(self):\n        \"\"\"Fetch full permittivity tensor.\"\"\"\n        eps_ext, eps_ord = self.permittivity_fetch()\n        return self._create_permittivity_tensor(eps_ext, eps_ord)\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n        \"\"\"Fetch permittivity tensor for a specific frequency.\"\"\"\n        params = self.permittivity_parameters()\n        eps_ext = self.permittivity_calc_for_freq(requested_frequency, **params[\"extraordinary\"])\n        eps_ord = self.permittivity_calc_for_freq(requested_frequency, **params[\"ordinary\"])\n        return self._create_permittivity_tensor(eps_ext, eps_ord)\n\n    def permittivity_fetch(self):\n        \"\"\"Fetch permittivity values for ordinary and extraordinary axes.\"\"\"\n        params = self.permittivity_parameters()\n        eps_ext = self.permittivity_calc(**params[\"extraordinary\"])\n        eps_ord = self.permittivity_calc(**params[\"ordinary\"])\n        return eps_ext, eps_ord\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Fetch full permittivity tensor.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self):\n    \"\"\"Fetch full permittivity tensor.\"\"\"\n    eps_ext, eps_ord = self.permittivity_fetch()\n    return self._create_permittivity_tensor(eps_ext, eps_ord)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Fetch permittivity tensor for a specific frequency.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency):\n    \"\"\"Fetch permittivity tensor for a specific frequency.\"\"\"\n    params = self.permittivity_parameters()\n    eps_ext = self.permittivity_calc_for_freq(requested_frequency, **params[\"extraordinary\"])\n    eps_ord = self.permittivity_calc_for_freq(requested_frequency, **params[\"ordinary\"])\n    return self._create_permittivity_tensor(eps_ext, eps_ord)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.permittivity_calc","title":"<code>permittivity_calc(high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln)</code>","text":"<p>Calculate permittivity over the frequency range.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_calc(self, high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln):\n    \"\"\"Calculate permittivity over the frequency range.\"\"\"\n    frequency = np.expand_dims(self.frequency, 0)\n\n    # Convert parameters to numpy arrays\n    omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n    gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n    omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n    gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n    omega_ln_expanded = omega_ln[:, np.newaxis]\n    gamma_ln_expanded = gamma_ln[:, np.newaxis]\n    omega_tn_expanded = omega_tn[:, np.newaxis]\n    gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n    top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n    bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n    result = top_line / bottom_line\n\n    return high_freq * np.prod(result, axis=0)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.permittivity_calc_for_freq","title":"<code>permittivity_calc_for_freq(frequency, high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln)</code>","text":"<p>Calculate permittivity for a given frequency using provided parameters.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_calc_for_freq(\n    self, frequency, high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln\n):\n    \"\"\"Calculate permittivity for a given frequency using provided parameters.\"\"\"\n    frequency = np.array([frequency], dtype=np.float64)\n\n    # Convert parameters to numpy arrays\n    omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n    gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n    omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n    gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n    # Expand dimensions for broadcasting\n    omega_ln_expanded = omega_ln[:, np.newaxis]\n    gamma_ln_expanded = gamma_ln[:, np.newaxis]\n    omega_tn_expanded = omega_tn[:, np.newaxis]\n    gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n    top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n    bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n    result = top_line / bottom_line\n\n    return (high_freq * np.prod(result, axis=0))[0]\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.permittivity_fetch","title":"<code>permittivity_fetch()</code>","text":"<p>Fetch permittivity values for ordinary and extraordinary axes.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_fetch(self):\n    \"\"\"Fetch permittivity values for ordinary and extraordinary axes.\"\"\"\n    params = self.permittivity_parameters()\n    eps_ext = self.permittivity_calc(**params[\"extraordinary\"])\n    eps_ord = self.permittivity_calc(**params[\"ordinary\"])\n    return eps_ext, eps_ord\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.load_material_parameters","title":"<code>load_material_parameters()</code>","text":"<p>Load material parameters from the JSON configuration file.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def load_material_parameters():\n    \"\"\"Load material parameters from the JSON configuration file.\"\"\"\n    config_path = Path(__file__).parent / \"material_params.json\"\n    with open(config_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/mueller/","title":"Mueller API","text":""},{"location":"api/mueller/#hyperbolic_optics.mueller","title":"<code>hyperbolic_optics.mueller</code>","text":""},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller","title":"<code>Mueller</code>","text":"Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>class Mueller:\n    def __init__(self, structure, debug=False):\n        \"\"\"\n        Initialize the Mueller class.\n\n        Args:\n            structure: The structure object containing scenario information.\n            debug (bool): Enable debug output (default: False)\n        \"\"\"\n        self.structure = structure\n        self.mueller_matrix = None\n        self.stokes_parameters = None\n        self.incident_stokes = np.array(\n            [1, 0, 0, 0], dtype=np.float64\n        )  # Default to unpolarized light\n        self.optical_components = []\n        self.anisotropic_sample_added = False\n        self.debug = debug\n\n    def _debug_print(self, message):\n        \"\"\"Print debug message if debug is enabled.\"\"\"\n        if self.debug:\n            print(message)\n\n    def _summarize_array(self, arr, name):\n        \"\"\"Summarize an array with statistics and sample points.\"\"\"\n        flat_arr = arr.flatten()\n        summary = (\n            f\"{name} - Shape: {arr.shape}, \"\n            f\"Min: {np.min(flat_arr):.6f}, Max: {np.max(flat_arr):.6f}, \"\n            f\"Mean: {np.mean(flat_arr):.6f}, Std: {np.std(flat_arr):.6f}\"\n        )\n        sample_points = np.linspace(0, len(flat_arr) - 1, 5, dtype=int)\n        samples = flat_arr[sample_points]\n        summary += f\"\\nSample points: {samples}\"\n        return summary\n\n    def set_incident_polarization(self, polarization_type, **kwargs):\n        \"\"\"\n        Set the incident polarization state.\n\n        Args:\n            polarization_type (str): Type of polarization ('linear', 'circular', or 'elliptical')\n            **kwargs: Additional arguments depending on the polarization type\n                For 'linear': angle (in degrees)\n                For 'circular': handedness ('right' or 'left')\n                For 'elliptical': alpha (in degrees), ellipticity (between -45 and 45 degrees)\n        \"\"\"\n        if polarization_type == \"linear\":\n            angle = kwargs.get(\"angle\", 0)\n            self.incident_stokes = self._linear_polarization(angle)\n        elif polarization_type == \"circular\":\n            handedness = kwargs.get(\"handedness\", \"right\")\n            self.incident_stokes = self._circular_polarization(handedness)\n        elif polarization_type == \"elliptical\":\n            alpha = kwargs.get(\"alpha\", 0)\n            ellipticity = kwargs.get(\"ellipticity\", 0)\n            self.incident_stokes = self._elliptical_polarization(alpha, ellipticity)\n        else:\n            raise ValueError(f\"Unsupported polarization type: {polarization_type}\")\n\n        self._debug_print(f\"Set incident polarization: {polarization_type}\")\n        self._debug_print(self._summarize_array(self.incident_stokes, \"Incident Stokes vector\"))\n\n    def _linear_polarization(self, angle):\n        \"\"\"\n        Create a Stokes vector for linear polarization.\n\n        Args:\n            angle (float): Angle of linear polarization in degrees\n            (0\u00b0 is p-polarized, 90\u00b0 is s-polarized)\n\n        Returns:\n            np.ndarray: Stokes vector for the specified linear polarization\n        \"\"\"\n        angle_rad = np.radians(angle)\n        return np.array([1, np.cos(2 * angle_rad), np.sin(2 * angle_rad), 0], dtype=np.float64)\n\n    def _circular_polarization(self, handedness):\n        \"\"\"\n        Create a Stokes vector for circular polarization.\n\n        Args:\n            handedness (str): 'right' for right-handed, 'left' for left-handed\n\n        Returns:\n            np.ndarray: Stokes vector for the specified circular polarization\n        \"\"\"\n        s3 = 1 if handedness == \"right\" else -1\n        return np.array([1, 0, 0, s3], dtype=np.float64)\n\n    def _elliptical_polarization(self, alpha, ellipticity):\n        \"\"\"\n        Create a Stokes vector for elliptical polarization.\n\n        Args:\n            alpha (float): Azimuth angle of the ellipse major axis in degrees\n            ellipticity (float): Ellipticity angle in degrees (between -45\u00b0 and 45\u00b0)\n\n        Returns:\n            np.ndarray: Stokes vector for the specified elliptical polarization\n        \"\"\"\n        alpha_rad = np.radians(alpha)\n        ellipticity_rad = np.radians(ellipticity)\n        return np.array(\n            [\n                1,\n                np.cos(2 * ellipticity_rad) * np.cos(2 * alpha_rad),\n                np.cos(2 * ellipticity_rad) * np.sin(2 * alpha_rad),\n                np.sin(2 * ellipticity_rad),\n            ],\n            dtype=np.float64,\n        )\n\n    def linear_polarizer(self, angle):\n        \"\"\"\n        Create a Mueller matrix for a linear polarizer at a given angle.\n\n        Args:\n            angle: Polarizer angle in degrees (float).\n\n        Returns:\n            Mueller matrix for the linear polarizer (np.ndarray).\n        \"\"\"\n        angle_rad = np.float64(np.radians(angle) * 2.0)\n\n        cos_angle = np.cos(angle_rad)\n        sin_angle = np.sin(angle_rad)\n\n        return 0.5 * np.array(\n            [\n                [1, cos_angle, sin_angle, 0],\n                [cos_angle, cos_angle**2.0, cos_angle * sin_angle, 0],\n                [sin_angle, cos_angle * sin_angle, sin_angle**2.0, 0],\n                [0, 0, 0, 0],\n            ],\n            dtype=np.float64,\n        )\n\n    def quarter_wave_plate(self, angle):\n        \"\"\"\n        Create a Mueller matrix for a quarter-wave plate at a given angle.\n\n        Args:\n            angle: Fast axis angle in degrees (float).\n\n        Returns:\n            Mueller matrix for the quarter-wave plate (np.ndarray).\n        \"\"\"\n        angle_rad = np.float64(np.radians(angle))\n        cos_angle = np.cos(2 * angle_rad)\n        sin_angle = np.sin(2 * angle_rad)\n\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, cos_angle**2, cos_angle * sin_angle, -sin_angle],\n                [0, cos_angle * sin_angle, sin_angle**2, cos_angle],\n                [0, sin_angle, -cos_angle, 0],\n            ],\n            dtype=np.float64,\n        )\n\n    def half_wave_plate(self, angle):\n        \"\"\"\n        Create a Mueller matrix for a half-wave plate at a given angle.\n\n        Args:\n            angle: Fast axis angle in degrees (float).\n\n        Returns:\n            Mueller matrix for the half-wave plate (np.ndarray).\n        \"\"\"\n        angle_rad = np.float64(np.radians(angle))\n        cos_angle = np.cos(2 * angle_rad)\n        sin_angle = np.sin(2 * angle_rad)\n\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, cos_angle**2 - sin_angle**2, 2 * cos_angle * sin_angle, 0],\n                [0, 2 * cos_angle * sin_angle, sin_angle**2 - cos_angle**2, 0],\n                [0, 0, 0, -1],\n            ],\n            dtype=np.float64,\n        )\n\n    def calculate_mueller_matrix(self):\n        \"\"\"\n        Calculate the Mueller matrix for the anisotropic sample using the reflection coefficients.\n        \"\"\"\n        r_pp = self.structure.r_pp\n        r_ps = self.structure.r_ps\n        r_sp = self.structure.r_sp\n        r_ss = self.structure.r_ss\n\n        f_matrix = np.array(\n            [\n                [\n                    r_pp * np.conj(r_pp),\n                    r_pp * np.conj(r_ps),\n                    r_ps * np.conj(r_pp),\n                    r_ps * np.conj(r_ps),\n                ],\n                [\n                    r_pp * np.conj(r_sp),\n                    r_pp * np.conj(r_ss),\n                    r_ps * np.conj(r_sp),\n                    r_ps * np.conj(r_ss),\n                ],\n                [\n                    r_sp * np.conj(r_pp),\n                    r_sp * np.conj(r_ps),\n                    r_ss * np.conj(r_pp),\n                    r_ss * np.conj(r_ps),\n                ],\n                [\n                    r_sp * np.conj(r_sp),\n                    r_sp * np.conj(r_ss),\n                    r_ss * np.conj(r_sp),\n                    r_ss * np.conj(r_ss),\n                ],\n            ],\n            dtype=np.complex128,\n        )\n\n        # Handle different scenario types\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, f_matrix is just [4, 4], no need to transpose\n            pass\n        else:\n            # For other scenarios, transpose as before\n            f_matrix = np.transpose(f_matrix, axes=[2, 3, 0, 1])\n\n        a_matrix = np.array(\n            [[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, 1j, -1j, 0]],\n            dtype=np.complex128,\n        )\n\n        # Add batch dimensions if needed\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, just compute matrix multiplication directly\n            self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n        else:\n            # For other scenarios, add batch dimensions\n            a_matrix = a_matrix[np.newaxis, np.newaxis, ...]\n            self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n\n        self._debug_print(\"Calculated Mueller matrix for anisotropic sample:\")\n        self._debug_print(self._summarize_array(self.mueller_matrix, \"Mueller matrix\"))\n\n    def add_optical_component(self, component_type, *args):\n        \"\"\"\n        Add an optical component to the system.\n\n        Args:\n            component_type: Type of the optical component (str).\n            *args: Arguments for the optical component (e.g., angle).\n        \"\"\"\n        if component_type == \"linear_polarizer\":\n            self.optical_components.append(self.linear_polarizer(*args))\n        elif component_type == \"anisotropic_sample\":\n            if self.anisotropic_sample_added:\n                raise ValueError(\"Anisotropic sample has already been added\")\n            self.calculate_mueller_matrix()\n            self.optical_components.append(self.mueller_matrix)\n            self.anisotropic_sample_added = True\n        elif component_type == \"quarter_wave_plate\":\n            self.optical_components.append(self.quarter_wave_plate(*args))\n        elif component_type == \"half_wave_plate\":\n            self.optical_components.append(self.half_wave_plate(*args))\n        else:\n            raise ValueError(f\"Unsupported optical component type: {component_type}\")\n        self._debug_print(f\"Added optical component: {component_type}\")\n\n    def calculate_stokes_parameters(self):\n        \"\"\"\n        Calculate the Stokes parameters of the system\n        using the set incident polarization and optical components.\n\n        Returns:\n            Stokes parameters of the system (np.ndarray).\n        \"\"\"\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, start with just the incident vector [4,]\n            stokes_vector = self.incident_stokes.reshape([4, 1])\n        else:\n            # For other scenarios, add batch dimensions\n            stokes_vector = self.incident_stokes.reshape([1, 1, 4, 1])\n\n        self._debug_print(f\"Initial Stokes vector: {stokes_vector.flatten()}\")\n\n        for i, component in enumerate(self.optical_components):\n            if self.structure.scenario.type == \"Simple\":\n                # For Simple scenario, component should be [4, 4]\n                stokes_vector = component @ stokes_vector\n            else:\n                # For other scenarios, component has batch dimensions\n                stokes_vector = component @ stokes_vector\n\n            self._debug_print(f\"After component {i}:\")\n            self._debug_print(self._summarize_array(stokes_vector, \"Stokes vector\"))\n\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, remove the last dimension [4, 1] -&gt; [4]\n            self.stokes_parameters = stokes_vector[:, 0]\n        else:\n            # For other scenarios, remove the last dimension [..., 4, 1] -&gt; [..., 4]\n            self.stokes_parameters = stokes_vector[..., 0]\n\n        self._debug_print(\"Final Stokes parameters:\")\n        self._debug_print(self._summarize_array(self.stokes_parameters, \"Stokes parameters\"))\n        return self.stokes_parameters\n\n    def get_reflectivity(self):\n        \"\"\"\n        Calculate the reflectivity of the system (S0 Stokes parameter).\n\n        Returns:\n            Reflectivity of the system (np.ndarray).\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        return self.stokes_parameters[..., 0]\n\n    def get_degree_of_polarisation(self):\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        s0 = self.stokes_parameters[..., 0]\n        s1 = self.stokes_parameters[..., 1]\n        s2 = self.stokes_parameters[..., 2]\n        s3 = self.stokes_parameters[..., 3]\n\n        # Avoid division by zero\n        epsilon = 1e-10\n        s0_safe = np.maximum(s0, epsilon)\n\n        dop = np.sqrt(s1**2 + s2**2 + s3**2) / s0_safe\n\n        # Clip to ensure DOP is always between 0 and 1\n        dop = np.clip(dop, 0.0, 1.0)\n\n        return dop\n\n    def get_ellipticity(self):\n        \"\"\"\n        Calculate the ellipticity of the polarization.\n\n        Returns:\n            Ellipticity of the polarization (np.ndarray).\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        s3 = self.stokes_parameters[..., 3]\n        s1 = self.stokes_parameters[..., 1]\n        s2 = self.stokes_parameters[..., 2]\n\n        return 0.5 * np.arctan2(s3, np.sqrt(s1**2 + s2**2))\n\n    def get_azimuth(self):\n        \"\"\"\n        Calculate the azimuth of the polarization.\n\n        Returns:\n            Azimuth of the polarization (np.ndarray).\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        s1 = self.stokes_parameters[..., 1]\n        s2 = self.stokes_parameters[..., 2]\n\n        return 0.5 * np.arctan2(s2, s1)\n\n    def get_stokes_parameters(self):\n        \"\"\"\n        Get the Stokes parameters for plotting.\n\n        Returns:\n            Dictionary of Stokes parameters (S0, S1, S2, S3).\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        return {\n            \"S0\": self.stokes_parameters[..., 0],\n            \"S1\": self.stokes_parameters[..., 1],\n            \"S2\": self.stokes_parameters[..., 2],\n            \"S3\": self.stokes_parameters[..., 3],\n        }\n\n    def get_polarisation_parameters(self):\n        \"\"\"\n        Get the polarization parameters for plotting.\n\n        Returns:\n            Dictionary of polarization parameters (DOP, Ellipticity, Azimuth).\n        \"\"\"\n        return {\n            \"DOP\": self.get_degree_of_polarisation(),\n            \"Ellipticity\": self.get_ellipticity(),\n            \"Azimuth\": self.get_azimuth(),\n        }\n\n    def get_all_parameters(self):\n        \"\"\"\n        Get all Stokes and polarization parameters for comprehensive plotting.\n\n        Returns:\n            Dictionary of all parameters (S0, S1, S2, S3, DOP, Ellipticity, Azimuth).\n        \"\"\"\n        stokes = self.get_stokes_parameters()\n        polarisation = self.get_polarisation_parameters()\n        all_params = {**stokes, **polarisation}\n\n        if self.debug:\n            print(\"Summary of all parameters:\")\n            for param, value in all_params.items():\n                print(self._summarize_array(value, param))\n\n        return all_params\n\n    def reset(self):\n        \"\"\"\n        Reset the Mueller object to its initial state.\n        \"\"\"\n        self.mueller_matrix = None\n        self.stokes_parameters = None\n        self.incident_stokes = np.array([1, 0, 0, 0], dtype=np.float64)\n        self.optical_components = []\n        self.anisotropic_sample_added = False\n        self._debug_print(\"Mueller object reset to initial state.\")\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.__init__","title":"<code>__init__(structure, debug=False)</code>","text":"<p>Initialize the Mueller class.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <p>The structure object containing scenario information.</p> required <code>debug</code> <code>bool</code> <p>Enable debug output (default: False)</p> <code>False</code> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def __init__(self, structure, debug=False):\n    \"\"\"\n    Initialize the Mueller class.\n\n    Args:\n        structure: The structure object containing scenario information.\n        debug (bool): Enable debug output (default: False)\n    \"\"\"\n    self.structure = structure\n    self.mueller_matrix = None\n    self.stokes_parameters = None\n    self.incident_stokes = np.array(\n        [1, 0, 0, 0], dtype=np.float64\n    )  # Default to unpolarized light\n    self.optical_components = []\n    self.anisotropic_sample_added = False\n    self.debug = debug\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.add_optical_component","title":"<code>add_optical_component(component_type, *args)</code>","text":"<p>Add an optical component to the system.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <p>Type of the optical component (str).</p> required <code>*args</code> <p>Arguments for the optical component (e.g., angle).</p> <code>()</code> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def add_optical_component(self, component_type, *args):\n    \"\"\"\n    Add an optical component to the system.\n\n    Args:\n        component_type: Type of the optical component (str).\n        *args: Arguments for the optical component (e.g., angle).\n    \"\"\"\n    if component_type == \"linear_polarizer\":\n        self.optical_components.append(self.linear_polarizer(*args))\n    elif component_type == \"anisotropic_sample\":\n        if self.anisotropic_sample_added:\n            raise ValueError(\"Anisotropic sample has already been added\")\n        self.calculate_mueller_matrix()\n        self.optical_components.append(self.mueller_matrix)\n        self.anisotropic_sample_added = True\n    elif component_type == \"quarter_wave_plate\":\n        self.optical_components.append(self.quarter_wave_plate(*args))\n    elif component_type == \"half_wave_plate\":\n        self.optical_components.append(self.half_wave_plate(*args))\n    else:\n        raise ValueError(f\"Unsupported optical component type: {component_type}\")\n    self._debug_print(f\"Added optical component: {component_type}\")\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.calculate_mueller_matrix","title":"<code>calculate_mueller_matrix()</code>","text":"<p>Calculate the Mueller matrix for the anisotropic sample using the reflection coefficients.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def calculate_mueller_matrix(self):\n    \"\"\"\n    Calculate the Mueller matrix for the anisotropic sample using the reflection coefficients.\n    \"\"\"\n    r_pp = self.structure.r_pp\n    r_ps = self.structure.r_ps\n    r_sp = self.structure.r_sp\n    r_ss = self.structure.r_ss\n\n    f_matrix = np.array(\n        [\n            [\n                r_pp * np.conj(r_pp),\n                r_pp * np.conj(r_ps),\n                r_ps * np.conj(r_pp),\n                r_ps * np.conj(r_ps),\n            ],\n            [\n                r_pp * np.conj(r_sp),\n                r_pp * np.conj(r_ss),\n                r_ps * np.conj(r_sp),\n                r_ps * np.conj(r_ss),\n            ],\n            [\n                r_sp * np.conj(r_pp),\n                r_sp * np.conj(r_ps),\n                r_ss * np.conj(r_pp),\n                r_ss * np.conj(r_ps),\n            ],\n            [\n                r_sp * np.conj(r_sp),\n                r_sp * np.conj(r_ss),\n                r_ss * np.conj(r_sp),\n                r_ss * np.conj(r_ss),\n            ],\n        ],\n        dtype=np.complex128,\n    )\n\n    # Handle different scenario types\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, f_matrix is just [4, 4], no need to transpose\n        pass\n    else:\n        # For other scenarios, transpose as before\n        f_matrix = np.transpose(f_matrix, axes=[2, 3, 0, 1])\n\n    a_matrix = np.array(\n        [[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, 1j, -1j, 0]],\n        dtype=np.complex128,\n    )\n\n    # Add batch dimensions if needed\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, just compute matrix multiplication directly\n        self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n    else:\n        # For other scenarios, add batch dimensions\n        a_matrix = a_matrix[np.newaxis, np.newaxis, ...]\n        self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n\n    self._debug_print(\"Calculated Mueller matrix for anisotropic sample:\")\n    self._debug_print(self._summarize_array(self.mueller_matrix, \"Mueller matrix\"))\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.calculate_stokes_parameters","title":"<code>calculate_stokes_parameters()</code>","text":"<p>Calculate the Stokes parameters of the system using the set incident polarization and optical components.</p> <p>Returns:</p> Type Description <p>Stokes parameters of the system (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def calculate_stokes_parameters(self):\n    \"\"\"\n    Calculate the Stokes parameters of the system\n    using the set incident polarization and optical components.\n\n    Returns:\n        Stokes parameters of the system (np.ndarray).\n    \"\"\"\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, start with just the incident vector [4,]\n        stokes_vector = self.incident_stokes.reshape([4, 1])\n    else:\n        # For other scenarios, add batch dimensions\n        stokes_vector = self.incident_stokes.reshape([1, 1, 4, 1])\n\n    self._debug_print(f\"Initial Stokes vector: {stokes_vector.flatten()}\")\n\n    for i, component in enumerate(self.optical_components):\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, component should be [4, 4]\n            stokes_vector = component @ stokes_vector\n        else:\n            # For other scenarios, component has batch dimensions\n            stokes_vector = component @ stokes_vector\n\n        self._debug_print(f\"After component {i}:\")\n        self._debug_print(self._summarize_array(stokes_vector, \"Stokes vector\"))\n\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, remove the last dimension [4, 1] -&gt; [4]\n        self.stokes_parameters = stokes_vector[:, 0]\n    else:\n        # For other scenarios, remove the last dimension [..., 4, 1] -&gt; [..., 4]\n        self.stokes_parameters = stokes_vector[..., 0]\n\n    self._debug_print(\"Final Stokes parameters:\")\n    self._debug_print(self._summarize_array(self.stokes_parameters, \"Stokes parameters\"))\n    return self.stokes_parameters\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_all_parameters","title":"<code>get_all_parameters()</code>","text":"<p>Get all Stokes and polarization parameters for comprehensive plotting.</p> <p>Returns:</p> Type Description <p>Dictionary of all parameters (S0, S1, S2, S3, DOP, Ellipticity, Azimuth).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_all_parameters(self):\n    \"\"\"\n    Get all Stokes and polarization parameters for comprehensive plotting.\n\n    Returns:\n        Dictionary of all parameters (S0, S1, S2, S3, DOP, Ellipticity, Azimuth).\n    \"\"\"\n    stokes = self.get_stokes_parameters()\n    polarisation = self.get_polarisation_parameters()\n    all_params = {**stokes, **polarisation}\n\n    if self.debug:\n        print(\"Summary of all parameters:\")\n        for param, value in all_params.items():\n            print(self._summarize_array(value, param))\n\n    return all_params\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_azimuth","title":"<code>get_azimuth()</code>","text":"<p>Calculate the azimuth of the polarization.</p> <p>Returns:</p> Type Description <p>Azimuth of the polarization (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_azimuth(self):\n    \"\"\"\n    Calculate the azimuth of the polarization.\n\n    Returns:\n        Azimuth of the polarization (np.ndarray).\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    s1 = self.stokes_parameters[..., 1]\n    s2 = self.stokes_parameters[..., 2]\n\n    return 0.5 * np.arctan2(s2, s1)\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_ellipticity","title":"<code>get_ellipticity()</code>","text":"<p>Calculate the ellipticity of the polarization.</p> <p>Returns:</p> Type Description <p>Ellipticity of the polarization (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_ellipticity(self):\n    \"\"\"\n    Calculate the ellipticity of the polarization.\n\n    Returns:\n        Ellipticity of the polarization (np.ndarray).\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    s3 = self.stokes_parameters[..., 3]\n    s1 = self.stokes_parameters[..., 1]\n    s2 = self.stokes_parameters[..., 2]\n\n    return 0.5 * np.arctan2(s3, np.sqrt(s1**2 + s2**2))\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_polarisation_parameters","title":"<code>get_polarisation_parameters()</code>","text":"<p>Get the polarization parameters for plotting.</p> <p>Returns:</p> Type Description <p>Dictionary of polarization parameters (DOP, Ellipticity, Azimuth).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_polarisation_parameters(self):\n    \"\"\"\n    Get the polarization parameters for plotting.\n\n    Returns:\n        Dictionary of polarization parameters (DOP, Ellipticity, Azimuth).\n    \"\"\"\n    return {\n        \"DOP\": self.get_degree_of_polarisation(),\n        \"Ellipticity\": self.get_ellipticity(),\n        \"Azimuth\": self.get_azimuth(),\n    }\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_reflectivity","title":"<code>get_reflectivity()</code>","text":"<p>Calculate the reflectivity of the system (S0 Stokes parameter).</p> <p>Returns:</p> Type Description <p>Reflectivity of the system (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_reflectivity(self):\n    \"\"\"\n    Calculate the reflectivity of the system (S0 Stokes parameter).\n\n    Returns:\n        Reflectivity of the system (np.ndarray).\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    return self.stokes_parameters[..., 0]\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_stokes_parameters","title":"<code>get_stokes_parameters()</code>","text":"<p>Get the Stokes parameters for plotting.</p> <p>Returns:</p> Type Description <p>Dictionary of Stokes parameters (S0, S1, S2, S3).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_stokes_parameters(self):\n    \"\"\"\n    Get the Stokes parameters for plotting.\n\n    Returns:\n        Dictionary of Stokes parameters (S0, S1, S2, S3).\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    return {\n        \"S0\": self.stokes_parameters[..., 0],\n        \"S1\": self.stokes_parameters[..., 1],\n        \"S2\": self.stokes_parameters[..., 2],\n        \"S3\": self.stokes_parameters[..., 3],\n    }\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.half_wave_plate","title":"<code>half_wave_plate(angle)</code>","text":"<p>Create a Mueller matrix for a half-wave plate at a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <p>Fast axis angle in degrees (float).</p> required <p>Returns:</p> Type Description <p>Mueller matrix for the half-wave plate (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def half_wave_plate(self, angle):\n    \"\"\"\n    Create a Mueller matrix for a half-wave plate at a given angle.\n\n    Args:\n        angle: Fast axis angle in degrees (float).\n\n    Returns:\n        Mueller matrix for the half-wave plate (np.ndarray).\n    \"\"\"\n    angle_rad = np.float64(np.radians(angle))\n    cos_angle = np.cos(2 * angle_rad)\n    sin_angle = np.sin(2 * angle_rad)\n\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, cos_angle**2 - sin_angle**2, 2 * cos_angle * sin_angle, 0],\n            [0, 2 * cos_angle * sin_angle, sin_angle**2 - cos_angle**2, 0],\n            [0, 0, 0, -1],\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.linear_polarizer","title":"<code>linear_polarizer(angle)</code>","text":"<p>Create a Mueller matrix for a linear polarizer at a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <p>Polarizer angle in degrees (float).</p> required <p>Returns:</p> Type Description <p>Mueller matrix for the linear polarizer (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def linear_polarizer(self, angle):\n    \"\"\"\n    Create a Mueller matrix for a linear polarizer at a given angle.\n\n    Args:\n        angle: Polarizer angle in degrees (float).\n\n    Returns:\n        Mueller matrix for the linear polarizer (np.ndarray).\n    \"\"\"\n    angle_rad = np.float64(np.radians(angle) * 2.0)\n\n    cos_angle = np.cos(angle_rad)\n    sin_angle = np.sin(angle_rad)\n\n    return 0.5 * np.array(\n        [\n            [1, cos_angle, sin_angle, 0],\n            [cos_angle, cos_angle**2.0, cos_angle * sin_angle, 0],\n            [sin_angle, cos_angle * sin_angle, sin_angle**2.0, 0],\n            [0, 0, 0, 0],\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.quarter_wave_plate","title":"<code>quarter_wave_plate(angle)</code>","text":"<p>Create a Mueller matrix for a quarter-wave plate at a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <p>Fast axis angle in degrees (float).</p> required <p>Returns:</p> Type Description <p>Mueller matrix for the quarter-wave plate (np.ndarray).</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def quarter_wave_plate(self, angle):\n    \"\"\"\n    Create a Mueller matrix for a quarter-wave plate at a given angle.\n\n    Args:\n        angle: Fast axis angle in degrees (float).\n\n    Returns:\n        Mueller matrix for the quarter-wave plate (np.ndarray).\n    \"\"\"\n    angle_rad = np.float64(np.radians(angle))\n    cos_angle = np.cos(2 * angle_rad)\n    sin_angle = np.sin(2 * angle_rad)\n\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, cos_angle**2, cos_angle * sin_angle, -sin_angle],\n            [0, cos_angle * sin_angle, sin_angle**2, cos_angle],\n            [0, sin_angle, -cos_angle, 0],\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.reset","title":"<code>reset()</code>","text":"<p>Reset the Mueller object to its initial state.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the Mueller object to its initial state.\n    \"\"\"\n    self.mueller_matrix = None\n    self.stokes_parameters = None\n    self.incident_stokes = np.array([1, 0, 0, 0], dtype=np.float64)\n    self.optical_components = []\n    self.anisotropic_sample_added = False\n    self._debug_print(\"Mueller object reset to initial state.\")\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.set_incident_polarization","title":"<code>set_incident_polarization(polarization_type, **kwargs)</code>","text":"<p>Set the incident polarization state.</p> <p>Parameters:</p> Name Type Description Default <code>polarization_type</code> <code>str</code> <p>Type of polarization ('linear', 'circular', or 'elliptical')</p> required <code>**kwargs</code> <p>Additional arguments depending on the polarization type For 'linear': angle (in degrees) For 'circular': handedness ('right' or 'left') For 'elliptical': alpha (in degrees), ellipticity (between -45 and 45 degrees)</p> <code>{}</code> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def set_incident_polarization(self, polarization_type, **kwargs):\n    \"\"\"\n    Set the incident polarization state.\n\n    Args:\n        polarization_type (str): Type of polarization ('linear', 'circular', or 'elliptical')\n        **kwargs: Additional arguments depending on the polarization type\n            For 'linear': angle (in degrees)\n            For 'circular': handedness ('right' or 'left')\n            For 'elliptical': alpha (in degrees), ellipticity (between -45 and 45 degrees)\n    \"\"\"\n    if polarization_type == \"linear\":\n        angle = kwargs.get(\"angle\", 0)\n        self.incident_stokes = self._linear_polarization(angle)\n    elif polarization_type == \"circular\":\n        handedness = kwargs.get(\"handedness\", \"right\")\n        self.incident_stokes = self._circular_polarization(handedness)\n    elif polarization_type == \"elliptical\":\n        alpha = kwargs.get(\"alpha\", 0)\n        ellipticity = kwargs.get(\"ellipticity\", 0)\n        self.incident_stokes = self._elliptical_polarization(alpha, ellipticity)\n    else:\n        raise ValueError(f\"Unsupported polarization type: {polarization_type}\")\n\n    self._debug_print(f\"Set incident polarization: {polarization_type}\")\n    self._debug_print(self._summarize_array(self.incident_stokes, \"Incident Stokes vector\"))\n</code></pre>"},{"location":"api/plots/","title":"Plots API","text":""},{"location":"api/plots/#hyperbolic_optics.plots","title":"<code>hyperbolic_optics.plots</code>","text":""},{"location":"api/plots/#hyperbolic_optics.plots.PlotStyle","title":"<code>PlotStyle</code>","text":"<p>Manages consistent plotting styles across all figures.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>class PlotStyle:\n    \"\"\"Manages consistent plotting styles across all figures.\"\"\"\n\n    @staticmethod\n    def initialize():\n        \"\"\"Initialize global matplotlib parameters.\"\"\"\n        plt.rcParams.update(\n            {\n                \"font.family\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n                \"font.size\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                \"axes.labelsize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                \"axes.titlesize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                \"xtick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n                \"ytick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n                \"mathtext.fontset\": \"custom\",\n                \"mathtext.rm\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n                \"mathtext.it\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:italic\",\n                \"mathtext.bf\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:bold\",\n            }\n        )\n\n    @staticmethod\n    def style_axis(ax: plt.Axes, show_labels: bool = True):\n        \"\"\"Apply consistent styling to axis.\"\"\"\n        ax.tick_params(\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n        )\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.PlotStyle.initialize","title":"<code>initialize()</code>  <code>staticmethod</code>","text":"<p>Initialize global matplotlib parameters.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>@staticmethod\ndef initialize():\n    \"\"\"Initialize global matplotlib parameters.\"\"\"\n    plt.rcParams.update(\n        {\n            \"font.family\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n            \"font.size\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            \"axes.labelsize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            \"axes.titlesize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            \"xtick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            \"ytick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            \"mathtext.fontset\": \"custom\",\n            \"mathtext.rm\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n            \"mathtext.it\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:italic\",\n            \"mathtext.bf\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:bold\",\n        }\n    )\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.PlotStyle.style_axis","title":"<code>style_axis(ax, show_labels=True)</code>  <code>staticmethod</code>","text":"<p>Apply consistent styling to axis.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>@staticmethod\ndef style_axis(ax: plt.Axes, show_labels: bool = True):\n    \"\"\"Apply consistent styling to axis.\"\"\"\n    ax.tick_params(\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n    )\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_kx_frequency","title":"<code>plot_kx_frequency(structure, param, title=None, rotation_y=None, save_name=None, label='a')</code>","text":"<p>Plot frequency vs kx with paper-quality styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>object</code> <p>Structure object containing eps_prism and frequency data</p> required <code>param</code> <code>ndarray</code> <p>The parameter to plot (e.g., reflectivity)</p> required <code>title</code> <code>Optional[str]</code> <p>Optional title for the plot</p> <code>None</code> <code>rotation_y</code> <code>Optional[float]</code> <p>Optional rotation angle to display</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>Optional filename for saving the plot</p> <code>None</code> <code>label</code> <code>str</code> <p>Optional subplot label (default: \"a\")</p> <code>'a'</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_kx_frequency(\n    structure: object,\n    param: np.ndarray,\n    title: Optional[str] = None,\n    rotation_y: Optional[float] = None,\n    save_name: Optional[str] = None,\n    label: str = \"a\",\n):\n    \"\"\"Plot frequency vs kx with paper-quality styling.\n\n    Args:\n        structure: Structure object containing eps_prism and frequency data\n        param: The parameter to plot (e.g., reflectivity)\n        title: Optional title for the plot\n        rotation_y: Optional rotation angle to display\n        save_name: Optional filename for saving the plot\n        label: Optional subplot label (default: \"a\")\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(nrows=1, ncols=1, wspace=0.2, left=0.1, right=0.9, top=0.9, bottom=0.15)\n\n    # Create axis with gridspec\n    ax = fig.add_subplot(gs[0])\n\n    # Calculate kx values from structure properties\n    n_prism = np.sqrt(float(structure.eps_prism))\n    incident_angles = structure.incident_angle\n    kx = n_prism * np.sin(incident_angles)\n    frequency = structure.frequency\n\n    # Create the color plot\n    im = ax.pcolormesh(kx, frequency, param, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Set x-axis limits and generate ticks\n    max_kx = n_prism\n    ax.set_xlim(-max_kx, max_kx)\n\n    # Determine step size based on the range\n    if max_kx &lt; 3:\n        step = 1  # Half-integer steps for small ranges\n    elif max_kx &lt; 8:\n        step = 2  # Integer steps for medium ranges\n    elif max_kx &lt; 15:\n        step = 3  # Steps of 3 for larger ranges\n    else:\n        step = 5  # Steps of 5 for very large ranges\n\n    # Calculate maximum tick value\n    max_tick = (int(max_kx) // step) * step\n\n    # Generate symmetrical ticks around zero\n    positive_ticks = np.arange(0, max_tick + step / 2, step)\n    negative_ticks = -np.arange(step, max_tick + step / 2, step)\n    ticks = np.concatenate([negative_ticks, positive_ticks])\n    ticks = ticks[np.abs(ticks) &lt;= max_kx]\n    ax.set_xticks(ticks)\n\n    # Set y-axis limits\n    ax.set_ylim(frequency[0], frequency[-1])\n\n    # Apply paper-quality tick styling\n    ax.tick_params(\n        labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n        top=False,\n        right=False,\n    )\n\n    # Set axis labels with LaTeX formatting\n    ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n    ax.set_ylabel(\n        r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n        fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n        labelpad=10,\n    )\n\n    # Add subplot label in top left corner\n    ax.text(\n        0.06,\n        0.94,\n        f\"({label})\",\n        transform=ax.transAxes,\n        fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n        va=\"top\",\n        ha=\"left\",\n    )\n\n    # Add rotation angle if provided\n    if rotation_y is not None:\n        ax.text(\n            0.98,\n            0.96,\n            rf\"$\\varphi = {rotation_y}^{{\\circ}}$\",\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            ha=\"right\",\n            va=\"top\",\n        )\n\n    # Add title if provided\n    if title:\n        ax.text(\n            0.5,\n            1.02,\n            title,\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            ha=\"center\",\n        )\n\n    # Set aspect ratio to make plot square\n    ax.set_box_aspect(1)\n\n    # Add custom positioned colorbar\n    pos = ax.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_kx_frequency_pair","title":"<code>plot_kx_frequency_pair(structure, param1, param2, rotation_y1=None, rotation_y2=None, title1=None, title2=None, save_name=None)</code>","text":"<p>Plot two kx-frequency plots side by side with paper-quality styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <p>Structure object containing data</p> required <code>param1</code> <code>ndarray</code> <p>Parameter for first plot</p> required <code>param2</code> <code>ndarray</code> <p>Parameter for second plot</p> required <code>rotation_y1</code> <code>Optional[float]</code> <p>Optional rotation angle for first plot</p> <code>None</code> <code>rotation_y2</code> <code>Optional[float]</code> <p>Optional rotation angle for second plot</p> <code>None</code> <code>title1</code> <code>Optional[str]</code> <p>Optional title for first plot</p> <code>None</code> <code>title2</code> <code>Optional[str]</code> <p>Optional title for second plot</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>Optional filename for saving the plot</p> <code>None</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_kx_frequency_pair(\n    structure,\n    param1: np.ndarray,\n    param2: np.ndarray,\n    rotation_y1: Optional[float] = None,\n    rotation_y2: Optional[float] = None,\n    title1: Optional[str] = None,\n    title2: Optional[str] = None,\n    save_name: Optional[str] = None,\n):\n    \"\"\"Plot two kx-frequency plots side by side with paper-quality styling.\n\n    Args:\n        structure: Structure object containing data\n        param1: Parameter for first plot\n        param2: Parameter for second plot\n        rotation_y1: Optional rotation angle for first plot\n        rotation_y2: Optional rotation angle for second plot\n        title1: Optional title for first plot\n        title2: Optional title for second plot\n        save_name: Optional filename for saving the plot\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=CONFIG[\"PLOT\"][\"FIGURE_SIZE\"])\n    gs = fig.add_gridspec(\n        nrows=1,\n        ncols=2,\n        width_ratios=[1, 1],\n        wspace=0.2,\n        left=0.1,\n        right=0.9,\n        top=0.9,\n        bottom=0.15,\n    )\n\n    # Calculate common data\n    n_prism = np.sqrt(float(structure.eps_prism))\n    incident_angles = structure.incident_angle\n    kx = n_prism * np.sin(incident_angles)\n    frequency = structure.frequency\n    max_kx = n_prism\n\n    # Create first subplot\n    ax1 = fig.add_subplot(gs[0])\n    ax1.pcolormesh(kx, frequency, param1, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Create second subplot\n    ax2 = fig.add_subplot(gs[1], sharey=ax1)\n    im2 = ax2.pcolormesh(kx, frequency, param2, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Style both subplots\n    [rotation_y1, rotation_y2]\n    for idx, (ax, title, rot_y) in enumerate(\n        [(ax1, title1, rotation_y1), (ax2, title2, rotation_y2)]\n    ):\n        # Set limits and generate ticks\n        ax.set_xlim(-max_kx, max_kx)\n\n        # Determine step size\n        if max_kx &lt; 3:\n            step = 0.5\n        elif max_kx &lt; 8:\n            step = 1\n        elif max_kx &lt; 15:\n            step = 3\n        else:\n            step = 5\n\n        max_tick = (int(max_kx) // step) * step\n        positive_ticks = np.arange(0, max_tick + step / 2, step)\n        negative_ticks = -np.arange(step, max_tick + step / 2, step)\n        ticks = np.concatenate([negative_ticks, positive_ticks])\n        ticks = ticks[np.abs(ticks) &lt;= max_kx]\n        ax.set_xticks(ticks)\n\n        ax.set_ylim(frequency[0], frequency[-1])\n\n        # Apply tick styling\n        ax.tick_params(\n            labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n            top=False,\n            right=False,\n        )\n\n        # Set labels\n        ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        if idx == 0:  # Only add ylabel to first subplot\n            ax.set_ylabel(\n                r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                labelpad=10,\n            )\n        else:\n            ax.tick_params(labelleft=False)\n\n        # Add subplot label\n        ax.text(\n            0.06,\n            0.94,\n            f'({[\"a\", \"b\"][idx]})',\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            va=\"top\",\n            ha=\"left\",\n        )\n\n        # Add rotation angle if provided\n        if rot_y is not None:\n            ax.text(\n                0.98,\n                0.96,\n                rf\"$\\varphi = {rot_y}^{{\\circ}}$\",\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n                ha=\"right\",\n                va=\"top\",\n            )\n\n        if title:\n            ax.text(\n                0.5,\n                1.02,\n                title,\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                ha=\"center\",\n            )\n\n        ax.set_box_aspect(1)\n\n    # Add colorbar to the right of the second subplot\n    pos = ax2.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im2, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_azimuthal","title":"<code>plot_mueller_azimuthal(structure, param, title=None, save_name=None, label='a')</code>","text":"<p>Plot frequency vs azimuthal angle with paper-quality styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <p>Structure object containing azimuthal angle and frequency data</p> required <code>param</code> <code>ndarray</code> <p>The parameter to plot</p> required <code>title</code> <code>Optional[str]</code> <p>Optional title for the plot</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>Optional filename for saving the plot</p> <code>None</code> <code>label</code> <code>str</code> <p>Optional subplot label (default: \"a\")</p> <code>'a'</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_azimuthal(\n    structure,\n    param: np.ndarray,\n    title: Optional[str] = None,\n    save_name: Optional[str] = None,\n    label: str = \"a\",\n):\n    \"\"\"Plot frequency vs azimuthal angle with paper-quality styling.\n\n    Args:\n        structure: Structure object containing azimuthal angle and frequency data\n        param: The parameter to plot\n        title: Optional title for the plot\n        save_name: Optional filename for saving the plot\n        label: Optional subplot label (default: \"a\")\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(nrows=1, ncols=1, wspace=0.2, left=0.1, right=0.9, top=0.9, bottom=0.15)\n\n    # Create axis with gridspec\n    ax = fig.add_subplot(gs[0])\n\n    # Calculate axis values\n    x_axis = np.round(np.degrees(structure.azimuthal_angle), 1)\n    frequency = structure.frequency\n\n    # Create the color plot using pcolormesh\n    im = ax.pcolormesh(x_axis, frequency, param, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Set axis limits and ticks\n    ax.set_xlim(0, 360)\n    ax.set_xticks([0, 90, 180, 270, 360])\n    ax.set_ylim(frequency[0], frequency[-1])\n\n    # Apply paper-quality tick styling\n    ax.tick_params(\n        labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n        top=False,\n        right=False,\n    )\n\n    # Set axis labels with LaTeX formatting\n    ax.set_xlabel(r\"$\\beta$ (degree)\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n    ax.set_ylabel(\n        r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n        fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n        labelpad=10,\n    )\n\n    # Add subplot label in top left corner\n    ax.text(\n        0.06,\n        0.94,\n        f\"({label})\",\n        transform=ax.transAxes,\n        fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n        va=\"top\",\n        ha=\"left\",\n    )\n\n    # Add title if provided\n    if title:\n        ax.text(\n            0.5,\n            1.02,\n            title,\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            ha=\"center\",\n        )\n\n    # Set aspect ratio to make plot square\n    ax.set_box_aspect(1)\n\n    # Add custom positioned colorbar\n    pos = ax.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save the plot if a filename is provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_azimuthal_pair","title":"<code>plot_mueller_azimuthal_pair(structure, param1, param2, title1=None, title2=None, save_name=None)</code>","text":"<p>Plot two azimuthal plots side by side with paper-quality styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <p>Structure object containing data</p> required <code>param1</code> <code>ndarray</code> <p>Parameter for first plot</p> required <code>param2</code> <code>ndarray</code> <p>Parameter for second plot</p> required <code>title1</code> <code>Optional[str]</code> <p>Optional title for first plot</p> <code>None</code> <code>title2</code> <code>Optional[str]</code> <p>Optional title for second plot</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>Optional filename for saving the plot</p> <code>None</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_azimuthal_pair(\n    structure,\n    param1: np.ndarray,\n    param2: np.ndarray,\n    title1: Optional[str] = None,\n    title2: Optional[str] = None,\n    save_name: Optional[str] = None,\n):\n    \"\"\"Plot two azimuthal plots side by side with paper-quality styling.\n\n    Args:\n        structure: Structure object containing data\n        param1: Parameter for first plot\n        param2: Parameter for second plot\n        title1: Optional title for first plot\n        title2: Optional title for second plot\n        save_name: Optional filename for saving the plot\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=CONFIG[\"PLOT\"][\"FIGURE_SIZE\"])\n    gs = fig.add_gridspec(\n        nrows=1,\n        ncols=2,\n        width_ratios=[1, 1],\n        wspace=0.2,\n        left=0.1,\n        right=0.9,\n        top=0.9,\n        bottom=0.15,\n    )\n\n    # Create first subplot\n    ax1 = fig.add_subplot(gs[0])\n    x_axis = np.round(np.degrees(structure.azimuthal_angle), 1)\n    frequency = structure.frequency\n\n    ax1.pcolormesh(x_axis, frequency, param1, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Create second subplot\n    ax2 = fig.add_subplot(gs[1], sharey=ax1)\n    im2 = ax2.pcolormesh(x_axis, frequency, param2, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Style both subplots\n    for idx, (ax, title) in enumerate([(ax1, title1), (ax2, title2)]):\n        ax.set_xlim(0, 360)\n        ax.set_xticks([0, 90, 180, 270, 360])\n        ax.set_ylim(frequency[0], frequency[-1])\n\n        ax.tick_params(\n            labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n            top=False,\n            right=False,\n        )\n\n        ax.set_xlabel(r\"$\\beta$ (degree)\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        if idx == 0:  # Only add ylabel to first subplot\n            ax.set_ylabel(\n                r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                labelpad=10,\n            )\n        else:\n            ax.tick_params(labelleft=False)\n\n        # Add subplot label\n        ax.text(\n            0.06,\n            0.94,\n            f'({[\"a\", \"b\"][idx]})',\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            va=\"top\",\n            ha=\"left\",\n        )\n\n        if title:\n            ax.text(\n                0.5,\n                1.02,\n                title,\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                ha=\"center\",\n            )\n\n        ax.set_box_aspect(1)\n\n    # Add colorbar to the right of the second subplot\n    pos = ax2.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im2, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save the plot if a filename is provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_dispersion","title":"<code>plot_mueller_dispersion(structure, param, title=None, rotation_y=None, save_name=None, label='a')</code>","text":"<p>Plot k-space dispersion with paper-quality styling in kx-ky coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>object</code> <p>Structure object containing angle and frequency data</p> required <code>param</code> <code>ndarray</code> <p>The parameter to plot</p> required <code>title</code> <code>Optional[str]</code> <p>Optional title for the plot</p> <code>None</code> <code>rotation_y</code> <code>Optional[float]</code> <p>Optional rotation angle to display</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>Optional filename for saving the plot</p> <code>None</code> <code>label</code> <code>str</code> <p>Optional subplot label (default: \"a\")</p> <code>'a'</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_dispersion(\n    structure: object,\n    param: np.ndarray,\n    title: Optional[str] = None,\n    rotation_y: Optional[float] = None,\n    save_name: Optional[str] = None,\n    label: str = \"a\",\n):\n    \"\"\"Plot k-space dispersion with paper-quality styling in kx-ky coordinates.\n\n    Args:\n        structure: Structure object containing angle and frequency data\n        param: The parameter to plot\n        title: Optional title for the plot\n        rotation_y: Optional rotation angle to display\n        save_name: Optional filename for saving the plot\n        label: Optional subplot label (default: \"a\")\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(nrows=1, ncols=1, wspace=0.2, left=0.1, right=0.9, top=0.9, bottom=0.15)\n\n    # Create axis with gridspec\n    ax = fig.add_subplot(gs[0])\n\n    # Calculate k-space coordinates\n    incident_angle = structure.incident_angle\n    z_rotation = structure.azimuthal_angle\n    max_k = np.sqrt(float(structure.eps_prism))  # Maximum k value from prism\n\n    # Create meshgrid for incident angle and z-rotation\n    incident_angle, z_rotation = np.meshgrid(incident_angle, z_rotation)\n\n    # Convert polar coordinates to Cartesian (kx, ky)\n    kx = max_k * np.sin(incident_angle) * np.cos(z_rotation)\n    ky = max_k * np.sin(incident_angle) * np.sin(z_rotation)\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"The input coordinates to pcolormesh\")\n        im = ax.pcolormesh(kx, ky, param.T, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Set plot limits and aspect ratio\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(-max_k * 1.1, max_k * 1.1)\n    ax.set_ylim(-max_k * 1.1, max_k * 1.1)\n\n    # Determine step size based on the range (same logic as plot_kx_frequency)\n    if max_k &lt; 3:\n        step = 1  # Integer steps for small ranges\n    elif max_k &lt; 8:\n        step = 2  # Steps of 2 for medium ranges\n    elif max_k &lt; 15:\n        step = 3  # Steps of 3 for larger ranges\n    else:\n        step = 5  # Steps of 5 for very large ranges\n\n    # Calculate maximum tick value\n    max_tick = (int(max_k) // step) * step\n\n    # Generate symmetrical ticks around zero\n    positive_ticks = np.arange(0, max_tick + step / 2, step)\n    negative_ticks = -np.arange(step, max_tick + step / 2, step)\n    ticks = np.concatenate([negative_ticks, positive_ticks])\n    ticks = ticks[np.abs(ticks) &lt;= max_k]\n\n    ax.set_xticks(ticks)\n    ax.set_yticks(ticks)\n\n    # Apply paper-quality tick styling\n    ax.tick_params(\n        labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n        top=False,\n        right=False,\n    )\n\n    # Set axis labels with LaTeX formatting\n    ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n    ax.set_ylabel(r\"$k_y/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n\n    # Add subplot label in top left corner\n    ax.text(\n        0.06,\n        0.94,\n        f\"({label})\",\n        transform=ax.transAxes,\n        fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n        va=\"top\",\n        ha=\"left\",\n    )\n\n    # Add rotation angle if provided\n    if rotation_y is not None:\n        ax.text(\n            0.98,\n            0.96,\n            rf\"$\\varphi = {rotation_y}^{{\\circ}}$\",\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            ha=\"right\",\n            va=\"top\",\n        )\n\n    # Add title if provided\n    if title:\n        ax.text(\n            0.5,\n            1.02,\n            title,\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            ha=\"center\",\n        )\n\n    # Add unit circle to indicate light cone\n    circle = plt.Circle((0, 0), 1, fill=False, color=\"white\", linestyle=\"-\", linewidth=1.5)\n    ax.add_patch(circle)\n\n    # Set aspect ratio to make plot square\n    ax.set_box_aspect(1)\n\n    # Add custom positioned colorbar\n    pos = ax.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_dispersion_pair","title":"<code>plot_mueller_dispersion_pair(structure, param1, param2, rotation_y1=None, rotation_y2=None, title1=None, title2=None, save_name=None)</code>","text":"<p>Plot two k-space dispersion plots side by side with paper-quality styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <p>Structure object containing data</p> required <code>param1</code> <code>ndarray</code> <p>Parameter for first plot</p> required <code>param2</code> <code>ndarray</code> <p>Parameter for second plot</p> required <code>rotation_y1</code> <code>Optional[float]</code> <p>Optional rotation angle for first plot</p> <code>None</code> <code>rotation_y2</code> <code>Optional[float]</code> <p>Optional rotation angle for second plot</p> <code>None</code> <code>title1</code> <code>Optional[str]</code> <p>Optional title for first plot</p> <code>None</code> <code>title2</code> <code>Optional[str]</code> <p>Optional title for second plot</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>Optional filename for saving the plot</p> <code>None</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_dispersion_pair(\n    structure,\n    param1: np.ndarray,\n    param2: np.ndarray,\n    rotation_y1: Optional[float] = None,\n    rotation_y2: Optional[float] = None,\n    title1: Optional[str] = None,\n    title2: Optional[str] = None,\n    save_name: Optional[str] = None,\n):\n    \"\"\"Plot two k-space dispersion plots side by side with paper-quality styling.\n\n    Args:\n        structure: Structure object containing data\n        param1: Parameter for first plot\n        param2: Parameter for second plot\n        rotation_y1: Optional rotation angle for first plot\n        rotation_y2: Optional rotation angle for second plot\n        title1: Optional title for first plot\n        title2: Optional title for second plot\n        save_name: Optional filename for saving the plot\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(\n        nrows=1,\n        ncols=2,\n        width_ratios=[1, 1],\n        wspace=0.2,\n        left=0.1,\n        right=0.9,\n        top=0.9,\n        bottom=0.15,\n    )\n\n    # Calculate common k-space coordinates\n    incident_angle = structure.incident_angle\n    z_rotation = structure.azimuthal_angle\n    max_k = np.sqrt(float(structure.eps_prism))\n\n    incident_angle, z_rotation = np.meshgrid(incident_angle, z_rotation)\n    kx = max_k * np.sin(incident_angle) * np.cos(z_rotation)\n    ky = max_k * np.sin(incident_angle) * np.sin(z_rotation)\n\n    # Create first subplot\n    ax1 = fig.add_subplot(gs[0])\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"The input coordinates to pcolormesh\")\n        ax1.pcolormesh(kx, ky, param1.T, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Create second subplot\n    ax2 = fig.add_subplot(gs[1], sharey=ax1)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"The input coordinates to pcolormesh\")\n        im2 = ax2.pcolormesh(kx, ky, param2.T, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Style both subplots\n    for idx, (ax, title, rot_y) in enumerate(\n        [(ax1, title1, rotation_y1), (ax2, title2, rotation_y2)]\n    ):\n        # Set plot limits and aspect ratio\n        ax.set_aspect(\"equal\")\n        ax.set_xlim(-max_k * 1.05, max_k * 1.05)\n        ax.set_ylim(-max_k * 1.05, max_k * 1.05)\n\n        # Set ticks based on max_k\n        if max_k &lt; 3:\n            tick_spacing = 1\n        elif max_k &lt; 6:\n            tick_spacing = 2\n        else:\n            tick_spacing = 3\n\n        # Generate negative ticks (going backwards from 0)\n        neg_ticks = np.arange(0, -int(max_k) - 1, -tick_spacing)\n        # Generate positive ticks (going forwards from 0)\n        pos_ticks = np.arange(0, int(max_k) + 1, tick_spacing)\n        # Combine them, excluding the duplicate 0\n        ticks = np.concatenate([neg_ticks[1:], pos_ticks])\n\n        ax.set_xticks(ticks)\n        ax.set_yticks(ticks)\n\n        # Apply tick styling\n        ax.tick_params(\n            labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n            top=False,\n            right=False,\n        )\n\n        # Set labels\n        ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        if idx == 0:  # Only add ylabel to first subplot\n            ax.set_ylabel(r\"$k_y/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        else:\n            ax.tick_params(labelleft=False)\n\n        # Add subplot label\n        ax.text(\n            0.06,\n            0.94,\n            f'({[\"a\", \"b\"][idx]})',\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            va=\"top\",\n            ha=\"left\",\n        )\n\n        # Add rotation angle if provided\n        if rot_y is not None:\n            ax.text(\n                0.98,\n                0.96,\n                rf\"$\\varphi = {rot_y}^{{\\circ}}$\",\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n                ha=\"right\",\n                va=\"top\",\n            )\n\n        if title:\n            ax.text(\n                0.5,\n                1.02,\n                title,\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                ha=\"center\",\n            )\n\n        # Add unit circle\n        circle = plt.Circle((0, 0), 1, fill=False, color=\"white\", linestyle=\"-\", linewidth=1.5)\n        ax.add_patch(circle)\n\n        ax.set_box_aspect(1)\n\n    # Add colorbar to the right of the second subplot\n    pos = ax2.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im2, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_permittivity","title":"<code>plot_permittivity(material, eps_ext, eps_ord, save_name=None)</code>","text":"<p>Plot permittivity spectra with improved styling.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_permittivity(material, eps_ext, eps_ord, save_name: Optional[str] = None):\n    \"\"\"Plot permittivity spectra with improved styling.\"\"\"\n    PlotStyle.initialize()\n\n    fig, axs = plt.subplots(2, figsize=(9, 7), sharex=True, gridspec_kw={\"hspace\": 0.1})\n\n    # Plot real part\n    axs[0].plot(\n        material.frequency,\n        eps_ext.real,\n        label=r\"$\\mathrm{Re}(\\varepsilon_\\mathrm{ext})$\",\n    )\n    axs[0].plot(\n        material.frequency,\n        eps_ord.real,\n        label=r\"$\\mathrm{Re}(\\varepsilon_\\mathrm{ord})$\",\n    )\n    axs[0].axhline(y=0, color=\"black\", linewidth=1)\n    axs[0].set(ylabel=r\"$\\mathrm{Re}(\\epsilon)$\")\n    axs[0].legend()\n    PlotStyle.style_axis(axs[0])\n\n    # Plot imaginary part\n    axs[1].plot(\n        material.frequency,\n        eps_ext.imag,\n        label=r\"$\\mathrm{Im}(\\varepsilon_\\mathrm{ext})$\",\n    )\n    axs[1].plot(\n        material.frequency,\n        eps_ord.imag,\n        label=r\"$\\mathrm{Im}(\\varepsilon_\\mathrm{ord})$\",\n    )\n    axs[1].set(xlabel=r\"Wavenumber (cm$^{-1}$)\", ylabel=r\"$\\mathrm{Im}(\\epsilon)$\")\n    axs[1].set_xlim(material.frequency[0], material.frequency[-1])\n    axs[1].set_ylim(\n        0,\n    )\n    axs[1].legend()\n    PlotStyle.style_axis(axs[1])\n\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n        )\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_stokes_parameters","title":"<code>plot_stokes_parameters(structure, params, plot_type='incidence', save_name=None)</code>","text":"<p>Plot all Stokes parameters in a 2x3 grid.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_stokes_parameters(\n    structure: object,\n    params: Dict[str, np.ndarray],\n    plot_type: str = \"incidence\",\n    save_name: Optional[str] = None,\n):\n    \"\"\"Plot all Stokes parameters in a 2x3 grid.\"\"\"\n    PlotStyle.initialize()\n\n    fig, ax = plt.subplots(2, 3, figsize=(18, 12))\n\n    ax_to_plot = [\n        (params[\"S0\"], \"S0\", 0, 0),\n        (params[\"S1\"], \"S1\", 0, 1),\n        (params[\"S2\"], \"S2\", 0, 2),\n        (params[\"S3\"], \"S3\", 1, 0),\n        (params[\"DOP\"], \"DOP\", 1, 1),\n        (params[\"Ellipticity\"], \"Ellipticity\", 1, 2),\n    ]\n\n    if plot_type == \"incidence\":\n        x_axis = np.round(np.degrees(structure.incident_angle), 1)\n        xlabel = r\"Incident Angle / $^\\circ$\"\n    else:  # azimuthal\n        x_axis = np.round(np.degrees(structure.azimuthal_angle), 1)\n        xlabel = r\"Azimuthal Rotation / $^\\circ$\"\n\n    frequency = structure.frequency\n\n    for data, title, row, col in ax_to_plot:\n        im = ax[row, col].pcolormesh(x_axis, frequency, data, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"])\n        cbar = plt.colorbar(im, ax=ax[row, col])\n        cbar.set_label(title, size=CONFIG[\"PLOT\"][\"LABEL_SIZE\"])\n        ax[row, col].set_title(title, size=CONFIG[\"PLOT\"][\"LABEL_SIZE\"])\n        ax[row, col].set_xlabel(xlabel)\n        ax[row, col].set_ylabel(r\"$\\omega/2\\pi c$ (cm$^{-1}$)\")\n        PlotStyle.style_axis(ax[row, col])\n\n    plt.tight_layout()\n\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n        )\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/scenario/","title":"Scenario API","text":""},{"location":"api/scenario/#hyperbolic_optics.scenario","title":"<code>hyperbolic_optics.scenario</code>","text":"<p>Scenario module - NumPy implementation Used for construction of four scenarios:</p> <ol> <li>Frequency vs. Incident Angle</li> <li>Frequency vs. Azimuthal Rotation</li> <li>Dispersion at a given frequency</li> <li>Simple - Single incident angle, orientation, and frequency</li> </ol>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup","title":"<code>ScenarioSetup</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for a scenario setup</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>class ScenarioSetup(ABC):\n    \"\"\"\n    Abstract class for a scenario setup\n    \"\"\"\n\n    def __init__(self, data):\n        self.type = data.get(\"type\")\n        self.incident_angle = data.get(\"incidentAngle\", None)\n        self.azimuthal_angle = data.get(\"azimuthal_angle\", None)\n        self.frequency = data.get(\"frequency\", None)\n        self.create_scenario()\n\n    def create_scenario(self):\n        \"\"\"\n        Creates the scenario based on the type\n        \"\"\"\n        if self.type == \"Incident\":\n            self.create_incident_scenario()\n        elif self.type == \"Azimuthal\":\n            self.create_azimuthal_scenario()\n        elif self.type == \"Dispersion\":\n            self.create_dispersion_scenario()\n        elif self.type == \"Simple\":\n            self.create_simple_scenario()\n        else:\n            raise NotImplementedError(f\"Scenario type {self.type} not implemented\")\n\n    def create_incident_scenario(self):\n        \"\"\"\n        Creates the incident scenario\n        \"\"\"\n        self.incident_angle = np.linspace(\n            -m.pi / 2.0 + 1.0e-9, m.pi / 2.0 - 1.0e-9, 360, dtype=np.float64\n        )\n\n    def create_azimuthal_scenario(self):\n        \"\"\"\n        Creates the azimuthal scenario\n        \"\"\"\n        self.incident_angle = np.float64(m.radians(self.incident_angle))\n        self.azimuthal_angle = np.linspace(\n            0.0 + 1.0e-15, 2.0 * m.pi - 1.0e-15, 360, dtype=np.float64\n        )\n\n    def create_dispersion_scenario(self):\n        \"\"\"\n        Creates the dispersion scenario\n        \"\"\"\n        self.incident_angle = np.linspace(0.0 + 1.0e-8, m.pi / 2.0 - 1.0e-8, 180, dtype=np.float64)\n\n        self.azimuthal_angle = np.linspace(1.0e-5, 2.0 * m.pi - 1.0e-5, 480, dtype=np.float64)\n\n        self.frequency = float(self.frequency)\n\n    def create_simple_scenario(self):\n        \"\"\"\n        Creates the simple scenario - single values for all parameters\n        \"\"\"\n        # Convert to scalar values for consistency\n        self.incident_angle = np.float64(m.radians(self.incident_angle) + 1.0e-15)\n        self.azimuthal_angle = np.float64(m.radians(self.azimuthal_angle) + 1.0e-15)\n        self.frequency = float(self.frequency)\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_azimuthal_scenario","title":"<code>create_azimuthal_scenario()</code>","text":"<p>Creates the azimuthal scenario</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_azimuthal_scenario(self):\n    \"\"\"\n    Creates the azimuthal scenario\n    \"\"\"\n    self.incident_angle = np.float64(m.radians(self.incident_angle))\n    self.azimuthal_angle = np.linspace(\n        0.0 + 1.0e-15, 2.0 * m.pi - 1.0e-15, 360, dtype=np.float64\n    )\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_dispersion_scenario","title":"<code>create_dispersion_scenario()</code>","text":"<p>Creates the dispersion scenario</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_dispersion_scenario(self):\n    \"\"\"\n    Creates the dispersion scenario\n    \"\"\"\n    self.incident_angle = np.linspace(0.0 + 1.0e-8, m.pi / 2.0 - 1.0e-8, 180, dtype=np.float64)\n\n    self.azimuthal_angle = np.linspace(1.0e-5, 2.0 * m.pi - 1.0e-5, 480, dtype=np.float64)\n\n    self.frequency = float(self.frequency)\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_incident_scenario","title":"<code>create_incident_scenario()</code>","text":"<p>Creates the incident scenario</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_incident_scenario(self):\n    \"\"\"\n    Creates the incident scenario\n    \"\"\"\n    self.incident_angle = np.linspace(\n        -m.pi / 2.0 + 1.0e-9, m.pi / 2.0 - 1.0e-9, 360, dtype=np.float64\n    )\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_scenario","title":"<code>create_scenario()</code>","text":"<p>Creates the scenario based on the type</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_scenario(self):\n    \"\"\"\n    Creates the scenario based on the type\n    \"\"\"\n    if self.type == \"Incident\":\n        self.create_incident_scenario()\n    elif self.type == \"Azimuthal\":\n        self.create_azimuthal_scenario()\n    elif self.type == \"Dispersion\":\n        self.create_dispersion_scenario()\n    elif self.type == \"Simple\":\n        self.create_simple_scenario()\n    else:\n        raise NotImplementedError(f\"Scenario type {self.type} not implemented\")\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_simple_scenario","title":"<code>create_simple_scenario()</code>","text":"<p>Creates the simple scenario - single values for all parameters</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_simple_scenario(self):\n    \"\"\"\n    Creates the simple scenario - single values for all parameters\n    \"\"\"\n    # Convert to scalar values for consistency\n    self.incident_angle = np.float64(m.radians(self.incident_angle) + 1.0e-15)\n    self.azimuthal_angle = np.float64(m.radians(self.azimuthal_angle) + 1.0e-15)\n    self.frequency = float(self.frequency)\n</code></pre>"},{"location":"api/structure/","title":"Structure API","text":""},{"location":"api/structure/#hyperbolic_optics.structure","title":"<code>hyperbolic_optics.structure</code>","text":"<p>Structure class for the optical system</p>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure","title":"<code>Structure</code>","text":"<p>Class for the structure of the optical system.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>class Structure:\n    \"\"\"Class for the structure of the optical system.\"\"\"\n\n    def __init__(self):\n        self.scenario = None\n        self.factory = LayerFactory()\n        self.layers = []\n        self.incident_angle = None\n        self.azimuthal_angle = None\n        self.frequency = None\n        self.eps_prism = None\n        self.k_x = None\n        self.k_0 = None\n        self.r_pp = None\n        self.r_ss = None\n        self.r_ps = None\n        self.r_sp = None\n        self.transfer_matrix = None\n\n    def get_scenario(self, scenario_data):\n        \"\"\"Get the scenario from the scenario_data.\"\"\"\n        self.scenario = ScenarioSetup(scenario_data)\n        self.setup_attributes()\n\n    def setup_attributes(self):\n        \"\"\"Set up the attributes for the structure based on the scenario.\"\"\"\n        self.incident_angle = self.scenario.incident_angle\n        self.azimuthal_angle = self.scenario.azimuthal_angle\n        self.frequency = self.scenario.frequency\n\n    def get_frequency_range(self, last_layer):\n        \"\"\"Get the frequency range based on the material of the last layer.\"\"\"\n        material = last_layer[\"material\"]\n\n        if material == \"Quartz\":\n            self.frequency = Quartz().frequency\n        elif material == \"Sapphire\":\n            self.frequency = Sapphire().frequency\n        elif material == \"Calcite\":\n            self.frequency = CalciteUpper().frequency\n        elif material == \"GalliumOxide\":\n            self.frequency = GalliumOxide().frequency\n        else:\n            raise NotImplementedError(\"Material not implemented\")\n\n    def calculate_kx_k0(self):\n        \"\"\"Calculate the k_x and k_0 values for the structure.\"\"\"\n        self.k_x = (\n            np.sqrt(np.float64(self.eps_prism)) * np.sin(self.incident_angle.astype(np.float64))\n        ).astype(np.float64)\n        self.k_0 = self.frequency * 2.0 * m.pi\n\n    def get_layers(self, layer_data_list):\n        \"\"\"Create the layers from the layer_data_list.\"\"\"\n        # First Layer is prism, so we parse it\n        self.eps_prism = layer_data_list[0].get(\"permittivity\", None)\n        if not self.frequency:\n            last_layer = layer_data_list[-1]\n            if last_layer.get(\"type\") != \"Semi Infinite Isotropic Layer\":\n                self.get_frequency_range(last_layer)\n            else:\n                self.get_frequency_range(layer_data_list[-2])\n        self.calculate_kx_k0()\n\n        # Create prism layer and add it to layers list\n        self.layers.append(\n            self.factory.create_layer(\n                layer_data_list[0],\n                self.scenario,\n                self.k_x,\n                self.k_0,\n            )\n        )\n\n        # Create the rest of the layers and add them to layers list\n        for layer_data in layer_data_list[1:]:\n            self.layers.append(\n                self.factory.create_layer(\n                    layer_data,\n                    self.scenario,\n                    self.k_x,\n                    self.k_0,\n                )\n            )\n\n    def calculate(self):\n        \"\"\"Calculate the transfer matrix for the given layers.\"\"\"\n        self.transfer_matrices = [layer.matrix for layer in self.layers]\n        self.transfer_matrix = functools.reduce(operator.matmul, self.transfer_matrices)\n\n    def calculate_reflectivity(self):\n        \"\"\"Calculate the reflectivity for the given transfer matrix.\"\"\"\n        bottom_line = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n        )\n        self.r_pp = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 3, 2]\n            - self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 0, 2]\n        ) / bottom_line\n        self.r_ps = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 1, 2]\n            - (self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 0, 2])\n        ) / bottom_line\n        self.r_sp = (\n            self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 3, 2] * self.transfer_matrix[..., 2, 0]\n        ) / bottom_line\n        self.r_ss = (\n            self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 1, 2] * self.transfer_matrix[..., 2, 0]\n        ) / bottom_line\n\n    def calculate_transmissivity(self):\n        \"\"\"Calculate the transmissivity for the given transfer matrix.\"\"\"\n        bottom_line = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n        )\n        self.t_pp = (self.transfer_matrix[..., 0, 0]) / bottom_line\n        self.t_ps = (-self.transfer_matrix[..., 0, 2]) / bottom_line\n        self.t_sp = (-self.transfer_matrix[..., 2, 0]) / bottom_line\n        self.t_ss = (self.transfer_matrix[..., 2, 2]) / bottom_line\n\n    def display_layer_info(self):\n        \"\"\"Display the information for each layer in the structure.\"\"\"\n        for layer in self.layers:\n            print(layer)\n            print(layer)\n\n    def execute(self, payload):\n        \"\"\"\n        Execute the calculation of reflectivity for the given scenario and layers.\n\n        Args:\n            payload (dict): A dictionary containing the scenario data and layers.\n        \"\"\"\n        # Get the scenario data\n        self.get_scenario(payload.get(\"ScenarioData\"))\n\n        # Get the layers\n        self.get_layers(payload.get(\"Layers\", None))\n\n        # Calculate the transfer matrix\n        self.calculate()\n\n        # Calculate the reflectivity\n        self.calculate_reflectivity()\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate","title":"<code>calculate()</code>","text":"<p>Calculate the transfer matrix for the given layers.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the transfer matrix for the given layers.\"\"\"\n    self.transfer_matrices = [layer.matrix for layer in self.layers]\n    self.transfer_matrix = functools.reduce(operator.matmul, self.transfer_matrices)\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate_kx_k0","title":"<code>calculate_kx_k0()</code>","text":"<p>Calculate the k_x and k_0 values for the structure.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate_kx_k0(self):\n    \"\"\"Calculate the k_x and k_0 values for the structure.\"\"\"\n    self.k_x = (\n        np.sqrt(np.float64(self.eps_prism)) * np.sin(self.incident_angle.astype(np.float64))\n    ).astype(np.float64)\n    self.k_0 = self.frequency * 2.0 * m.pi\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate_reflectivity","title":"<code>calculate_reflectivity()</code>","text":"<p>Calculate the reflectivity for the given transfer matrix.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate_reflectivity(self):\n    \"\"\"Calculate the reflectivity for the given transfer matrix.\"\"\"\n    bottom_line = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n    )\n    self.r_pp = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 3, 2]\n        - self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 0, 2]\n    ) / bottom_line\n    self.r_ps = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 1, 2]\n        - (self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 0, 2])\n    ) / bottom_line\n    self.r_sp = (\n        self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 3, 2] * self.transfer_matrix[..., 2, 0]\n    ) / bottom_line\n    self.r_ss = (\n        self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 1, 2] * self.transfer_matrix[..., 2, 0]\n    ) / bottom_line\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate_transmissivity","title":"<code>calculate_transmissivity()</code>","text":"<p>Calculate the transmissivity for the given transfer matrix.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate_transmissivity(self):\n    \"\"\"Calculate the transmissivity for the given transfer matrix.\"\"\"\n    bottom_line = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n    )\n    self.t_pp = (self.transfer_matrix[..., 0, 0]) / bottom_line\n    self.t_ps = (-self.transfer_matrix[..., 0, 2]) / bottom_line\n    self.t_sp = (-self.transfer_matrix[..., 2, 0]) / bottom_line\n    self.t_ss = (self.transfer_matrix[..., 2, 2]) / bottom_line\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.display_layer_info","title":"<code>display_layer_info()</code>","text":"<p>Display the information for each layer in the structure.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def display_layer_info(self):\n    \"\"\"Display the information for each layer in the structure.\"\"\"\n    for layer in self.layers:\n        print(layer)\n        print(layer)\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.execute","title":"<code>execute(payload)</code>","text":"<p>Execute the calculation of reflectivity for the given scenario and layers.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>A dictionary containing the scenario data and layers.</p> required Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def execute(self, payload):\n    \"\"\"\n    Execute the calculation of reflectivity for the given scenario and layers.\n\n    Args:\n        payload (dict): A dictionary containing the scenario data and layers.\n    \"\"\"\n    # Get the scenario data\n    self.get_scenario(payload.get(\"ScenarioData\"))\n\n    # Get the layers\n    self.get_layers(payload.get(\"Layers\", None))\n\n    # Calculate the transfer matrix\n    self.calculate()\n\n    # Calculate the reflectivity\n    self.calculate_reflectivity()\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.get_frequency_range","title":"<code>get_frequency_range(last_layer)</code>","text":"<p>Get the frequency range based on the material of the last layer.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def get_frequency_range(self, last_layer):\n    \"\"\"Get the frequency range based on the material of the last layer.\"\"\"\n    material = last_layer[\"material\"]\n\n    if material == \"Quartz\":\n        self.frequency = Quartz().frequency\n    elif material == \"Sapphire\":\n        self.frequency = Sapphire().frequency\n    elif material == \"Calcite\":\n        self.frequency = CalciteUpper().frequency\n    elif material == \"GalliumOxide\":\n        self.frequency = GalliumOxide().frequency\n    else:\n        raise NotImplementedError(\"Material not implemented\")\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.get_layers","title":"<code>get_layers(layer_data_list)</code>","text":"<p>Create the layers from the layer_data_list.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def get_layers(self, layer_data_list):\n    \"\"\"Create the layers from the layer_data_list.\"\"\"\n    # First Layer is prism, so we parse it\n    self.eps_prism = layer_data_list[0].get(\"permittivity\", None)\n    if not self.frequency:\n        last_layer = layer_data_list[-1]\n        if last_layer.get(\"type\") != \"Semi Infinite Isotropic Layer\":\n            self.get_frequency_range(last_layer)\n        else:\n            self.get_frequency_range(layer_data_list[-2])\n    self.calculate_kx_k0()\n\n    # Create prism layer and add it to layers list\n    self.layers.append(\n        self.factory.create_layer(\n            layer_data_list[0],\n            self.scenario,\n            self.k_x,\n            self.k_0,\n        )\n    )\n\n    # Create the rest of the layers and add them to layers list\n    for layer_data in layer_data_list[1:]:\n        self.layers.append(\n            self.factory.create_layer(\n                layer_data,\n                self.scenario,\n                self.k_x,\n                self.k_0,\n            )\n        )\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.get_scenario","title":"<code>get_scenario(scenario_data)</code>","text":"<p>Get the scenario from the scenario_data.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def get_scenario(self, scenario_data):\n    \"\"\"Get the scenario from the scenario_data.\"\"\"\n    self.scenario = ScenarioSetup(scenario_data)\n    self.setup_attributes()\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.setup_attributes","title":"<code>setup_attributes()</code>","text":"<p>Set up the attributes for the structure based on the scenario.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def setup_attributes(self):\n    \"\"\"Set up the attributes for the structure based on the scenario.\"\"\"\n    self.incident_angle = self.scenario.incident_angle\n    self.azimuthal_angle = self.scenario.azimuthal_angle\n    self.frequency = self.scenario.frequency\n</code></pre>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>All examples are available in the <code>examples/</code> directory of the repository.</p>"},{"location":"examples/basic/#simple-calcite-reflection","title":"Simple Calcite Reflection","text":"<p>Calculate basic reflection coefficients for a Calcite crystal.</p> examples/calcite.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nBasic Calcite Reflection Example\n\nThis script demonstrates the most basic usage of the hyperbolic-optics package\nby calculating reflection coefficients for a simple Calcite crystal structure.\n\"\"\"\n\n\nimport numpy as np\n\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Calculate basic reflection coefficients for Calcite at a single frequency and angle.\n    \"\"\"\n    print(\"=== Basic Calcite Reflection Example ===\\n\")\n\n    # Define a simple structure with Calcite\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Simple\",\n            \"incidentAngle\": 45.0,  # 45 degree incident angle\n            \"azimuthal_angle\": 0.0,  # No azimuthal rotation\n            \"frequency\": 1460.0,  # Frequency in cm^-1\n        },\n        \"Layers\": [\n            {\n                \"type\": \"Ambient Incident Layer\",\n                \"permittivity\": 50.0,  # High-index prism\n            },\n            {\n                \"type\": \"Isotropic Middle-Stack Layer\",\n                \"thickness\": 0.1,  # Thin air gap (in mm)\n                \"permittivity\": 1.0,  # Air\n            },\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 90,  # Rotate optical axis\n                \"rotationZ\": 0,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    print(\"Creating structure and calculating...\")\n    structure = Structure()\n    structure.execute(payload)\n\n    # Extract reflection coefficients\n    r_pp = structure.r_pp  # p-to-p polarization\n    r_ss = structure.r_ss  # s-to-s polarization\n    r_ps = structure.r_ps  # p-to-s polarization\n    r_sp = structure.r_sp  # s-to-p polarization\n\n    # Calculate reflectivities (|r|\u00b2)\n    R_pp = abs(r_pp) ** 2\n    R_ss = abs(r_ss) ** 2\n    R_ps = abs(r_ps) ** 2\n    R_sp = abs(r_sp) ** 2\n\n    # Display results\n    print(\"Results:\")\n    print(f\"  Incident angle: {structure.scenario.incident_angle * 180/np.pi:.1f}\u00b0\")\n    print(f\"  Frequency: {structure.frequency:.1f} cm\u207b\u00b9\")\n    print(\"  Material: Calcite\")\n    print()\n    print(\"Reflection Coefficients:\")\n    print(f\"  r_pp = {r_pp:.6f}\")\n    print(f\"  r_ss = {r_ss:.6f}\")\n    print(f\"  r_ps = {r_ps:.6f}\")\n    print(f\"  r_sp = {r_sp:.6f}\")\n    print()\n    print(\"Reflectivities (|r|\u00b2):\")\n    print(f\"  R_pp = {R_pp:.4f}\")\n    print(f\"  R_ss = {R_ss:.4f}\")\n    print(f\"  R_ps = {R_ps:.4f}\")\n    print(f\"  R_sp = {R_sp:.4f}\")\n    print()\n    print(f\"Total reflectivity for p-polarized light: {R_pp + R_ps:.4f}\")\n    print(f\"Total reflectivity for s-polarized light: {R_ss + R_sp:.4f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download calcite.py</p>"},{"location":"examples/basic/#frequency-vs-incident-angle","title":"Frequency vs Incident Angle","text":"<p>Generate dispersion plots showing frequency vs kx.</p> examples/frequency_vs_kx.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nk-Space Dispersion Plot Example\n\nThis script demonstrates how to generate k-space dispersion plots (kx vs ky)\nshowing the reflectivity in momentum space for a Calcite crystal.\n\"\"\"\n\n\nfrom hyperbolic_optics.plots import plot_kx_frequency\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Generate a k-space dispersion plot for Calcite.\n    \"\"\"\n    # Define dispersion scenario\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Incident\",\n        },\n        \"Layers\": [\n            {\"type\": \"Ambient Incident Layer\", \"permittivity\": 12.5},\n            {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 90,\n                \"rotationZ\": 90,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    structure = Structure()\n    structure.execute(payload)\n\n    # Calculate total reflectivity\n    R_total = abs(structure.r_pp) ** 2 + abs(structure.r_ps) ** 2\n\n    # Generate the plot using your existing plotting function\n\n    plot_kx_frequency(\n        structure,\n        R_total,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download frequency_vs_kx.py</p>"},{"location":"examples/basic/#k-space-dispersion","title":"k-Space Dispersion","text":"<p>Visualize polariton dispersion in momentum space (kx vs ky).</p> examples/kx_vs_ky.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nk-Space Dispersion Plot Example\n\nThis script demonstrates how to generate k-space dispersion plots (kx vs ky)\nshowing the reflectivity in momentum space for a Calcite crystal.\n\"\"\"\n\n\nfrom hyperbolic_optics.plots import plot_mueller_dispersion\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Generate a k-space dispersion plot for Calcite.\n    \"\"\"\n    # Define dispersion scenario\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Dispersion\",\n            \"frequency\": 1460.0,  # Fixed frequency in cm^-1\n        },\n        \"Layers\": [\n            {\"type\": \"Ambient Incident Layer\", \"permittivity\": 25.0},\n            {\n                \"type\": \"Isotropic Middle-Stack Layer\",\n                \"thickness\": 0.5,\n                \"permittivity\": 1.0,\n            },\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 70,  # Optical axis tilt\n                \"rotationZ\": 0,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    structure = Structure()\n    structure.execute(payload)\n\n    # Calculate total reflectivity\n    R_total = abs(structure.r_pp) ** 2 + abs(structure.r_ps) ** 2\n\n    # Generate the plot using your existing plotting function\n\n    plot_mueller_dispersion(\n        structure,\n        R_total,\n        title=\"The Hyperbolic Ghost Polariton\",\n        rotation_y=70,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download kx_vs_ky.py</p>"},{"location":"examples/basic/#azimuthal-variation","title":"Azimuthal Variation","text":"<p>Study how reflectivity changes with sample rotation.</p> examples/azimuthal_variation.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nk-Space Dispersion Plot Example\n\nThis script demonstrates how to generate k-space dispersion plots (kx vs ky)\nshowing the reflectivity in momentum space for a Calcite crystal.\n\"\"\"\n\n\nfrom hyperbolic_optics.plots import plot_mueller_azimuthal\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Generate a k-space dispersion plot for Calcite.\n    \"\"\"\n    # Define dispersion scenario\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Azimuthal\",\n            \"incidentAngle\": 40,\n        },\n        \"Layers\": [\n            {\"type\": \"Ambient Incident Layer\", \"permittivity\": 12.5},\n            {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 90,\n                \"rotationZ\": 0,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    structure = Structure()\n    structure.execute(payload)\n\n    # Calculate total reflectivity\n    R_total = abs(structure.r_pp) ** 2 + abs(structure.r_ps) ** 2\n\n    # Generate the plot using your existing plotting function\n\n    plot_mueller_azimuthal(\n        structure,\n        R_total,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download azimuthal_variation.py</p>"},{"location":"examples/basic/#running-the-examples","title":"Running the Examples","text":"<p>Clone the repository and run any example:</p> <pre><code>git clone https://github.com/MarkCunningham0410/hyperbolic_optics.git\ncd hyperbolic_optics\npython examples/calcite.py\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install hyperbolic-optics\n</code></pre>"},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (recommended)","text":"<pre><code>uv add hyperbolic-optics\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute or modify the source code:</p> <pre><code># Clone the repository\ngit clone https://github.com/MarkCunningham0410/hyperbolic_optics.git\ncd hyperbolic_optics\n\n# Install with all extras\nuv sync --all-extras\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test your installation:</p> <pre><code>from hyperbolic_optics.structure import Structure\nprint(\"Installation successful!\")\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>The package automatically installs:</p> <ul> <li>NumPy &gt;= 1.20.0</li> <li>SciPy &gt;= 1.7.0</li> <li>Matplotlib &gt;= 3.5.0</li> </ul>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For development:</p> <pre><code>uv sync --extra dev\n</code></pre> <p>This includes pytest, black, isort, and flake8 for testing and code quality.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#your-first-simulation","title":"Your First Simulation","text":"<p>Let's run a simple simulation to calculate reflection coefficients for a Calcite crystal.</p> <pre><code>from hyperbolic_optics.structure import Structure\n\n# Define the structure\npayload = {\n    \"ScenarioData\": {\n        \"type\": \"Simple\",\n        \"incidentAngle\": 45.0,      # degrees\n        \"azimuthal_angle\": 0.0,      # degrees\n        \"frequency\": 1460.0          # cm^-1\n    },\n    \"Layers\": [\n        {\n            \"type\": \"Ambient Incident Layer\",\n            \"permittivity\": 50.0\n        },\n        {\n            \"type\": \"Isotropic Middle-Stack Layer\",\n            \"thickness\": 0.1,  # mm\n            \"permittivity\": 1.0\n        },\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Calcite\",\n            \"rotationX\": 0,\n            \"rotationY\": 90,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\n# Run simulation\nstructure = Structure()\nstructure.execute(payload)\n\n# Get reflection coefficients\nr_pp = structure.r_pp  # p-to-p\nr_ss = structure.r_ss  # s-to-s\nr_ps = structure.r_ps  # p-to-s\nr_sp = structure.r_sp  # s-to-p\n\n# Calculate reflectivities\nR_pp = abs(r_pp)**2\nR_ss = abs(r_ss)**2\n\nprint(f\"p-polarized reflectivity: {R_pp:.4f}\")\nprint(f\"s-polarized reflectivity: {R_ss:.4f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#adding-mueller-matrix-analysis","title":"Adding Mueller Matrix Analysis","text":"<pre><code>from hyperbolic_optics.mueller import Mueller\n\n# Use the structure from above\nmueller = Mueller(structure)\n\n# Set incident polarization\nmueller.set_incident_polarization('linear', angle=45)\n\n# Add the sample\nmueller.add_optical_component('anisotropic_sample')\n\n# Get all parameters\nparams = mueller.get_all_parameters()\n\nprint(f\"Reflectance (S0): {params['S0']:.4f}\")\nprint(f\"Degree of polarization: {params['DOP']:.4f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#running-different-scenarios","title":"Running Different Scenarios","text":""},{"location":"getting-started/quickstart/#incident-angle-sweep","title":"Incident Angle Sweep","text":"<pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Incident\",  # Sweeps through angles\n    },\n    \"Layers\": [\n        {\"type\": \"Ambient Incident Layer\", \"permittivity\": 12.5},\n        {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Calcite\",\n            \"rotationX\": 0,\n            \"rotationY\": 90,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\nstructure = Structure()\nstructure.execute(payload)\n\n# Results are now arrays: shape (410, 360)\n# 410 frequency points x 360 angle points\n</code></pre>"},{"location":"getting-started/quickstart/#plotting-results","title":"Plotting Results","text":"<pre><code>from hyperbolic_optics.plots import plot_kx_frequency\n\n# Calculate total reflectivity\nR_total = abs(structure.r_pp)**2 + abs(structure.r_ps)**2\n\n# Generate plot\nplot_kx_frequency(structure, R_total, save_name=\"my_simulation\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about different scenarios</li> <li>Explore available materials</li> <li>See more examples</li> <li>Check the API reference</li> </ul>"},{"location":"user-guide/concepts/","title":"Basic Concepts","text":""},{"location":"user-guide/concepts/#overview","title":"Overview","text":"<p>The hyperbolic-optics package uses the 4\u00d74 transfer matrix method to calculate reflection and transmission coefficients for multilayer anisotropic structures.</p>"},{"location":"user-guide/concepts/#key-components","title":"Key Components","text":""},{"location":"user-guide/concepts/#structure","title":"Structure","text":"<p>The <code>Structure</code> class is the main interface for setting up and running simulations. It:</p> <ul> <li>Defines the geometry (layers and materials)</li> <li>Sets up the scenario (angles, frequencies)</li> <li>Calculates reflection coefficients</li> </ul>"},{"location":"user-guide/concepts/#layers","title":"Layers","text":"<p>A structure consists of multiple layers:</p> <ol> <li>Ambient Incident Layer: The incident medium (e.g., prism)</li> <li>Middle Layers: Can be isotropic or anisotropic, finite thickness</li> <li>Exit Layer: Usually semi-infinite, can be isotropic or anisotropic</li> </ol>"},{"location":"user-guide/concepts/#materials","title":"Materials","text":"<p>Materials are defined by their permittivity (\u03b5) and permeability (\u03bc) tensors:</p> <ul> <li>Uniaxial: Single optical axis (Quartz, Calcite, Sapphire)</li> <li>Biaxial/Monoclinic: Two or three optical axes (Gallium Oxide)</li> <li>Isotropic: No optical axis (Air, glass)</li> <li>Arbitrary: Custom-defined tensors</li> </ul>"},{"location":"user-guide/concepts/#reflection-coefficients","title":"Reflection Coefficients","text":"<p>The package calculates four reflection coefficients:</p> <ul> <li>r_pp: p-polarized \u2192 p-polarized</li> <li>r_ss: s-polarized \u2192 s-polarized  </li> <li>r_ps: p-polarized \u2192 s-polarized</li> <li>r_sp: s-polarized \u2192 p-polarized</li> </ul> <p>Reflectivity is calculated as: \\(R = |r|^2\\)</p>"},{"location":"user-guide/concepts/#coordinate-system","title":"Coordinate System","text":"<ul> <li>x-axis: Parallel to the interface, in the plane of incidence</li> <li>y-axis: Parallel to the interface, perpendicular to plane of incidence</li> <li>z-axis: Normal to the interface (propagation direction)</li> </ul>"},{"location":"user-guide/concepts/#rotations","title":"Rotations","text":"<p>Materials can be rotated using Euler angles:</p> <ul> <li>rotationY: Rotation around y-axis (often the optical axis tilt)</li> <li>rotationZ: Rotation around z-axis (azimuthal rotation)</li> </ul>"},{"location":"user-guide/concepts/#transfer-matrix-method","title":"Transfer Matrix Method","text":"<p>The 4\u00d74 transfer matrix method tracks both electric and magnetic field components through each layer. For each layer:</p> <ol> <li>Calculate the Berreman matrix (describes wave propagation)</li> <li>Find eigenvalues and eigenvectors (wave modes)</li> <li>Construct the transfer matrix</li> <li>Multiply matrices for all layers</li> <li>Extract reflection coefficients</li> </ol>"},{"location":"user-guide/concepts/#mueller-matrices","title":"Mueller Matrices","text":"<p>Mueller matrices describe how polarization states transform upon reflection:</p> \\[\\mathbf{S}_{out} = \\mathbf{M} \\cdot \\mathbf{S}_{in}\\] <p>Where \\(\\mathbf{S}\\) is the Stokes vector: \\([S_0, S_1, S_2, S_3]^T\\)</p> <p>The package can: 1. Calculate Mueller matrices from reflection coefficients 2. Simulate optical components (polarizers, wave plates) 3. Calculate Stokes parameters and polarization properties</p>"},{"location":"user-guide/concepts/#units","title":"Units","text":"<ul> <li>Frequency: cm\u207b\u00b9 (wavenumbers)</li> <li>Thickness: mm (converted to cm internally)</li> <li>Angles: degrees (converted to radians internally)</li> <li>Permittivity/Permeability: dimensionless</li> </ul>"},{"location":"user-guide/materials/","title":"Materials","text":""},{"location":"user-guide/materials/#built-in-materials","title":"Built-in Materials","text":""},{"location":"user-guide/materials/#uniaxial-materials","title":"Uniaxial Materials","text":"<p>Materials with a single optical axis (extraordinary axis differs from ordinary axes).</p>"},{"location":"user-guide/materials/#quartz","title":"Quartz","text":"<pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"Quartz\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,  # Optical axis orientation\n    \"rotationZ\": 0\n}\n</code></pre> <ul> <li>Frequency range: 410-600 cm\u207b\u00b9</li> <li>Type: Uniaxial positive</li> <li>Applications: Mid-infrared phonon polaritons</li> </ul>"},{"location":"user-guide/materials/#calcite","title":"Calcite","text":"<p>Two variants available:</p> <p>Upper Reststrahlen Band: <pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"Calcite\",  # or \"CalciteUpper\"\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre></p> <ul> <li>Frequency range: 1300-1600 cm\u207b\u00b9</li> <li>Type: Uniaxial negative (hyperbolic)</li> </ul> <p>Lower Reststrahlen Band: <pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"CalciteLower\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre></p> <ul> <li>Frequency range: 860-920 cm\u207b\u00b9</li> <li>Type: Uniaxial positive</li> </ul>"},{"location":"user-guide/materials/#sapphire","title":"Sapphire","text":"<pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"Sapphire\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre> <ul> <li>Frequency range: 210-1000 cm\u207b\u00b9</li> <li>Type: Uniaxial negative</li> <li>Applications: Wide-band phonon polaritons</li> </ul>"},{"location":"user-guide/materials/#monoclinic-materials","title":"Monoclinic Materials","text":""},{"location":"user-guide/materials/#gallium-oxide-ga2o3","title":"Gallium Oxide (\u03b2-Ga\u2082O\u2083)","text":"<pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"GalliumOxide\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre> <ul> <li>Frequency range: 350-800 cm\u207b\u00b9</li> <li>Type: Monoclinic (non-zero off-diagonal elements)</li> <li>Special: Has xy coupling (\u03b5_xy \u2260 0)</li> </ul>"},{"location":"user-guide/materials/#isotropic-materials","title":"Isotropic Materials","text":""},{"location":"user-guide/materials/#air","title":"Air","text":"<p>Used for air gaps and isotropic layers:</p> <pre><code>{\n    \"type\": \"Isotropic Middle-Stack Layer\",\n    \"thickness\": 0.5,\n    \"permittivity\": 1.0  # Air\n}\n</code></pre>"},{"location":"user-guide/materials/#custom-isotropic","title":"Custom Isotropic","text":"<pre><code>{\n    \"type\": \"Isotropic Middle-Stack Layer\",\n    \"thickness\": 0.5,\n    \"permittivity\": {\"real\": 2.5, \"imag\": 0.1}\n}\n</code></pre>"},{"location":"user-guide/materials/#arbitrary-materials","title":"Arbitrary Materials","text":"<p>Define custom materials with full tensors:</p> <pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": {\n        \"eps_xx\": {\"real\": 2.27, \"imag\": 0.001},\n        \"eps_yy\": {\"real\": -4.84, \"imag\": 0.755},\n        \"eps_zz\": {\"real\": -4.84, \"imag\": 0.755},\n        \"eps_xy\": {\"real\": 0.0, \"imag\": 0.0},\n        \"eps_xz\": {\"real\": 0.0, \"imag\": 0.0},\n        \"eps_yz\": {\"real\": 0.0, \"imag\": 0.0}\n    },\n    \"rotationX\": 0,\n    \"rotationY\": 0,\n    \"rotationZ\": 0\n}\n</code></pre>"},{"location":"user-guide/materials/#material-rotations","title":"Material Rotations","text":""},{"location":"user-guide/materials/#rotation-types","title":"Rotation Types","text":"<p>Materials can be rotated using Euler angles (in degrees):</p> <ul> <li>rotationX: Rotation around x-axis (Not really used)</li> <li>rotationY: Rotation around y-axis (typically optical axis tilt)</li> <li>rotationZ: Rotation around z-axis (azimuthal)</li> </ul>"},{"location":"user-guide/materials/#rotation-examples","title":"Rotation Examples","text":"<p>Optical axis perpendicular to interface: <pre><code>\"rotationX\": 0,\n\"rotationY\": 0,\n\"rotationZ\": 0\n</code></pre></p> <p>Optical axis in the plane (70\u00b0 tilt): <pre><code>\"rotationX\": 0,\n\"rotationY\": 70,\n\"rotationZ\": 0\n</code></pre></p> <p>45\u00b0 azimuthal rotation: <pre><code>\"rotationX\": 0,\n\"rotationY\": 90,\n\"rotationZ\": 45\n</code></pre></p>"},{"location":"user-guide/materials/#rotation-types-for-z-rotation","title":"Rotation Types for Z-rotation","text":"<pre><code>\"rotationZ\": 45,\n\"rotationZType\": \"relative\"  # Default: rotates with azimuthal angle\n</code></pre> <p>or</p> <pre><code>\"rotationZ\": 45,\n\"rotationZType\": \"static\"  # Fixed: doesn't rotate with azimuthal angle\n</code></pre>"},{"location":"user-guide/materials/#plotting-material-properties","title":"Plotting Material Properties","text":"<pre><code>from hyperbolic_optics.materials import CalciteUpper\nfrom hyperbolic_optics.plots import plot_permittivity\n\n# Create material\ncalcite = CalciteUpper()\n\n# Get permittivity\neps_ext, eps_ord = calcite.permittivity_fetch()\n\n# Plot\nplot_permittivity(calcite, eps_ext, eps_ord, save_name=\"calcite_permittivity\")\n</code></pre>"},{"location":"user-guide/materials/#material-properties-summary","title":"Material Properties Summary","text":"Material Type Frequency Range Hyperbolic? Quartz Uniaxial 410-600 cm\u207b\u00b9 Yes Calcite Upper Uniaxial 1300-1600 cm\u207b\u00b9 Yes Calcite Lower Uniaxial 860-920 cm\u207b\u00b9 Yes Sapphire Uniaxial 210-1000 cm\u207b\u00b9 Yes Gallium Oxide Monoclinic 350-800 cm\u207b\u00b9 Yes <p>Note: A material is \"hyperbolic\" when the real parts of permittivity components have opposite signs.</p>"},{"location":"user-guide/mueller/","title":"Mueller Matrices","text":"<p>Mueller matrices describe how light's polarization state changes upon reflection from a surface.</p>"},{"location":"user-guide/mueller/#basic-usage","title":"Basic Usage","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.mueller import Mueller\n\n# Create structure\nstructure = Structure()\nstructure.execute(payload)\n\n# Create Mueller analyzer\nmueller = Mueller(structure)\n\n# Set incident polarization\nmueller.set_incident_polarization('linear', angle=45)\n\n# Add the sample\nmueller.add_optical_component('anisotropic_sample')\n\n# Calculate results\nparams = mueller.get_all_parameters()\n</code></pre>"},{"location":"user-guide/mueller/#incident-polarization-states","title":"Incident Polarization States","text":""},{"location":"user-guide/mueller/#linear-polarization","title":"Linear Polarization","text":"<pre><code># p-polarized (0\u00b0)\nmueller.set_incident_polarization('linear', angle=0)\n\n# s-polarized (90\u00b0)\nmueller.set_incident_polarization('linear', angle=90)\n\n# 45\u00b0 linear\nmueller.set_incident_polarization('linear', angle=45)\n</code></pre>"},{"location":"user-guide/mueller/#circular-polarization","title":"Circular Polarization","text":"<pre><code># Right-handed circular\nmueller.set_incident_polarization('circular', handedness='right')\n\n# Left-handed circular\nmueller.set_incident_polarization('circular', handedness='left')\n</code></pre>"},{"location":"user-guide/mueller/#elliptical-polarization","title":"Elliptical Polarization","text":"<pre><code># Elliptical with azimuth 30\u00b0 and ellipticity 20\u00b0\nmueller.set_incident_polarization('elliptical', alpha=30, ellipticity=20)\n</code></pre>"},{"location":"user-guide/mueller/#optical-components","title":"Optical Components","text":""},{"location":"user-guide/mueller/#anisotropic-sample","title":"Anisotropic Sample","text":"<p>The main sample being analyzed:</p> <pre><code>mueller.add_optical_component('anisotropic_sample')\n</code></pre>"},{"location":"user-guide/mueller/#linear-polarizer","title":"Linear Polarizer","text":"<pre><code># Horizontal polarizer (0\u00b0)\nmueller.add_optical_component('linear_polarizer', 0)\n\n# Vertical polarizer (90\u00b0)\nmueller.add_optical_component('linear_polarizer', 90)\n\n# 45\u00b0 polarizer\nmueller.add_optical_component('linear_polarizer', 45)\n</code></pre>"},{"location":"user-guide/mueller/#quarter-wave-plate","title":"Quarter-Wave Plate","text":"<pre><code># QWP with fast axis at 45\u00b0\nmueller.add_optical_component('quarter_wave_plate', 45)\n</code></pre>"},{"location":"user-guide/mueller/#half-wave-plate","title":"Half-Wave Plate","text":"<pre><code># HWP with fast axis at 22.5\u00b0\nmueller.add_optical_component('half_wave_plate', 22.5)\n</code></pre>"},{"location":"user-guide/mueller/#multiple-components","title":"Multiple Components","text":"<p>Place components in series:</p> <pre><code># Polarizer \u2192 Sample \u2192 Analyzer\nmueller.set_incident_polarization('linear', angle=0)\nmueller.add_optical_component('linear_polarizer', 0)  # Input polarizer\nmueller.add_optical_component('anisotropic_sample')    # Sample\nmueller.add_optical_component('linear_polarizer', 90)  # Analyzer (crossed)\n\nreflectivity = mueller.get_reflectivity()\n</code></pre>"},{"location":"user-guide/mueller/#stokes-parameters","title":"Stokes Parameters","text":"<p>The Stokes parameters describe the polarization state:</p> <ul> <li>S0: Total intensity (reflectance)</li> <li>S1: Horizontal vs vertical linear polarization</li> <li>S2: +45\u00b0 vs -45\u00b0 linear polarization</li> <li>S3: Right vs left circular polarization</li> </ul> <pre><code>stokes = mueller.get_stokes_parameters()\n\nprint(f\"Total intensity: {stokes['S0']}\")\nprint(f\"Linear H/V: {stokes['S1']}\")\nprint(f\"Linear \u00b145\u00b0: {stokes['S2']}\")\nprint(f\"Circular R/L: {stokes['S3']}\")\n</code></pre>"},{"location":"user-guide/mueller/#polarization-properties","title":"Polarization Properties","text":""},{"location":"user-guide/mueller/#degree-of-polarization-dop","title":"Degree of Polarization (DOP)","text":"<pre><code>dop = mueller.get_degree_of_polarisation()\n# DOP = 0: unpolarized\n# DOP = 1: fully polarized\n</code></pre>"},{"location":"user-guide/mueller/#ellipticity","title":"Ellipticity","text":"<pre><code>ellipticity = mueller.get_ellipticity()\n# Ellipticity angle in radians\n# 0: linear\n# \u00b1\u03c0/4: circular\n</code></pre>"},{"location":"user-guide/mueller/#azimuth","title":"Azimuth","text":"<pre><code>azimuth = mueller.get_azimuth()\n# Orientation of polarization ellipse major axis\n</code></pre>"},{"location":"user-guide/mueller/#all-parameters-at-once","title":"All Parameters at Once","text":"<pre><code>params = mueller.get_all_parameters()\n\n# Contains: S0, S1, S2, S3, DOP, Ellipticity, Azimuth\nfor key, value in params.items():\n    print(f\"{key}: {value}\")\n</code></pre>"},{"location":"user-guide/mueller/#complete-example","title":"Complete Example","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.mueller import Mueller\n\n# Define structure\npayload = {\n    \"ScenarioData\": {\n        \"type\": \"Incident\"\n    },\n    \"Layers\": [\n        {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.1},\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Quartz\",\n            \"rotationX\": 0,\n            \"rotationY\": 70,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\n# Run simulation\nstructure = Structure()\nstructure.execute(payload)\n\n# Mueller analysis\nmueller = Mueller(structure)\n\n# Try different incident polarizations\nfor angle in [0, 45, 90]:\n    mueller.set_incident_polarization('linear', angle=angle)\n    mueller.add_optical_component('anisotropic_sample')\n\n    params = mueller.get_all_parameters()\n    print(f\"\\nIncident angle: {angle}\u00b0\")\n    print(f\"Average reflectance: {params['S0'].mean():.4f}\")\n    print(f\"Average DOP: {params['DOP'].mean():.4f}\")\n\n    mueller.reset()  # Reset for next calculation\n</code></pre>"},{"location":"user-guide/mueller/#resetting-the-mueller-object","title":"Resetting the Mueller Object","text":"<pre><code># Clear all settings and start fresh\nmueller.reset()\n</code></pre> <p>This clears: - Mueller matrix - Stokes parameters - Optical components - Resets incident polarization to unpolarized</p>"},{"location":"user-guide/mueller/#physical-interpretation","title":"Physical Interpretation","text":""},{"location":"user-guide/mueller/#reflectance-s0","title":"Reflectance (S0)","text":"<p>Total reflected power, sum of all polarization components.</p>"},{"location":"user-guide/mueller/#degree-of-polarization","title":"Degree of Polarization","text":"<ul> <li>DOP = 1: Fully polarized (pure state)</li> <li>0 &lt; DOP &lt; 1: Partially polarized</li> <li>DOP = 0: Unpolarized (random)</li> </ul>"},{"location":"user-guide/mueller/#understanding-s1-s2-s3","title":"Understanding S1, S2, S3","text":"<ul> <li>S1 &gt; 0: More horizontal than vertical</li> <li>S1 &lt; 0: More vertical than horizontal</li> <li>S2 &gt; 0: More +45\u00b0 than -45\u00b0</li> <li>S2 &lt; 0: More -45\u00b0 than +45\u00b0</li> <li>S3 &gt; 0: More right-circular</li> <li>S3 &lt; 0: More left-circular</li> </ul>"},{"location":"user-guide/scenarios/","title":"Scenarios","text":"<p>The package supports four different scenario types for different analysis needs.</p>"},{"location":"user-guide/scenarios/#simple-scenario","title":"Simple Scenario","text":"<p>Single point calculation at a specific angle, frequency, and orientation.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Simple\",\n        \"incidentAngle\": 45.0,      # degrees\n        \"azimuthal_angle\": 0.0,      # degrees  \n        \"frequency\": 1460.0          # cm^-1\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: Scalar values for reflection coefficients</p> <p>Use case: Quick calculations, debugging, single point analysis</p>"},{"location":"user-guide/scenarios/#incident-scenario","title":"Incident Scenario","text":"<p>Sweeps through incident angles at multiple frequencies.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Incident\"\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: <code>[410, 360]</code> - 410 frequency points \u00d7 360 angle points</p> <p>Use case: Analyzing angle-dependent behavior, finding resonances</p> <p>Plotting: Use <code>plot_kx_frequency()</code> for frequency vs kx plots</p>"},{"location":"user-guide/scenarios/#azimuthal-scenario","title":"Azimuthal Scenario","text":"<p>Rotates the sample azimuthally at a fixed incident angle.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Azimuthal\",\n        \"incidentAngle\": 40.0  # degrees\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: <code>[410, 360]</code> - 410 frequency points \u00d7 360 azimuthal angles</p> <p>Use case: Studying rotational symmetry, in-plane anisotropy</p> <p>Plotting: Use <code>plot_mueller_azimuthal()</code> for frequency vs \u03b2 plots</p>"},{"location":"user-guide/scenarios/#dispersion-scenario","title":"Dispersion Scenario","text":"<p>k-space dispersion at a fixed frequency.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Dispersion\",\n        \"frequency\": 1460.0  # cm^-1\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: <code>[180, 480]</code> - 180 incident angles \u00d7 480 azimuthal angles</p> <p>Use case: Visualizing polariton dispersion, identifying wave modes</p> <p>Plotting: Use <code>plot_mueller_dispersion()</code> for kx vs ky plots</p>"},{"location":"user-guide/scenarios/#choosing-a-scenario","title":"Choosing a Scenario","text":"Goal Scenario Type Quick single calculation Simple Angle-dependent analysis Incident Rotational behavior Azimuthal k-space dispersion relations Dispersion"},{"location":"user-guide/scenarios/#frequency-ranges","title":"Frequency Ranges","text":"<p>For <code>Incident</code> and <code>Azimuthal</code> scenarios, frequency ranges are automatically determined by the material:</p> <ul> <li>Calcite: 1300-1600 cm\u207b\u00b9 (upper) or 860-920 cm\u207b\u00b9 (lower)</li> <li>Quartz: 410-600 cm\u207b\u00b9</li> <li>Sapphire: 210-1000 cm\u207b\u00b9</li> <li>Gallium Oxide: 350-800 cm\u207b\u00b9</li> </ul>"},{"location":"user-guide/scenarios/#example-comparing-scenarios","title":"Example: Comparing Scenarios","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.plots import plot_kx_frequency, plot_mueller_dispersion\n\n# Same material, different scenarios\nbase_layers = [\n    {\"type\": \"Ambient Incident Layer\", \"permittivity\": 25.0},\n    {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n    {\n        \"type\": \"Semi Infinite Anisotropic Layer\",\n        \"material\": \"Calcite\",\n        \"rotationX\": 0,\n        \"rotationY\": 70,\n        \"rotationZ\": 0\n    }\n]\n\n# Incident scenario\npayload_incident = {\n    \"ScenarioData\": {\"type\": \"Incident\"},\n    \"Layers\": base_layers\n}\nstructure_inc = Structure()\nstructure_inc.execute(payload_incident)\nR_inc = abs(structure_inc.r_pp)**2\n\n# Dispersion scenario\npayload_disp = {\n    \"ScenarioData\": {\"type\": \"Dispersion\", \"frequency\": 1460.0},\n    \"Layers\": base_layers\n}\nstructure_disp = Structure()\nstructure_disp.execute(payload_disp)\nR_disp = abs(structure_disp.r_pp)**2\n\n# Plot both\nplot_kx_frequency(structure_inc, R_inc, save_name=\"incident\")\nplot_mueller_dispersion(structure_disp, R_disp, save_name=\"dispersion\")\n</code></pre>"}]}