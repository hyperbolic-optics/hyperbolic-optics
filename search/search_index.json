{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hyperbolic Optics Documentation","text":"<p>A comprehensive Python package for simulating the reflective properties of hyperbolic materials and anisotropic structures using the 4\u00d74 transfer matrix method.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Transfer Matrix Method: Accurate 4\u00d74 transfer matrix implementation for anisotropic media</li> <li>Multiple Scenarios: Support for incident angle sweeps, azimuthal rotations, dispersion analysis, and single-point calculations</li> <li>Materials Library: Pre-configured materials including Quartz, Calcite, Sapphire, and Gallium Oxide</li> <li>Mueller Matrix Analysis: Complete Stokes parameter and polarization analysis capabilities</li> <li>Custom Materials: Define arbitrary materials with custom permittivity and permeability tensors</li> <li>Visualization: Publication-quality plotting functions</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.mueller import Mueller\n\n# Define a simple structure\npayload = {\n    \"ScenarioData\": {\n        \"type\": \"Simple\",\n        \"incidentAngle\": 45.0,\n        \"azimuthal_angle\": 0.0,\n        \"frequency\": 1460.0\n    },\n    \"Layers\": [\n        {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.1},\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Calcite\",\n            \"rotationX\": 0,\n            \"rotationY\": 90,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\n# Run simulation\nstructure = Structure()\nstructure.execute(payload)\n\n# Calculate reflectivities\nR_pp = abs(structure.r_pp)**2\nR_ss = abs(structure.r_ss)**2\n\nprint(f\"p-polarized reflectivity: {R_pp:.4f}\")\nprint(f\"s-polarized reflectivity: {R_ss:.4f}\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install hyperbolic-optics\n</code></pre> <p>Or using uv (recommended):</p> <pre><code>uv add hyperbolic-optics\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Detailed installation instructions</li> <li>Quick Start - Get up and running quickly</li> <li>User Guide - Learn about core concepts</li> <li>API Reference - Detailed API documentation</li> <li>Examples - See more examples</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use this package in your research, please cite:</p> <pre><code>@software{cunningham2025hyperbolic,\n  title={Hyperbolic Optics Simulation Package},\n  author={Mark Cunningham},\n  year={2025},\n  version={0.1.8},\n  doi={10.5281/zenodo.14946556},\n  url={https://pypi.org/project/hyperbolic-optics/}\n}\n</code></pre>"},{"location":"#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Repository: GitHub Repository</li> </ul>"},{"location":"citation/","title":"Citation","text":"<p>If you use this package in your research, please cite:</p>"},{"location":"citation/#software-citation","title":"Software Citation","text":"<pre><code>@software{cunningham2025hyperbolic,\n  title={Hyperbolic Optics Simulation Package},\n  author={Mark Cunningham},\n  year={2025},\n  version={0.1.8},\n  doi={10.5281/zenodo.14946556},\n  url={https://pypi.org/project/hyperbolic-optics/},\n  howpublished={PyPI},\n  note={Python package for 4\u00d74 transfer matrix method simulations}\n}\n</code></pre>"},{"location":"citation/#related-publications","title":"Related Publications","text":"<p>This package was developed as part of research on hyperbolic polaritons and was used to generate results in:</p> <p>M. Cunningham et al., \"Optical footprint of ghost and leaky hyperbolic polaritons,\" Photonics Research, vol. 13, no. 8, pp. 2291-2305 (2025). DOI: 10.1364/PRJ.558334</p>"},{"location":"citation/#bibtex-entry-for-publication","title":"BibTeX Entry for Publication","text":"<pre><code>@article{cunningham2025optical,\n  title={Optical footprint of ghost and leaky hyperbolic polaritons},\n  author={Cunningham, Mark and others},\n  journal={Photonics Research},\n  volume={13},\n  number={8},\n  pages={2291--2305},\n  year={2025},\n  doi={10.1364/PRJ.558334}\n}\n</code></pre>"},{"location":"citation/#zenodo-doi","title":"Zenodo DOI","text":"<p>Permanent archive: 10.5281/zenodo.14946556</p>"},{"location":"citation/#citing-specific-versions","title":"Citing Specific Versions","text":"<p>If you need to cite a specific version:</p> <pre><code>@software{cunningham2025hyperbolic_v018,\n  title={Hyperbolic Optics Simulation Package},\n  author={Mark Cunningham},\n  year={2025},\n  version={0.1.8},\n  doi={10.5281/zenodo.14946556},\n  url={https://pypi.org/project/hyperbolic-optics/0.1.8/}\n}\n</code></pre>"},{"location":"citation/#acknowledgments","title":"Acknowledgments","text":"<p>This work builds upon the theoretical framework established by:</p> <ul> <li>N. C. Passler and A. Paarmann, \"Generalized 4 \u00d7 4 matrix formalism for light propagation in anisotropic stratified media,\" J. Opt. Soc. Am. B 34, 2128-2139 (2017)</li> <li>P. Yeh, \"Electromagnetic propagation in birefringent layered media,\" J. Opt. Soc. Am. 69, 742-756 (1979)</li> <li>N. C. Passler et al., \"Layer-resolved resonance intensity of evanescent polariton modes in anisotropic multilayers,\" Phys. Rev. B 107, 235426 (2023)</li> </ul>"},{"location":"citation/#copyright-and-license","title":"Copyright and License","text":"<p>Copyright (c) 2025 Mark Cunningham</p> <p>Licensed under the MIT License. See LICENSE for details.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to the Hyperbolic Optics package! This guide will help you get started.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Report bugs via GitHub Issues</li> <li>Request features or enhancements</li> <li>Improve documentation (fix typos, add examples, clarify explanations)</li> <li>Submit bug fixes or new features via Pull Requests</li> <li>Add new materials to the materials library</li> <li>Share your research that uses this package</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> <li>uv package manager (recommended)</li> <li>Git</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork and clone the repository</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/hyperbolic_optics.git\ncd hyperbolic_optics\n</code></pre> <ol> <li>Install dependencies</li> </ol> <pre><code># Using uv (recommended)\nuv sync --all-extras\n\n# Or using pip\npip install -e \".[dev]\"\n</code></pre> <ol> <li>Verify installation</li> </ol> <pre><code># Run tests\nuv run pytest\n\n# Check code works\npython examples/calcite.py\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"contributing/#2-make-your-changes","title":"2. Make Your Changes","text":"<p>Edit the code in your favorite editor. The main package is in <code>hyperbolic_optics/</code>.</p>"},{"location":"contributing/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=hyperbolic_optics --cov-report=html\n\n# Run specific test file\nuv run pytest tests/test_structure.py\n\n# Run specific test\nuv run pytest tests/test_structure.py::TestStructureBasicFunctionality::test_simple_scenario_execution\n</code></pre>"},{"location":"contributing/#4-check-code-quality","title":"4. Check Code Quality","text":"<pre><code># Format code with black\nuv run black hyperbolic_optics tests\n\n# Sort imports with isort\nuv run isort hyperbolic_optics tests\n\n# Lint with flake8\nuv run flake8 hyperbolic_optics tests --max-line-length=100 --extend-ignore=E203,W503\n</code></pre>"},{"location":"contributing/#5-update-documentation","title":"5. Update Documentation","text":"<p>If you added new features:</p> <ul> <li>Add docstrings to your functions/classes (they auto-generate API docs!)</li> <li>Update relevant user guide pages in <code>docs/</code></li> <li>Add examples if appropriate</li> </ul> <p>Build docs locally to preview:</p> <pre><code>uv run mkdocs serve\n# Visit http://127.0.0.1:8000\n</code></pre>"},{"location":"contributing/#6-commit-your-changes","title":"6. Commit Your Changes","text":"<pre><code>git add .\ngit commit -m \"Brief description of your changes\"\n</code></pre> <p>Write clear commit messages: - Use present tense (\"Add feature\" not \"Added feature\") - Be descriptive but concise - Reference issue numbers if applicable (#123)</p>"},{"location":"contributing/#7-push-and-create-pull-request","title":"7. Push and Create Pull Request","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then open a Pull Request on GitHub with: - Clear title and description - Reference to related issues - Summary of changes made - Any breaking changes noted</p>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"contributing/#python-code","title":"Python Code","text":"<ul> <li>Follow PEP 8 style guide</li> <li>Use type hints where appropriate</li> <li>Maximum line length: 100 characters</li> <li>Use descriptive variable names</li> </ul>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def example_function(param1, param2):\n    \"\"\"Brief description of function.\n\n    More detailed description if needed, explaining what the\n    function does and any important details.\n\n    Args:\n        param1 (float): Description of param1.\n        param2 (np.ndarray): Description of param2.\n\n    Returns:\n        dict: Description of return value.\n\n    Raises:\n        ValueError: When param1 is negative.\n\n    Example:\n        &gt;&gt;&gt; result = example_function(1.0, np.array([1, 2, 3]))\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#test-guidelines","title":"Test Guidelines","text":"<ul> <li>Write tests for all new features</li> <li>Aim for &gt;90% code coverage</li> <li>Use descriptive test names</li> <li>Group related tests in classes</li> <li>Use fixtures for common setup</li> </ul> <pre><code>def test_structure_executes_simple_scenario(simple_payload):\n    \"\"\"Test that structure executes simple scenario correctly.\"\"\"\n    structure = Structure()\n    structure.execute(simple_payload)\n\n    assert structure.r_pp is not None\n    assert structure.r_ss is not None\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>hyperbolic_optics/\n\u251c\u2500\u2500 hyperbolic_optics/          # Main package\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 structure.py            # Structure class\n\u2502   \u251c\u2500\u2500 materials.py            # Material definitions\n\u2502   \u251c\u2500\u2500 layers.py               # Layer classes\n\u2502   \u251c\u2500\u2500 mueller.py              # Mueller matrix calculations\n\u2502   \u251c\u2500\u2500 scenario.py             # Scenario types\n\u2502   \u251c\u2500\u2500 waves.py                # Wave calculations\n\u2502   \u251c\u2500\u2500 plots.py                # Plotting functions\n\u2502   \u2514\u2500\u2500 material_params.json    # Material parameters\n\u251c\u2500\u2500 tests/                      # Test suite\n\u2502   \u251c\u2500\u2500 conftest.py            # Pytest fixtures\n\u2502   \u251c\u2500\u2500 test_structure.py\n\u2502   \u251c\u2500\u2500 test_materials.py\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 examples/                   # Example scripts\n\u251c\u2500\u2500 docs/                       # Documentation\n\u251c\u2500\u2500 .github/workflows/          # CI/CD pipelines\n\u251c\u2500\u2500 pyproject.toml             # Project configuration\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"contributing/#adding-a-new-material","title":"Adding a New Material","text":"<ol> <li>Add material parameters to <code>hyperbolic_optics/material_params.json</code></li> <li>Create material class in <code>hyperbolic_optics/materials.py</code></li> <li>Add tests in <code>tests/test_materials.py</code></li> <li>Update documentation in <code>docs/user-guide/materials.md</code></li> </ol>"},{"location":"contributing/#adding-new-layer-types","title":"Adding New Layer Types","text":"<ol> <li>Create layer class in <code>hyperbolic_optics/layers.py</code></li> <li>Register in <code>LayerFactory.layer_classes</code></li> <li>Add tests in <code>tests/test_layers.py</code></li> <li>Update documentation</li> </ol>"},{"location":"contributing/#running-cicd-locally","title":"Running CI/CD Locally","text":"<p>The project uses GitHub Actions for CI/CD. You can test similar checks locally:</p> <pre><code># Run tests (like CI does)\nuv run pytest --cov=hyperbolic_optics --cov-report=xml --cov-report=term\n\n# Check formatting\nuv run black --check hyperbolic_optics tests\nuv run isort --check-only hyperbolic_optics tests\nuv run flake8 hyperbolic_optics tests --max-line-length=100 --extend-ignore=E203,W503\n</code></pre>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting bugs, please include:</p> <ul> <li>Python version (<code>python --version</code>)</li> <li>Package version (<code>pip show hyperbolic-optics</code>)</li> <li>Operating system</li> <li>Minimal code to reproduce the issue</li> <li>Full error traceback</li> <li>Expected vs actual behavior</li> </ul> <p>Example:</p> <pre><code>## Bug Description\nBrief description of the bug\n\n## To Reproduce\n\\```python\n# Minimal code to reproduce\n\\```\n\n## Expected Behavior\nWhat you expected to happen\n\n## Actual Behavior\nWhat actually happened\n\n## Environment\n- OS: macOS 14.2\n- Python: 3.12.1\n- Package version: 0.1.8\n</code></pre>"},{"location":"contributing/#code-review-process","title":"Code Review Process","text":"<ol> <li>All submissions require review</li> <li>Maintainers will provide feedback</li> <li>Address review comments by pushing new commits</li> <li>Once approved, maintainers will merge your PR</li> </ol>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open a Discussion for questions</li> <li>Check existing Issues</li> <li>Email: m.cunningham.2@research.gla.ac.uk</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Thank you for considering contributing to Hyperbolic Optics! Every contribution helps make the package better for everyone.</p>"},{"location":"api/layers/","title":"Layers API","text":""},{"location":"api/layers/#hyperbolic_optics.layers","title":"<code>hyperbolic_optics.layers</code>","text":"<p>Layer construction and transfer matrix calculation.</p> <p>This module implements various layer types for multilayer optical structures: - Ambient media (incident prism, exit medium) - Isotropic layers (air gaps, dielectric layers) - Anisotropic crystal layers (finite thickness) - Semi-infinite anisotropic layers</p> <p>Each layer type calculates its own transfer matrix using the 4\u00d74 formalism, which relates electromagnetic field components at the layer boundaries.</p>"},{"location":"api/layers/#hyperbolic_optics.layers.AirGapLayer","title":"<code>AirGapLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>The airgap/isotropic middle layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AirGapLayer(Layer):\n    \"\"\"The airgap/isotropic middle layer.\"\"\"\n\n    def __init__(\n        self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; None:\n        \"\"\"Initialize an isotropic middle-stack layer (air gap or dielectric).\n\n        Args:\n            data: Dictionary with 'thickness', 'permittivity', and optionally 'permeability'\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber\n\n        Note:\n            Permittivity and permeability can be specified as scalars or as\n            dictionaries with 'real' and 'imag' components.\n        \"\"\"\n        super().__init__(data, scenario, kx, k0)\n\n        # Handle complex permittivity input\n        perm = data.get(\"permittivity\", 1.0)\n        if isinstance(perm, dict):\n            if \"real\" in perm or \"imag\" in perm:\n                self.permittivity = complex(perm.get(\"real\", 0), perm.get(\"imag\", 0))\n            else:\n                # Handle nested permittivity structure if present\n                self.permittivity = {\n                    k: (complex(v.get(\"real\", 0), v.get(\"imag\", 0)) if isinstance(v, dict) else v)\n                    for k, v in perm.items()\n                }\n        else:\n            self.permittivity = complex(perm, 0)\n\n        # CHANGED: Handle magnetic permeability input\n        mu = data.get(\"permeability\", 1.0)\n        if isinstance(mu, dict):\n            if \"real\" in mu or \"imag\" in mu:\n                self.permeability = complex(mu.get(\"real\", 0), mu.get(\"imag\", 0))\n            else:\n                # Handle nested permeability structure if present\n                self.permeability = {\n                    k: (complex(v.get(\"real\", 0), v.get(\"imag\", 0)) if isinstance(v, dict) else v)\n                    for k, v in mu.items()\n                }\n        else:\n            self.permeability = complex(mu, 0)\n\n        # CHANGED: Create the isotropic material with both eps and mu\n        self.isotropic_material = Air(\n            permittivity=self.permittivity, permeability=self.permeability\n        )\n\n        # CHANGED: Get both tensors from the material\n        self.eps_tensor = self.isotropic_material.fetch_permittivity_tensor()\n        self.mu_tensor = self.isotropic_material.fetch_magnetic_tensor()\n\n        self.calculate_mode()\n        self.create()\n\n    def calculate_mode(self) -&gt; None:\n        \"\"\"Determine the calculation mode based on scenario type.\n\n        Sets the internal mode string used by the Wave class to determine\n        appropriate tensor shapes and broadcasting patterns.\n        \"\"\"\n        if self.scenario == \"Incident\":\n            self.mode = \"airgap\"\n        elif self.scenario == \"Azimuthal\":\n            self.mode = \"azimuthal_airgap\"\n        elif self.scenario == \"Dispersion\":\n            self.mode = \"simple_airgap\"\n        elif self.scenario == \"Simple\":\n            self.mode = \"simple_scalar_airgap\"\n\n    def create(self) -&gt; None:\n        \"\"\"Create the air gap layer transfer matrix and wave profile.\n\n        Constructs the transfer matrix by solving the wave equation for the\n        isotropic layer with specified thickness.\n        \"\"\"\n        self.profile, self.matrix = Wave(\n            self.kx,\n            self.eps_tensor,\n            self.mu_tensor,  # Now passing the actual magnetic tensor\n            self.mode,\n            k_0=self.k0,\n            thickness=self.thickness,\n        ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AirGapLayer.__init__","title":"<code>__init__(data, scenario, kx, k0)</code>","text":"<p>Initialize an isotropic middle-stack layer (air gap or dielectric).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'thickness', 'permittivity', and optionally 'permeability'</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber</p> required Note <p>Permittivity and permeability can be specified as scalars or as dictionaries with 'real' and 'imag' components.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; None:\n    \"\"\"Initialize an isotropic middle-stack layer (air gap or dielectric).\n\n    Args:\n        data: Dictionary with 'thickness', 'permittivity', and optionally 'permeability'\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber\n\n    Note:\n        Permittivity and permeability can be specified as scalars or as\n        dictionaries with 'real' and 'imag' components.\n    \"\"\"\n    super().__init__(data, scenario, kx, k0)\n\n    # Handle complex permittivity input\n    perm = data.get(\"permittivity\", 1.0)\n    if isinstance(perm, dict):\n        if \"real\" in perm or \"imag\" in perm:\n            self.permittivity = complex(perm.get(\"real\", 0), perm.get(\"imag\", 0))\n        else:\n            # Handle nested permittivity structure if present\n            self.permittivity = {\n                k: (complex(v.get(\"real\", 0), v.get(\"imag\", 0)) if isinstance(v, dict) else v)\n                for k, v in perm.items()\n            }\n    else:\n        self.permittivity = complex(perm, 0)\n\n    # CHANGED: Handle magnetic permeability input\n    mu = data.get(\"permeability\", 1.0)\n    if isinstance(mu, dict):\n        if \"real\" in mu or \"imag\" in mu:\n            self.permeability = complex(mu.get(\"real\", 0), mu.get(\"imag\", 0))\n        else:\n            # Handle nested permeability structure if present\n            self.permeability = {\n                k: (complex(v.get(\"real\", 0), v.get(\"imag\", 0)) if isinstance(v, dict) else v)\n                for k, v in mu.items()\n            }\n    else:\n        self.permeability = complex(mu, 0)\n\n    # CHANGED: Create the isotropic material with both eps and mu\n    self.isotropic_material = Air(\n        permittivity=self.permittivity, permeability=self.permeability\n    )\n\n    # CHANGED: Get both tensors from the material\n    self.eps_tensor = self.isotropic_material.fetch_permittivity_tensor()\n    self.mu_tensor = self.isotropic_material.fetch_magnetic_tensor()\n\n    self.calculate_mode()\n    self.create()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AirGapLayer.calculate_mode","title":"<code>calculate_mode()</code>","text":"<p>Determine the calculation mode based on scenario type.</p> <p>Sets the internal mode string used by the Wave class to determine appropriate tensor shapes and broadcasting patterns.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_mode(self) -&gt; None:\n    \"\"\"Determine the calculation mode based on scenario type.\n\n    Sets the internal mode string used by the Wave class to determine\n    appropriate tensor shapes and broadcasting patterns.\n    \"\"\"\n    if self.scenario == \"Incident\":\n        self.mode = \"airgap\"\n    elif self.scenario == \"Azimuthal\":\n        self.mode = \"azimuthal_airgap\"\n    elif self.scenario == \"Dispersion\":\n        self.mode = \"simple_airgap\"\n    elif self.scenario == \"Simple\":\n        self.mode = \"simple_scalar_airgap\"\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AirGapLayer.create","title":"<code>create()</code>","text":"<p>Create the air gap layer transfer matrix and wave profile.</p> <p>Constructs the transfer matrix by solving the wave equation for the isotropic layer with specified thickness.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"Create the air gap layer transfer matrix and wave profile.\n\n    Constructs the transfer matrix by solving the wave equation for the\n    isotropic layer with specified thickness.\n    \"\"\"\n    self.profile, self.matrix = Wave(\n        self.kx,\n        self.eps_tensor,\n        self.mu_tensor,  # Now passing the actual magnetic tensor\n        self.mode,\n        k_0=self.k0,\n        thickness=self.thickness,\n    ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium","title":"<code>AmbientExitMedium</code>","text":"<p>               Bases: <code>AmbientMedium</code></p> <p>Class representing the ambient exit medium. Moved from material_params.py to better organize layer-related functionality.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AmbientExitMedium(AmbientMedium):\n    \"\"\"\n    Class representing the ambient exit medium.\n    Moved from material_params.py to better organize layer-related functionality.\n    \"\"\"\n\n    def __init__(\n        self, incident_angle: float, permittivity_incident: float, permittivity_exit: float\n    ) -&gt; None:\n        \"\"\"Initialize the ambient exit medium.\n\n        Args:\n            incident_angle: Incident angle at the first interface in radians\n            permittivity_incident: Permittivity of the incident medium\n            permittivity_exit: Permittivity of the exit medium\n        \"\"\"\n        super().__init__()\n        self.theta_incident = incident_angle\n        self.N_exit = np.sqrt(permittivity_exit)\n        self.N_incident = np.sqrt(permittivity_incident)\n\n    def construct_tensor(self) -&gt; np.ndarray:\n        \"\"\"Construct the transfer matrix for the ambient exit medium.\n\n        Builds the 4\u00d74 transfer matrix for the semi-infinite exit layer,\n        accounting for refraction at the final interface.\n\n        Returns:\n            Transfer matrix accounting for transmitted waves only\n\n        Note:\n            The exit medium has no reflected waves (semi-infinite), so only\n            forward-propagating modes are included.\n        \"\"\"\n\n        sin_theta_incident = np.sin(self.theta_incident)\n        expr_inside_sqrt = 1.0 - ((self.N_incident / self.N_exit) * sin_theta_incident) ** 2.0\n        expr_inside_sqrt_complex = expr_inside_sqrt.astype(np.complex128)\n        cos_theta_f = np.sqrt(expr_inside_sqrt_complex)\n        N_exit = self.N_exit.astype(np.complex128)\n        Nf_cos_theta_f = N_exit * cos_theta_f\n\n        element1 = np.stack(\n            [\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n                cos_theta_f,\n                -cos_theta_f,\n            ],\n            axis=-1,\n        )\n\n        element2 = np.stack(\n            [\n                np.ones_like(cos_theta_f),\n                np.ones_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n            ],\n            axis=-1,\n        )\n\n        element3 = np.stack(\n            [\n                -Nf_cos_theta_f,\n                Nf_cos_theta_f,\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n            ],\n            axis=-1,\n        )\n\n        element4 = np.stack(\n            [\n                np.zeros_like(cos_theta_f),\n                np.zeros_like(cos_theta_f),\n                N_exit * np.ones_like(cos_theta_f),\n                N_exit * np.ones_like(cos_theta_f),\n            ],\n            axis=-1,\n        )\n\n        matrix = np.stack([element1, element2, element3, element4], axis=1)\n        return matrix.astype(np.complex128)\n\n    def construct_tensor_singular(self) -&gt; np.ndarray:\n        \"\"\"Construct transfer matrix for single-point exit medium.\n\n        Returns:\n            Transfer matrix with shape [4, 4] for scalar case\n        \"\"\"\n        sin_theta_incident = np.sin(self.theta_incident)\n        expr_inside_sqrt = 1.0 - ((self.N_incident / self.N_exit) * sin_theta_incident) ** 2.0\n        expr_inside_sqrt_complex = np.complex128(expr_inside_sqrt)\n        cos_theta_f = np.sqrt(expr_inside_sqrt_complex)\n        N_exit = np.complex128(self.N_exit)\n        Nf_cos_theta_f = N_exit * cos_theta_f\n\n        element1 = np.array([0.0, 0.0, cos_theta_f, -cos_theta_f])\n        element2 = np.array([1.0, 1.0, 0.0, 0.0])\n        element3 = np.array([-Nf_cos_theta_f, Nf_cos_theta_f, 0.0, 0.0])\n        element4 = np.array([0.0, 0.0, N_exit, N_exit])\n\n        matrix = np.stack([element1, element2, element3, element4], axis=0)\n        return matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium.__init__","title":"<code>__init__(incident_angle, permittivity_incident, permittivity_exit)</code>","text":"<p>Initialize the ambient exit medium.</p> <p>Parameters:</p> Name Type Description Default <code>incident_angle</code> <code>float</code> <p>Incident angle at the first interface in radians</p> required <code>permittivity_incident</code> <code>float</code> <p>Permittivity of the incident medium</p> required <code>permittivity_exit</code> <code>float</code> <p>Permittivity of the exit medium</p> required Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, incident_angle: float, permittivity_incident: float, permittivity_exit: float\n) -&gt; None:\n    \"\"\"Initialize the ambient exit medium.\n\n    Args:\n        incident_angle: Incident angle at the first interface in radians\n        permittivity_incident: Permittivity of the incident medium\n        permittivity_exit: Permittivity of the exit medium\n    \"\"\"\n    super().__init__()\n    self.theta_incident = incident_angle\n    self.N_exit = np.sqrt(permittivity_exit)\n    self.N_incident = np.sqrt(permittivity_incident)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium.construct_tensor","title":"<code>construct_tensor()</code>","text":"<p>Construct the transfer matrix for the ambient exit medium.</p> <p>Builds the 4\u00d74 transfer matrix for the semi-infinite exit layer, accounting for refraction at the final interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transfer matrix accounting for transmitted waves only</p> Note <p>The exit medium has no reflected waves (semi-infinite), so only forward-propagating modes are included.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor(self) -&gt; np.ndarray:\n    \"\"\"Construct the transfer matrix for the ambient exit medium.\n\n    Builds the 4\u00d74 transfer matrix for the semi-infinite exit layer,\n    accounting for refraction at the final interface.\n\n    Returns:\n        Transfer matrix accounting for transmitted waves only\n\n    Note:\n        The exit medium has no reflected waves (semi-infinite), so only\n        forward-propagating modes are included.\n    \"\"\"\n\n    sin_theta_incident = np.sin(self.theta_incident)\n    expr_inside_sqrt = 1.0 - ((self.N_incident / self.N_exit) * sin_theta_incident) ** 2.0\n    expr_inside_sqrt_complex = expr_inside_sqrt.astype(np.complex128)\n    cos_theta_f = np.sqrt(expr_inside_sqrt_complex)\n    N_exit = self.N_exit.astype(np.complex128)\n    Nf_cos_theta_f = N_exit * cos_theta_f\n\n    element1 = np.stack(\n        [\n            np.zeros_like(cos_theta_f),\n            np.zeros_like(cos_theta_f),\n            cos_theta_f,\n            -cos_theta_f,\n        ],\n        axis=-1,\n    )\n\n    element2 = np.stack(\n        [\n            np.ones_like(cos_theta_f),\n            np.ones_like(cos_theta_f),\n            np.zeros_like(cos_theta_f),\n            np.zeros_like(cos_theta_f),\n        ],\n        axis=-1,\n    )\n\n    element3 = np.stack(\n        [\n            -Nf_cos_theta_f,\n            Nf_cos_theta_f,\n            np.zeros_like(cos_theta_f),\n            np.zeros_like(cos_theta_f),\n        ],\n        axis=-1,\n    )\n\n    element4 = np.stack(\n        [\n            np.zeros_like(cos_theta_f),\n            np.zeros_like(cos_theta_f),\n            N_exit * np.ones_like(cos_theta_f),\n            N_exit * np.ones_like(cos_theta_f),\n        ],\n        axis=-1,\n    )\n\n    matrix = np.stack([element1, element2, element3, element4], axis=1)\n    return matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientExitMedium.construct_tensor_singular","title":"<code>construct_tensor_singular()</code>","text":"<p>Construct transfer matrix for single-point exit medium.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transfer matrix with shape [4, 4] for scalar case</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor_singular(self) -&gt; np.ndarray:\n    \"\"\"Construct transfer matrix for single-point exit medium.\n\n    Returns:\n        Transfer matrix with shape [4, 4] for scalar case\n    \"\"\"\n    sin_theta_incident = np.sin(self.theta_incident)\n    expr_inside_sqrt = 1.0 - ((self.N_incident / self.N_exit) * sin_theta_incident) ** 2.0\n    expr_inside_sqrt_complex = np.complex128(expr_inside_sqrt)\n    cos_theta_f = np.sqrt(expr_inside_sqrt_complex)\n    N_exit = np.complex128(self.N_exit)\n    Nf_cos_theta_f = N_exit * cos_theta_f\n\n    element1 = np.array([0.0, 0.0, cos_theta_f, -cos_theta_f])\n    element2 = np.array([1.0, 1.0, 0.0, 0.0])\n    element3 = np.array([-Nf_cos_theta_f, Nf_cos_theta_f, 0.0, 0.0])\n    element4 = np.array([0.0, 0.0, N_exit, N_exit])\n\n    matrix = np.stack([element1, element2, element3, element4], axis=0)\n    return matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium","title":"<code>AmbientIncidentMedium</code>","text":"<p>               Bases: <code>AmbientMedium</code></p> <p>Class representing the ambient incident medium. Moved from material_params.py to better organize layer-related functionality.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AmbientIncidentMedium(AmbientMedium):\n    \"\"\"\n    Class representing the ambient incident medium.\n    Moved from material_params.py to better organize layer-related functionality.\n    \"\"\"\n\n    def __init__(self, permittivity: float, kx: np.ndarray) -&gt; None:\n        \"\"\"Initialize the ambient incident medium (prism).\n\n        Args:\n            permittivity: Relative permittivity of the incident medium\n            kx: x-component of the wavevector (parallel to interface)\n        \"\"\"\n        super().__init__()\n        self.permittivity = permittivity\n        self.theta = np.arcsin(kx / np.sqrt(permittivity)).astype(np.float64)\n\n    def construct_tensor(self) -&gt; np.ndarray:\n        \"\"\"Construct the transfer matrix for the ambient incident medium.\n\n        Builds the 4\u00d74 transfer matrix relating incident and reflected field\n        components in the incident medium. The matrix accounts for both s and p\n        polarizations.\n\n        Returns:\n            Transfer matrix with shape [180, 4, 4] for incident scenario or\n            [1, 1, 4, 4] for azimuthal scenario\n\n        Note:\n            This implements the boundary condition matrix for a semi-infinite\n            incident medium (prism) as described in the 4\u00d74 formalism.\n        \"\"\"\n\n        n = np.sqrt(self.permittivity)\n        cos_theta = np.cos(self.theta)\n        n_cos_theta = n * cos_theta\n\n        # Combine updates into a single tensor with shape [180, 4, 4]\n        element1 = np.stack(\n            [\n                np.zeros_like(self.theta),\n                np.ones_like(self.theta),\n                -1.0 / n_cos_theta,\n                np.zeros_like(self.theta),\n            ],\n            axis=-1,\n        )\n        element2 = np.stack(\n            [\n                np.zeros_like(self.theta),\n                np.ones_like(self.theta),\n                1.0 / n_cos_theta,\n                np.zeros_like(self.theta),\n            ],\n            axis=-1,\n        )\n        element3 = np.stack(\n            [\n                1.0 / cos_theta,\n                np.zeros_like(self.theta),\n                np.zeros_like(self.theta),\n                1.0 / n * np.ones_like(self.theta),\n            ],\n            axis=-1,\n        )\n        element4 = np.stack(\n            [\n                -1.0 / cos_theta,\n                np.zeros_like(self.theta),\n                np.zeros_like(self.theta),\n                1.0 / n * np.ones_like(self.theta),\n            ],\n            axis=-1,\n        )\n\n        matrix = np.stack([element1, element2, element3, element4], axis=1)\n        return 0.5 * matrix.astype(np.complex128)\n\n    def construct_tensor_singular(self) -&gt; np.ndarray:\n        \"\"\"Construct transfer matrix for single-point (simple) scenarios.\n\n        Returns:\n            Transfer matrix with shape [4, 4] for scalar incident angle\n\n        Note:\n            This is a specialized version of construct_tensor for cases where\n            only a single incident angle is calculated.\n        \"\"\"\n\n        n = np.sqrt(self.permittivity)\n        cos_theta = np.cos(self.theta)\n        n_cos_theta = n * cos_theta\n\n        element1 = np.stack([0.0, 1.0, -1.0 / n_cos_theta, 0.0])\n        element2 = np.stack([0.0, 1.0, 1.0 / n_cos_theta, 0.0])\n        element3 = np.stack([1.0 / cos_theta, 0.0, 0.0, 1.0 / n])\n        element4 = np.stack([-1.0 / cos_theta, 0.0, 0.0, 1.0 / n])\n\n        matrix = np.stack([element1, element2, element3, element4], axis=0)\n        return 0.5 * matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium.__init__","title":"<code>__init__(permittivity, kx)</code>","text":"<p>Initialize the ambient incident medium (prism).</p> <p>Parameters:</p> Name Type Description Default <code>permittivity</code> <code>float</code> <p>Relative permittivity of the incident medium</p> required <code>kx</code> <code>ndarray</code> <p>x-component of the wavevector (parallel to interface)</p> required Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(self, permittivity: float, kx: np.ndarray) -&gt; None:\n    \"\"\"Initialize the ambient incident medium (prism).\n\n    Args:\n        permittivity: Relative permittivity of the incident medium\n        kx: x-component of the wavevector (parallel to interface)\n    \"\"\"\n    super().__init__()\n    self.permittivity = permittivity\n    self.theta = np.arcsin(kx / np.sqrt(permittivity)).astype(np.float64)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium.construct_tensor","title":"<code>construct_tensor()</code>","text":"<p>Construct the transfer matrix for the ambient incident medium.</p> <p>Builds the 4\u00d74 transfer matrix relating incident and reflected field components in the incident medium. The matrix accounts for both s and p polarizations.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transfer matrix with shape [180, 4, 4] for incident scenario or</p> <code>ndarray</code> <p>[1, 1, 4, 4] for azimuthal scenario</p> Note <p>This implements the boundary condition matrix for a semi-infinite incident medium (prism) as described in the 4\u00d74 formalism.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor(self) -&gt; np.ndarray:\n    \"\"\"Construct the transfer matrix for the ambient incident medium.\n\n    Builds the 4\u00d74 transfer matrix relating incident and reflected field\n    components in the incident medium. The matrix accounts for both s and p\n    polarizations.\n\n    Returns:\n        Transfer matrix with shape [180, 4, 4] for incident scenario or\n        [1, 1, 4, 4] for azimuthal scenario\n\n    Note:\n        This implements the boundary condition matrix for a semi-infinite\n        incident medium (prism) as described in the 4\u00d74 formalism.\n    \"\"\"\n\n    n = np.sqrt(self.permittivity)\n    cos_theta = np.cos(self.theta)\n    n_cos_theta = n * cos_theta\n\n    # Combine updates into a single tensor with shape [180, 4, 4]\n    element1 = np.stack(\n        [\n            np.zeros_like(self.theta),\n            np.ones_like(self.theta),\n            -1.0 / n_cos_theta,\n            np.zeros_like(self.theta),\n        ],\n        axis=-1,\n    )\n    element2 = np.stack(\n        [\n            np.zeros_like(self.theta),\n            np.ones_like(self.theta),\n            1.0 / n_cos_theta,\n            np.zeros_like(self.theta),\n        ],\n        axis=-1,\n    )\n    element3 = np.stack(\n        [\n            1.0 / cos_theta,\n            np.zeros_like(self.theta),\n            np.zeros_like(self.theta),\n            1.0 / n * np.ones_like(self.theta),\n        ],\n        axis=-1,\n    )\n    element4 = np.stack(\n        [\n            -1.0 / cos_theta,\n            np.zeros_like(self.theta),\n            np.zeros_like(self.theta),\n            1.0 / n * np.ones_like(self.theta),\n        ],\n        axis=-1,\n    )\n\n    matrix = np.stack([element1, element2, element3, element4], axis=1)\n    return 0.5 * matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientIncidentMedium.construct_tensor_singular","title":"<code>construct_tensor_singular()</code>","text":"<p>Construct transfer matrix for single-point (simple) scenarios.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transfer matrix with shape [4, 4] for scalar incident angle</p> Note <p>This is a specialized version of construct_tensor for cases where only a single incident angle is calculated.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def construct_tensor_singular(self) -&gt; np.ndarray:\n    \"\"\"Construct transfer matrix for single-point (simple) scenarios.\n\n    Returns:\n        Transfer matrix with shape [4, 4] for scalar incident angle\n\n    Note:\n        This is a specialized version of construct_tensor for cases where\n        only a single incident angle is calculated.\n    \"\"\"\n\n    n = np.sqrt(self.permittivity)\n    cos_theta = np.cos(self.theta)\n    n_cos_theta = n * cos_theta\n\n    element1 = np.stack([0.0, 1.0, -1.0 / n_cos_theta, 0.0])\n    element2 = np.stack([0.0, 1.0, 1.0 / n_cos_theta, 0.0])\n    element3 = np.stack([1.0 / cos_theta, 0.0, 0.0, 1.0 / n])\n    element4 = np.stack([-1.0 / cos_theta, 0.0, 0.0, 1.0 / n])\n\n    matrix = np.stack([element1, element2, element3, element4], axis=0)\n    return 0.5 * matrix.astype(np.complex128)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientMedium","title":"<code>AmbientMedium</code>","text":"<p>Base class for ambient mediums (incident and exit).</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class AmbientMedium:\n    \"\"\"Base class for ambient mediums (incident and exit).\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the ambient medium.\"\"\"\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.AmbientMedium.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the ambient medium.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the ambient medium.\"\"\"\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.CrystalLayer","title":"<code>CrystalLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Anisotropic crystal of arbitrary orientation and thickness.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class CrystalLayer(Layer):\n    \"\"\"Anisotropic crystal of arbitrary orientation and thickness.\"\"\"\n\n    def __init__(\n        self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; None:\n        \"\"\"Initialize an anisotropic crystal layer with finite thickness.\n\n        Args:\n            data: Dictionary with 'material', 'thickness', and rotation angles\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber\n\n        Note:\n            The crystal can be rotated using rotationX, rotationY, and rotationZ\n            Euler angles specified in degrees.\n        \"\"\"\n        super().__init__(data, scenario, kx, k0)\n        self.calculate_tensors()  # Get both eps and mu tensors\n        self.calculate_z_rotation()\n        self.rotate_tensors()  # Rotate both tensors\n        self.create()\n\n    def create(self) -&gt; None:\n        \"\"\"Create the crystal layer transfer matrix and wave profile.\n\n        Solves for the wave modes in the anisotropic layer and constructs the\n        transfer matrix accounting for phase accumulation through the layer.\n        \"\"\"\n        self.profile, self.matrix = Wave(\n            self.kx,\n            self.eps_tensor,\n            self.mu_tensor,  # Now using the actual magnetic tensor from material\n            self.scenario,\n            k_0=self.k0,\n            thickness=self.thickness,\n        ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.CrystalLayer.__init__","title":"<code>__init__(data, scenario, kx, k0)</code>","text":"<p>Initialize an anisotropic crystal layer with finite thickness.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'material', 'thickness', and rotation angles</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber</p> required Note <p>The crystal can be rotated using rotationX, rotationY, and rotationZ Euler angles specified in degrees.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; None:\n    \"\"\"Initialize an anisotropic crystal layer with finite thickness.\n\n    Args:\n        data: Dictionary with 'material', 'thickness', and rotation angles\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber\n\n    Note:\n        The crystal can be rotated using rotationX, rotationY, and rotationZ\n        Euler angles specified in degrees.\n    \"\"\"\n    super().__init__(data, scenario, kx, k0)\n    self.calculate_tensors()  # Get both eps and mu tensors\n    self.calculate_z_rotation()\n    self.rotate_tensors()  # Rotate both tensors\n    self.create()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.CrystalLayer.create","title":"<code>create()</code>","text":"<p>Create the crystal layer transfer matrix and wave profile.</p> <p>Solves for the wave modes in the anisotropic layer and constructs the transfer matrix accounting for phase accumulation through the layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"Create the crystal layer transfer matrix and wave profile.\n\n    Solves for the wave modes in the anisotropic layer and constructs the\n    transfer matrix accounting for phase accumulation through the layer.\n    \"\"\"\n    self.profile, self.matrix = Wave(\n        self.kx,\n        self.eps_tensor,\n        self.mu_tensor,  # Now using the actual magnetic tensor from material\n        self.scenario,\n        k_0=self.k0,\n        thickness=self.thickness,\n    ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.IsotropicSemiInfiniteLayer","title":"<code>IsotropicSemiInfiniteLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Isotropic semi-infinite layer with a given permittivity.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class IsotropicSemiInfiniteLayer(Layer):\n    \"\"\"Isotropic semi-infinite layer with a given permittivity.\"\"\"\n\n    def __init__(\n        self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; None:\n        \"\"\"Initialize a semi-infinite isotropic exit layer.\n\n        Args:\n            data: Dictionary with 'permittivity' for exit medium\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber\n\n        Raises:\n            ValueError: If exit permittivity is not provided\n        \"\"\"\n        super().__init__(data, scenario, kx, k0)\n        self.eps_incident = (kx.astype(np.float64) / np.sin(self.incident_angle)) ** 2\n        self.eps_exit = np.float64(data.get(\"permittivity\"))\n\n        if self.eps_exit is None:\n            raise ValueError(\"No exit permittivity provided for isotropic semi-infinite layer\")\n\n        self.create()\n\n    def create(self) -&gt; None:\n        \"\"\"Create the isotropic exit layer transfer matrix.\n\n        Constructs the transfer matrix for the semi-infinite isotropic exit\n        medium, accounting for refraction at the final interface.\n        \"\"\"\n        exit_medium = AmbientExitMedium(self.incident_angle, self.eps_incident, self.eps_exit)\n\n        if self.scenario == \"Incident\":\n            self.matrix = exit_medium.construct_tensor()\n        elif self.scenario == \"Azimuthal\":\n            self.matrix = exit_medium.construct_tensor()[np.newaxis, np.newaxis, ...]\n        elif self.scenario == \"Dispersion\":\n            self.matrix = exit_medium.construct_tensor()[:, np.newaxis, ...]\n        elif self.scenario == \"Simple\":\n            # For simple scenario, just get the scalar tensor without additional dimensions\n            self.matrix = exit_medium.construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.IsotropicSemiInfiniteLayer.__init__","title":"<code>__init__(data, scenario, kx, k0)</code>","text":"<p>Initialize a semi-infinite isotropic exit layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'permittivity' for exit medium</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If exit permittivity is not provided</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; None:\n    \"\"\"Initialize a semi-infinite isotropic exit layer.\n\n    Args:\n        data: Dictionary with 'permittivity' for exit medium\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber\n\n    Raises:\n        ValueError: If exit permittivity is not provided\n    \"\"\"\n    super().__init__(data, scenario, kx, k0)\n    self.eps_incident = (kx.astype(np.float64) / np.sin(self.incident_angle)) ** 2\n    self.eps_exit = np.float64(data.get(\"permittivity\"))\n\n    if self.eps_exit is None:\n        raise ValueError(\"No exit permittivity provided for isotropic semi-infinite layer\")\n\n    self.create()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.IsotropicSemiInfiniteLayer.create","title":"<code>create()</code>","text":"<p>Create the isotropic exit layer transfer matrix.</p> <p>Constructs the transfer matrix for the semi-infinite isotropic exit medium, accounting for refraction at the final interface.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"Create the isotropic exit layer transfer matrix.\n\n    Constructs the transfer matrix for the semi-infinite isotropic exit\n    medium, accounting for refraction at the final interface.\n    \"\"\"\n    exit_medium = AmbientExitMedium(self.incident_angle, self.eps_incident, self.eps_exit)\n\n    if self.scenario == \"Incident\":\n        self.matrix = exit_medium.construct_tensor()\n    elif self.scenario == \"Azimuthal\":\n        self.matrix = exit_medium.construct_tensor()[np.newaxis, np.newaxis, ...]\n    elif self.scenario == \"Dispersion\":\n        self.matrix = exit_medium.construct_tensor()[:, np.newaxis, ...]\n    elif self.scenario == \"Simple\":\n        # For simple scenario, just get the scalar tensor without additional dimensions\n        self.matrix = exit_medium.construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer","title":"<code>Layer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for a layer in the device.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class Layer(ABC):\n    \"\"\"Abstract base class for a layer in the device.\"\"\"\n\n    def __init__(\n        self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; None:\n        \"\"\"Initialize a generic layer.\n\n        Args:\n            data: Dictionary containing layer parameters (type, material, rotations, etc.)\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber (2\u03c0/\u03bb)\n\n        Note:\n            This is an abstract base class. Use specific layer types like\n            PrismLayer, AirGapLayer, or CrystalLayer instead.\n        \"\"\"\n        self.type = data.get(\"type\")\n        self.material = data.get(\"material\", None)\n        self.rotationX = np.float64(m.radians(data.get(\"rotationX\", 0)))\n        self.rotationY = np.float64(m.radians(data.get(\"rotationY\", 0))) + 1e-8\n        self.rotationZ = np.float64(m.radians(data.get(\"rotationZ\", 0))) + 1.0e-9\n        self.rotationZ_type = data.get(\"rotationZType\", \"relative\")\n        self.kx = kx\n        self.k0 = k0\n        self.frequency = scenario.frequency\n        self.scenario = scenario.type\n        self.incident_angle = scenario.incident_angle\n        self.azimuthal_angle = scenario.azimuthal_angle\n\n        # CHANGED: Remove the default non_magnetic_tensor assignment\n        # We'll get both tensors from materials now\n        self.eps_tensor = None\n        self.mu_tensor = None\n\n        self.thickness = data.get(\"thickness\", None)\n        if self.thickness:\n            self.thickness = float(self.thickness) * 1e-4\n\n    def material_factory(self) -&gt; None:\n        \"\"\"Create the material object based on material name or specifications.\n\n        Instantiates the appropriate material class (Quartz, Calcite, etc.) or\n        creates an ArbitraryMaterial from custom parameters.\n\n        Raises:\n            NotImplementedError: If the material name is not recognized\n\n        Note:\n            For arbitrary materials, expects a dictionary with permittivity\n            and optionally permeability tensor components.\n        \"\"\"\n        if isinstance(self.material, dict):\n            # Create an ArbitraryMaterial instance instead of returning the dict\n            self.material = ArbitraryMaterial(self.material)\n        elif self.material == \"Quartz\":\n            self.material = Quartz()\n        elif self.material == \"Sapphire\":\n            self.material = Sapphire()\n        elif self.material == \"Calcite\":\n            self.material = CalciteUpper()\n        elif self.material == \"CalciteLower\":\n            self.material = CalciteLower()\n        elif self.material == \"GalliumOxide\":\n            self.material = GalliumOxide()\n        else:\n            raise NotImplementedError(f\"Material {self.material} not implemented\")\n\n    def calculate_z_rotation(self) -&gt; None:\n        \"\"\"Calculate the z-axis rotation based on scenario type and rotation mode.\n\n        Determines whether the z-rotation is relative to the azimuthal angle or\n        static (fixed in space). For dispersion and azimuthal scenarios, adds\n        the azimuthal angle to relative rotations.\n\n        Note:\n            The rotationZType attribute controls whether rotation is 'relative'\n            (rotates with sample) or 'static' (fixed in lab frame).\n        \"\"\"\n        if self.scenario in [\"Dispersion\", \"Azimuthal\", \"Simple\"]:\n            if self.rotationZ_type == \"relative\":\n                self.rotationZ = self.azimuthal_angle + self.rotationZ\n            elif self.rotationZ_type == \"static\":\n                if self.scenario == \"Simple\":\n                    # For simple scenario, keep as scalar\n                    self.rotationZ = self.rotationZ\n                else:\n                    self.rotationZ = self.rotationZ * np.ones_like(self.azimuthal_angle)\n\n    def calculate_tensors(self) -&gt; None:\n        \"\"\"Calculate both permittivity and permeability tensors for the layer.\n\n        Fetches the material's permittivity (\u03b5) and permeability (\u03bc) tensors\n        for the appropriate frequency or frequency range based on scenario type.\n\n        Note:\n            For Incident/Azimuthal scenarios, tensors span the full frequency\n            range. For Dispersion/Simple scenarios, tensors are calculated for\n            a single frequency.\n        \"\"\"\n        self.material_factory()\n\n        if self.scenario in [\"Incident\", \"Azimuthal\"]:\n            self.eps_tensor = self.material.fetch_permittivity_tensor().astype(np.complex128)\n            self.mu_tensor = self.material.fetch_magnetic_tensor().astype(np.complex128)\n        elif self.scenario in [\"Dispersion\", \"Simple\"]:\n            self.eps_tensor = self.material.fetch_permittivity_tensor_for_freq(\n                self.frequency\n            ).astype(np.complex128)\n            self.mu_tensor = self.material.fetch_magnetic_tensor_for_freq(self.frequency).astype(\n                np.complex128\n            )\n\n    def rotate_tensors(self) -&gt; None:\n        \"\"\"Apply Euler angle rotations to permittivity and permeability tensors.\n\n        Rotates both \u03b5 and \u03bc tensors according to the specified Euler angles\n        (rotationX, rotationY, rotationZ) to account for crystal orientation.\n\n        Note:\n            The rotation function used depends on the scenario type to handle\n            proper broadcasting across angle arrays.\n        \"\"\"\n        if self.scenario in [\"Incident\", \"Dispersion\"]:\n            rotation_func = anisotropy_rotation_one_value\n        elif self.scenario == \"Azimuthal\":\n            rotation_func = anisotropy_rotation_one_axis\n        elif self.scenario == \"Simple\":\n            rotation_func = anisotropy_rotation_one_value\n\n        self.eps_tensor = rotation_func(\n            self.eps_tensor, self.rotationX, self.rotationY, self.rotationZ\n        )\n        self.mu_tensor = rotation_func(\n            self.mu_tensor, self.rotationX, self.rotationY, self.rotationZ\n        )\n\n    @abstractmethod\n    def create(self) -&gt; None:\n        \"\"\"Create the layer's transfer matrix and wave profile.\n\n        This method must be implemented by concrete layer classes to construct\n        the layer-specific transfer matrix.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.__init__","title":"<code>__init__(data, scenario, kx, k0)</code>","text":"<p>Initialize a generic layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing layer parameters (type, material, rotations, etc.)</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber (2\u03c0/\u03bb)</p> required Note <p>This is an abstract base class. Use specific layer types like PrismLayer, AirGapLayer, or CrystalLayer instead.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; None:\n    \"\"\"Initialize a generic layer.\n\n    Args:\n        data: Dictionary containing layer parameters (type, material, rotations, etc.)\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber (2\u03c0/\u03bb)\n\n    Note:\n        This is an abstract base class. Use specific layer types like\n        PrismLayer, AirGapLayer, or CrystalLayer instead.\n    \"\"\"\n    self.type = data.get(\"type\")\n    self.material = data.get(\"material\", None)\n    self.rotationX = np.float64(m.radians(data.get(\"rotationX\", 0)))\n    self.rotationY = np.float64(m.radians(data.get(\"rotationY\", 0))) + 1e-8\n    self.rotationZ = np.float64(m.radians(data.get(\"rotationZ\", 0))) + 1.0e-9\n    self.rotationZ_type = data.get(\"rotationZType\", \"relative\")\n    self.kx = kx\n    self.k0 = k0\n    self.frequency = scenario.frequency\n    self.scenario = scenario.type\n    self.incident_angle = scenario.incident_angle\n    self.azimuthal_angle = scenario.azimuthal_angle\n\n    # CHANGED: Remove the default non_magnetic_tensor assignment\n    # We'll get both tensors from materials now\n    self.eps_tensor = None\n    self.mu_tensor = None\n\n    self.thickness = data.get(\"thickness\", None)\n    if self.thickness:\n        self.thickness = float(self.thickness) * 1e-4\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.calculate_tensors","title":"<code>calculate_tensors()</code>","text":"<p>Calculate both permittivity and permeability tensors for the layer.</p> <p>Fetches the material's permittivity (\u03b5) and permeability (\u03bc) tensors for the appropriate frequency or frequency range based on scenario type.</p> Note <p>For Incident/Azimuthal scenarios, tensors span the full frequency range. For Dispersion/Simple scenarios, tensors are calculated for a single frequency.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_tensors(self) -&gt; None:\n    \"\"\"Calculate both permittivity and permeability tensors for the layer.\n\n    Fetches the material's permittivity (\u03b5) and permeability (\u03bc) tensors\n    for the appropriate frequency or frequency range based on scenario type.\n\n    Note:\n        For Incident/Azimuthal scenarios, tensors span the full frequency\n        range. For Dispersion/Simple scenarios, tensors are calculated for\n        a single frequency.\n    \"\"\"\n    self.material_factory()\n\n    if self.scenario in [\"Incident\", \"Azimuthal\"]:\n        self.eps_tensor = self.material.fetch_permittivity_tensor().astype(np.complex128)\n        self.mu_tensor = self.material.fetch_magnetic_tensor().astype(np.complex128)\n    elif self.scenario in [\"Dispersion\", \"Simple\"]:\n        self.eps_tensor = self.material.fetch_permittivity_tensor_for_freq(\n            self.frequency\n        ).astype(np.complex128)\n        self.mu_tensor = self.material.fetch_magnetic_tensor_for_freq(self.frequency).astype(\n            np.complex128\n        )\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.calculate_z_rotation","title":"<code>calculate_z_rotation()</code>","text":"<p>Calculate the z-axis rotation based on scenario type and rotation mode.</p> <p>Determines whether the z-rotation is relative to the azimuthal angle or static (fixed in space). For dispersion and azimuthal scenarios, adds the azimuthal angle to relative rotations.</p> Note <p>The rotationZType attribute controls whether rotation is 'relative' (rotates with sample) or 'static' (fixed in lab frame).</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def calculate_z_rotation(self) -&gt; None:\n    \"\"\"Calculate the z-axis rotation based on scenario type and rotation mode.\n\n    Determines whether the z-rotation is relative to the azimuthal angle or\n    static (fixed in space). For dispersion and azimuthal scenarios, adds\n    the azimuthal angle to relative rotations.\n\n    Note:\n        The rotationZType attribute controls whether rotation is 'relative'\n        (rotates with sample) or 'static' (fixed in lab frame).\n    \"\"\"\n    if self.scenario in [\"Dispersion\", \"Azimuthal\", \"Simple\"]:\n        if self.rotationZ_type == \"relative\":\n            self.rotationZ = self.azimuthal_angle + self.rotationZ\n        elif self.rotationZ_type == \"static\":\n            if self.scenario == \"Simple\":\n                # For simple scenario, keep as scalar\n                self.rotationZ = self.rotationZ\n            else:\n                self.rotationZ = self.rotationZ * np.ones_like(self.azimuthal_angle)\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.create","title":"<code>create()</code>  <code>abstractmethod</code>","text":"<p>Create the layer's transfer matrix and wave profile.</p> <p>This method must be implemented by concrete layer classes to construct the layer-specific transfer matrix.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>@abstractmethod\ndef create(self) -&gt; None:\n    \"\"\"Create the layer's transfer matrix and wave profile.\n\n    This method must be implemented by concrete layer classes to construct\n    the layer-specific transfer matrix.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.material_factory","title":"<code>material_factory()</code>","text":"<p>Create the material object based on material name or specifications.</p> <p>Instantiates the appropriate material class (Quartz, Calcite, etc.) or creates an ArbitraryMaterial from custom parameters.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the material name is not recognized</p> Note <p>For arbitrary materials, expects a dictionary with permittivity and optionally permeability tensor components.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def material_factory(self) -&gt; None:\n    \"\"\"Create the material object based on material name or specifications.\n\n    Instantiates the appropriate material class (Quartz, Calcite, etc.) or\n    creates an ArbitraryMaterial from custom parameters.\n\n    Raises:\n        NotImplementedError: If the material name is not recognized\n\n    Note:\n        For arbitrary materials, expects a dictionary with permittivity\n        and optionally permeability tensor components.\n    \"\"\"\n    if isinstance(self.material, dict):\n        # Create an ArbitraryMaterial instance instead of returning the dict\n        self.material = ArbitraryMaterial(self.material)\n    elif self.material == \"Quartz\":\n        self.material = Quartz()\n    elif self.material == \"Sapphire\":\n        self.material = Sapphire()\n    elif self.material == \"Calcite\":\n        self.material = CalciteUpper()\n    elif self.material == \"CalciteLower\":\n        self.material = CalciteLower()\n    elif self.material == \"GalliumOxide\":\n        self.material = GalliumOxide()\n    else:\n        raise NotImplementedError(f\"Material {self.material} not implemented\")\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.Layer.rotate_tensors","title":"<code>rotate_tensors()</code>","text":"<p>Apply Euler angle rotations to permittivity and permeability tensors.</p> <p>Rotates both \u03b5 and \u03bc tensors according to the specified Euler angles (rotationX, rotationY, rotationZ) to account for crystal orientation.</p> Note <p>The rotation function used depends on the scenario type to handle proper broadcasting across angle arrays.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def rotate_tensors(self) -&gt; None:\n    \"\"\"Apply Euler angle rotations to permittivity and permeability tensors.\n\n    Rotates both \u03b5 and \u03bc tensors according to the specified Euler angles\n    (rotationX, rotationY, rotationZ) to account for crystal orientation.\n\n    Note:\n        The rotation function used depends on the scenario type to handle\n        proper broadcasting across angle arrays.\n    \"\"\"\n    if self.scenario in [\"Incident\", \"Dispersion\"]:\n        rotation_func = anisotropy_rotation_one_value\n    elif self.scenario == \"Azimuthal\":\n        rotation_func = anisotropy_rotation_one_axis\n    elif self.scenario == \"Simple\":\n        rotation_func = anisotropy_rotation_one_value\n\n    self.eps_tensor = rotation_func(\n        self.eps_tensor, self.rotationX, self.rotationY, self.rotationZ\n    )\n    self.mu_tensor = rotation_func(\n        self.mu_tensor, self.rotationX, self.rotationY, self.rotationZ\n    )\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.LayerFactory","title":"<code>LayerFactory</code>","text":"<p>Factory class for creating layers.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class LayerFactory:\n    \"\"\"Factory class for creating layers.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the layer factory with available layer types.\n\n        Registers all available layer classes for creation based on type string.\n        \"\"\"\n        self.layer_classes = {\n            \"Ambient Incident Layer\": PrismLayer,\n            \"Isotropic Middle-Stack Layer\": AirGapLayer,\n            \"Crystal Layer\": CrystalLayer,\n            \"Semi Infinite Anisotropic Layer\": SemiInfiniteCrystalLayer,\n            \"Semi Infinite Isotropic Layer\": IsotropicSemiInfiniteLayer,\n        }\n\n    def create_layer(\n        self, layer_data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; Layer:\n        \"\"\"Create a layer instance from configuration data.\n\n        Args:\n            layer_data: Dictionary containing layer type and parameters\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber\n\n        Returns:\n            An instance of the appropriate Layer subclass\n\n        Raises:\n            ValueError: If layer type is not recognized\n\n        Example:\n            &gt;&gt;&gt; factory = LayerFactory()\n            &gt;&gt;&gt; layer_data = {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0}\n            &gt;&gt;&gt; layer = factory.create_layer(layer_data, scenario, kx, k0)\n        \"\"\"\n        layer_class = self.layer_classes.get(layer_data[\"type\"])\n        if layer_class is not None:\n            return layer_class(layer_data, scenario, kx, k0)\n        else:\n            raise ValueError(f\"Invalid layer type {layer_data['type']}\")\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.LayerFactory.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the layer factory with available layer types.</p> <p>Registers all available layer classes for creation based on type string.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the layer factory with available layer types.\n\n    Registers all available layer classes for creation based on type string.\n    \"\"\"\n    self.layer_classes = {\n        \"Ambient Incident Layer\": PrismLayer,\n        \"Isotropic Middle-Stack Layer\": AirGapLayer,\n        \"Crystal Layer\": CrystalLayer,\n        \"Semi Infinite Anisotropic Layer\": SemiInfiniteCrystalLayer,\n        \"Semi Infinite Isotropic Layer\": IsotropicSemiInfiniteLayer,\n    }\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.LayerFactory.create_layer","title":"<code>create_layer(layer_data, scenario, kx, k0)</code>","text":"<p>Create a layer instance from configuration data.</p> <p>Parameters:</p> Name Type Description Default <code>layer_data</code> <code>dict[str, Any]</code> <p>Dictionary containing layer type and parameters</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber</p> required <p>Returns:</p> Type Description <code>Layer</code> <p>An instance of the appropriate Layer subclass</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If layer type is not recognized</p> Example <p>factory = LayerFactory() layer_data = {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0} layer = factory.create_layer(layer_data, scenario, kx, k0)</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create_layer(\n    self, layer_data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; Layer:\n    \"\"\"Create a layer instance from configuration data.\n\n    Args:\n        layer_data: Dictionary containing layer type and parameters\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber\n\n    Returns:\n        An instance of the appropriate Layer subclass\n\n    Raises:\n        ValueError: If layer type is not recognized\n\n    Example:\n        &gt;&gt;&gt; factory = LayerFactory()\n        &gt;&gt;&gt; layer_data = {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0}\n        &gt;&gt;&gt; layer = factory.create_layer(layer_data, scenario, kx, k0)\n    \"\"\"\n    layer_class = self.layer_classes.get(layer_data[\"type\"])\n    if layer_class is not None:\n        return layer_class(layer_data, scenario, kx, k0)\n    else:\n        raise ValueError(f\"Invalid layer type {layer_data['type']}\")\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.PrismLayer","title":"<code>PrismLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>The incident coupling prism layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class PrismLayer(Layer):\n    \"\"\"The incident coupling prism layer.\"\"\"\n\n    def __init__(\n        self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; None:\n        \"\"\"Initialize the incident coupling prism layer.\n\n        Args:\n            data: Dictionary containing 'permittivity' key for prism permittivity\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber\n        \"\"\"\n        super().__init__(data, scenario, kx, k0)\n        self.eps_prism = np.float64(data.get(\"permittivity\", 5.5))\n        self.create()\n\n    def create(self) -&gt; None:\n        \"\"\"Create the prism transfer matrix.\n\n        Constructs the appropriate transfer matrix based on scenario type,\n        handling different array shapes for Simple, Incident, Azimuthal, and\n        Dispersion scenarios.\n        \"\"\"\n        prism = AmbientIncidentMedium(self.eps_prism, self.kx)\n\n        if self.scenario == \"Incident\":\n            self.matrix = prism.construct_tensor()\n        elif self.scenario == \"Azimuthal\":\n            self.matrix = prism.construct_tensor_singular()[np.newaxis, np.newaxis, ...]\n        elif self.scenario == \"Dispersion\":\n            self.matrix = prism.construct_tensor()[:, np.newaxis, ...]\n        elif self.scenario == \"Simple\":\n            self.matrix = prism.construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.PrismLayer.__init__","title":"<code>__init__(data, scenario, kx, k0)</code>","text":"<p>Initialize the incident coupling prism layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing 'permittivity' key for prism permittivity</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber</p> required Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; None:\n    \"\"\"Initialize the incident coupling prism layer.\n\n    Args:\n        data: Dictionary containing 'permittivity' key for prism permittivity\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber\n    \"\"\"\n    super().__init__(data, scenario, kx, k0)\n    self.eps_prism = np.float64(data.get(\"permittivity\", 5.5))\n    self.create()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.PrismLayer.create","title":"<code>create()</code>","text":"<p>Create the prism transfer matrix.</p> <p>Constructs the appropriate transfer matrix based on scenario type, handling different array shapes for Simple, Incident, Azimuthal, and Dispersion scenarios.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"Create the prism transfer matrix.\n\n    Constructs the appropriate transfer matrix based on scenario type,\n    handling different array shapes for Simple, Incident, Azimuthal, and\n    Dispersion scenarios.\n    \"\"\"\n    prism = AmbientIncidentMedium(self.eps_prism, self.kx)\n\n    if self.scenario == \"Incident\":\n        self.matrix = prism.construct_tensor()\n    elif self.scenario == \"Azimuthal\":\n        self.matrix = prism.construct_tensor_singular()[np.newaxis, np.newaxis, ...]\n    elif self.scenario == \"Dispersion\":\n        self.matrix = prism.construct_tensor()[:, np.newaxis, ...]\n    elif self.scenario == \"Simple\":\n        self.matrix = prism.construct_tensor_singular()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.SemiInfiniteCrystalLayer","title":"<code>SemiInfiniteCrystalLayer</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Anisotropic semi-infinite crystal layer.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>class SemiInfiniteCrystalLayer(Layer):\n    \"\"\"Anisotropic semi-infinite crystal layer.\"\"\"\n\n    def __init__(\n        self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n    ) -&gt; None:\n        \"\"\"Initialize a semi-infinite anisotropic crystal layer.\n\n        Args:\n            data: Dictionary with 'material' and rotation angles\n            scenario: The simulation scenario configuration\n            kx: x-component of wavevector\n            k0: Free-space wavenumber\n\n        Note:\n            Semi-infinite layers have no thickness parameter as they extend\n            infinitely in the +z direction. Only forward-propagating modes exist.\n        \"\"\"\n        super().__init__(data, scenario, kx, k0)\n        self.calculate_z_rotation()\n        # CHANGED: Use the new unified tensor calculation methods\n        self.calculate_tensors()  # Get both eps and mu tensors\n        self.rotate_tensors()  # Rotate both tensors\n        self.create()\n\n    def create(self) -&gt; None:\n        \"\"\"Create the semi-infinite crystal transfer matrix.\n\n        Constructs a transfer matrix that includes only the eigenvectors\n        without phase propagation (no thickness dependence).\n        \"\"\"\n        self.profile, self.matrix = Wave(\n            self.kx,\n            self.eps_tensor,\n            self.mu_tensor,  # Now using the actual magnetic tensor from material\n            self.scenario,\n            semi_infinite=True,\n        ).execute()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.SemiInfiniteCrystalLayer.__init__","title":"<code>__init__(data, scenario, kx, k0)</code>","text":"<p>Initialize a semi-infinite anisotropic crystal layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'material' and rotation angles</p> required <code>scenario</code> <code>ScenarioSetup</code> <p>The simulation scenario configuration</p> required <code>kx</code> <code>ndarray</code> <p>x-component of wavevector</p> required <code>k0</code> <code>ndarray</code> <p>Free-space wavenumber</p> required Note <p>Semi-infinite layers have no thickness parameter as they extend infinitely in the +z direction. Only forward-propagating modes exist.</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def __init__(\n    self, data: dict[str, Any], scenario: ScenarioSetup, kx: np.ndarray, k0: np.ndarray\n) -&gt; None:\n    \"\"\"Initialize a semi-infinite anisotropic crystal layer.\n\n    Args:\n        data: Dictionary with 'material' and rotation angles\n        scenario: The simulation scenario configuration\n        kx: x-component of wavevector\n        k0: Free-space wavenumber\n\n    Note:\n        Semi-infinite layers have no thickness parameter as they extend\n        infinitely in the +z direction. Only forward-propagating modes exist.\n    \"\"\"\n    super().__init__(data, scenario, kx, k0)\n    self.calculate_z_rotation()\n    # CHANGED: Use the new unified tensor calculation methods\n    self.calculate_tensors()  # Get both eps and mu tensors\n    self.rotate_tensors()  # Rotate both tensors\n    self.create()\n</code></pre>"},{"location":"api/layers/#hyperbolic_optics.layers.SemiInfiniteCrystalLayer.create","title":"<code>create()</code>","text":"<p>Create the semi-infinite crystal transfer matrix.</p> <p>Constructs a transfer matrix that includes only the eigenvectors without phase propagation (no thickness dependence).</p> Source code in <code>hyperbolic_optics/layers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"Create the semi-infinite crystal transfer matrix.\n\n    Constructs a transfer matrix that includes only the eigenvectors\n    without phase propagation (no thickness dependence).\n    \"\"\"\n    self.profile, self.matrix = Wave(\n        self.kx,\n        self.eps_tensor,\n        self.mu_tensor,  # Now using the actual magnetic tensor from material\n        self.scenario,\n        semi_infinite=True,\n    ).execute()\n</code></pre>"},{"location":"api/materials/","title":"Materials API","text":""},{"location":"api/materials/#hyperbolic_optics.materials","title":"<code>hyperbolic_optics.materials</code>","text":"<p>Material definitions and permittivity/permeability calculations.</p> <p>This module provides material classes for various crystal types:</p> <p>Uniaxial materials (single optical axis): - Quartz (\u03b1-SiO\u2082) - Sapphire (\u03b1-Al\u2082O\u2083) - Calcite (CaCO\u2083) - upper and lower reststrahlen bands</p> <p>Monoclinic materials (non-zero off-diagonal components): - Gallium Oxide (\u03b2-Ga\u2082O\u2083)</p> <p>Arbitrary materials: - User-defined permittivity and permeability tensors</p> <p>Isotropic materials: - Air/vacuum</p> <p>All materials implement frequency-dependent permittivity using Lorentz oscillator models with parameters loaded from material_params.json.</p>"},{"location":"api/materials/#hyperbolic_optics.materials.Air","title":"<code>Air</code>","text":"<p>               Bases: <code>IsotropicMaterial</code></p> <p>Air material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Air(IsotropicMaterial):\n    \"\"\"Air material implementation.\"\"\"\n\n    def __init__(\n        self,\n        permittivity: float | complex | dict[str, float] | None = None,\n        permeability: float | complex | dict[str, float] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize Air material (vacuum approximation).\n\n        Args:\n            permittivity: Relative permittivity (default: 1.0 from config)\n            permeability: Relative permeability (default: 1.0)\n\n        Note:\n            Air is treated as an isotropic, non-dispersive material with\n            \u03b5 \u2248 1.0 and \u03bc \u2248 1.0 across all frequencies.\n        \"\"\"\n        if permittivity is None:\n            params = load_material_parameters()[\"isotropic_materials\"][\"air\"]\n            permittivity = params[\"permittivity\"]\n\n        if permeability is None:\n            permeability = 1.0\n\n        super().__init__(permittivity=permittivity, permeability=permeability)\n        self.name = \"Air\"\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Air.__init__","title":"<code>__init__(permittivity=None, permeability=None)</code>","text":"<p>Initialize Air material (vacuum approximation).</p> <p>Parameters:</p> Name Type Description Default <code>permittivity</code> <code>float | complex | dict[str, float] | None</code> <p>Relative permittivity (default: 1.0 from config)</p> <code>None</code> <code>permeability</code> <code>float | complex | dict[str, float] | None</code> <p>Relative permeability (default: 1.0)</p> <code>None</code> Note <p>Air is treated as an isotropic, non-dispersive material with \u03b5 \u2248 1.0 and \u03bc \u2248 1.0 across all frequencies.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self,\n    permittivity: float | complex | dict[str, float] | None = None,\n    permeability: float | complex | dict[str, float] | None = None,\n) -&gt; None:\n    \"\"\"Initialize Air material (vacuum approximation).\n\n    Args:\n        permittivity: Relative permittivity (default: 1.0 from config)\n        permeability: Relative permeability (default: 1.0)\n\n    Note:\n        Air is treated as an isotropic, non-dispersive material with\n        \u03b5 \u2248 1.0 and \u03bc \u2248 1.0 across all frequencies.\n    \"\"\"\n    if permittivity is None:\n        params = load_material_parameters()[\"isotropic_materials\"][\"air\"]\n        permittivity = params[\"permittivity\"]\n\n    if permeability is None:\n        permeability = 1.0\n\n    super().__init__(permittivity=permittivity, permeability=permeability)\n    self.name = \"Air\"\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial","title":"<code>ArbitraryMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Material with arbitrary permittivity and permeability tensor components.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class ArbitraryMaterial(BaseMaterial):\n    \"\"\"Material with arbitrary permittivity and permeability tensor components.\"\"\"\n\n    def __init__(self, material_data: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Initialize material with arbitrary permittivity and permeability tensors.\n\n        Args:\n            material_data: Dictionary with tensor components (eps_xx, eps_yy, etc.)\n                        If None, uses default identity-like values\n\n        Example:\n            &gt;&gt;&gt; mat_data = {\n            ...     \"eps_xx\": {\"real\": 2.5, \"imag\": 0.1},\n            ...     \"eps_yy\": {\"real\": 3.0, \"imag\": 0.0},\n            ...     \"eps_zz\": {\"real\": -4.0, \"imag\": 0.5},\n            ...     \"mu_r\": 1.0\n            ... }\n            &gt;&gt;&gt; material = ArbitraryMaterial(mat_data)\n        \"\"\"\n        super().__init__()\n        self.name = \"Arbitrary Material\"\n\n        if material_data is None:\n            material_data = load_material_parameters()[\"arbitrary_materials\"][\"default\"]\n\n        self._init_tensor_components(material_data)\n\n    def _to_complex(self, value: Any) -&gt; complex:\n        \"\"\"Convert various input formats to complex numbers.\n\n        Args:\n            value: Input value (dict, string, number, or None)\n\n        Returns:\n            Complex number representation\n\n        Note:\n            Handles dict with 'real'/'imag' keys, string representations,\n            and numeric values.\n        \"\"\"\n        if value is None:\n            return complex(0, 0)\n        if isinstance(value, dict):\n            return complex(value.get(\"real\", 0), value.get(\"imag\", 0))\n        if isinstance(value, str):\n            try:\n                return complex(value.replace(\" \", \"\"))\n            except ValueError:\n                return complex(0, 0)\n        return complex(value, 0)\n\n    def _init_tensor_components(self, material_data: dict[str, Any]) -&gt; None:\n        \"\"\"Initialize permittivity and permeability tensor components.\n\n        Args:\n            material_data: Dictionary with component values\n\n        Note:\n            Sets attributes for eps_xx, eps_yy, eps_zz, eps_xy, eps_xz, eps_yz\n            and corresponding mu components. Missing values default to\n            appropriate identity-like values.\n        \"\"\"\n        # Permittivity components\n        eps_components = {\n            \"eps_xx\": 1.0,\n            \"eps_yy\": 1.0,\n            \"eps_zz\": 1.0,\n            \"eps_xy\": 0.0,\n            \"eps_xz\": 0.0,\n            \"eps_yz\": 0.0,\n        }\n\n        # Magnetic permeability components\n        mu_components = {\n            \"mu_xx\": 1.0,\n            \"mu_yy\": 1.0,\n            \"mu_zz\": 1.0,\n            \"mu_xy\": 0.0,\n            \"mu_xz\": 0.0,\n            \"mu_yz\": 0.0,\n        }\n\n        all_components = {**eps_components, **mu_components}\n\n        for key, default in all_components.items():\n            value = material_data.get(key, default)\n            setattr(self, key, self._to_complex(value))\n\n        # Backward compatibility: if only mu_r is specified\n        if \"mu_r\" in material_data:\n            mu_r_val = self._to_complex(material_data[\"mu_r\"])\n            self.mu_xx = self.mu_yy = self.mu_zz = mu_r_val\n\n    def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n        \"\"\"Construct full permittivity tensor from components.\n\n        Returns:\n            3\u00d73 complex permittivity tensor\n        \"\"\"\n        tensor_elements = [\n            [self.eps_xx, self.eps_xy, self.eps_xz],\n            [self.eps_xy, self.eps_yy, self.eps_yz],\n            [self.eps_xz, self.eps_yz, self.eps_zz],\n        ]\n        return np.array(tensor_elements, dtype=np.complex128)\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Return frequency-independent permittivity tensor.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n        Returns:\n            3\u00d73 complex permittivity tensor\n\n        Note:\n            Arbitrary materials are frequency-independent by definition.\n        \"\"\"\n        return self.fetch_permittivity_tensor()\n\n    def fetch_magnetic_tensor(self) -&gt; np.ndarray:\n        \"\"\"Construct full magnetic permeability tensor from components.\n\n        Returns:\n            3\u00d73 complex permeability tensor\n        \"\"\"\n        tensor_elements = [\n            [self.mu_xx, self.mu_xy, self.mu_xz],\n            [self.mu_xy, self.mu_yy, self.mu_yz],\n            [self.mu_xz, self.mu_yz, self.mu_zz],\n        ]\n        return np.array(tensor_elements, dtype=np.complex128)\n\n    def fetch_magnetic_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Return frequency-independent magnetic tensor.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n        Returns:\n            3\u00d73 complex permeability tensor\n\n        Note:\n            Arbitrary materials are frequency-independent by definition.\n        \"\"\"\n        return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.__init__","title":"<code>__init__(material_data=None)</code>","text":"<p>Initialize material with arbitrary permittivity and permeability tensors.</p> <p>Parameters:</p> Name Type Description Default <code>material_data</code> <code>dict[str, Any] | None</code> <p>Dictionary with tensor components (eps_xx, eps_yy, etc.)         If None, uses default identity-like values</p> <code>None</code> Example <p>mat_data = { ...     \"eps_xx\": {\"real\": 2.5, \"imag\": 0.1}, ...     \"eps_yy\": {\"real\": 3.0, \"imag\": 0.0}, ...     \"eps_zz\": {\"real\": -4.0, \"imag\": 0.5}, ...     \"mu_r\": 1.0 ... } material = ArbitraryMaterial(mat_data)</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(self, material_data: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Initialize material with arbitrary permittivity and permeability tensors.\n\n    Args:\n        material_data: Dictionary with tensor components (eps_xx, eps_yy, etc.)\n                    If None, uses default identity-like values\n\n    Example:\n        &gt;&gt;&gt; mat_data = {\n        ...     \"eps_xx\": {\"real\": 2.5, \"imag\": 0.1},\n        ...     \"eps_yy\": {\"real\": 3.0, \"imag\": 0.0},\n        ...     \"eps_zz\": {\"real\": -4.0, \"imag\": 0.5},\n        ...     \"mu_r\": 1.0\n        ... }\n        &gt;&gt;&gt; material = ArbitraryMaterial(mat_data)\n    \"\"\"\n    super().__init__()\n    self.name = \"Arbitrary Material\"\n\n    if material_data is None:\n        material_data = load_material_parameters()[\"arbitrary_materials\"][\"default\"]\n\n    self._init_tensor_components(material_data)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_magnetic_tensor","title":"<code>fetch_magnetic_tensor()</code>","text":"<p>Construct full magnetic permeability tensor from components.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 complex permeability tensor</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor(self) -&gt; np.ndarray:\n    \"\"\"Construct full magnetic permeability tensor from components.\n\n    Returns:\n        3\u00d73 complex permeability tensor\n    \"\"\"\n    tensor_elements = [\n        [self.mu_xx, self.mu_xy, self.mu_xz],\n        [self.mu_xy, self.mu_yy, self.mu_yz],\n        [self.mu_xz, self.mu_yz, self.mu_zz],\n    ]\n    return np.array(tensor_elements, dtype=np.complex128)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_magnetic_tensor_for_freq","title":"<code>fetch_magnetic_tensor_for_freq(requested_frequency)</code>","text":"<p>Return frequency-independent magnetic tensor.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9 (ignored)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 complex permeability tensor</p> Note <p>Arbitrary materials are frequency-independent by definition.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Return frequency-independent magnetic tensor.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n    Returns:\n        3\u00d73 complex permeability tensor\n\n    Note:\n        Arbitrary materials are frequency-independent by definition.\n    \"\"\"\n    return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Construct full permittivity tensor from components.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 complex permittivity tensor</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n    \"\"\"Construct full permittivity tensor from components.\n\n    Returns:\n        3\u00d73 complex permittivity tensor\n    \"\"\"\n    tensor_elements = [\n        [self.eps_xx, self.eps_xy, self.eps_xz],\n        [self.eps_xy, self.eps_yy, self.eps_yz],\n        [self.eps_xz, self.eps_yz, self.eps_zz],\n    ]\n    return np.array(tensor_elements, dtype=np.complex128)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ArbitraryMaterial.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Return frequency-independent permittivity tensor.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9 (ignored)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 complex permittivity tensor</p> Note <p>Arbitrary materials are frequency-independent by definition.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Return frequency-independent permittivity tensor.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n    Returns:\n        3\u00d73 complex permittivity tensor\n\n    Note:\n        Arbitrary materials are frequency-independent by definition.\n    \"\"\"\n    return self.fetch_permittivity_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial","title":"<code>BaseMaterial</code>","text":"<p>Base class for all materials providing common functionality.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class BaseMaterial:\n    \"\"\"Base class for all materials providing common functionality.\"\"\"\n\n    def __init__(self, frequency_length: int = 410) -&gt; None:\n        \"\"\"Initialize base material with frequency array length.\n\n        Args:\n            frequency_length: Number of frequency points for dispersion calculations\n        \"\"\"\n        self.frequency_length = frequency_length\n        self.name = \"Base Material\"\n        self.frequency = None\n        self.mu_r = 1.0  # Default magnetic permeability\n\n    def _initialize_frequency_range(\n        self, params: dict[str, Any], freq_min: float | None = None, freq_max: float | None = None\n    ) -&gt; None:\n        \"\"\"Initialize frequency range from parameters or defaults.\n\n        Args:\n            params: Material parameters dictionary containing frequency_range\n            freq_min: Override minimum frequency in cm\u207b\u00b9\n            freq_max: Override maximum frequency in cm\u207b\u00b9\n\n        Note:\n            If freq_min/freq_max are not provided, uses default values from\n            the material parameters.\n        \"\"\"\n        if \"frequency_range\" not in params:\n            return\n\n        freq_range = params[\"frequency_range\"]\n        if freq_min is None:\n            freq_min = freq_range[\"default_min\"]\n        if freq_max is None:\n            freq_max = freq_range[\"default_max\"]\n\n        self.frequency = np.linspace(freq_min, freq_max, self.frequency_length, dtype=np.float64)\n\n    def _create_isotropic_mu_tensor_like(self, eps_tensor: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Create isotropic magnetic permeability tensor matching \u03b5 tensor shape.\n\n        Args:\n            eps_tensor: Permittivity tensor to match shape\n\n        Returns:\n            Magnetic permeability tensor with \u03bc = \u03bc\u1d63\u00b7I where I is identity matrix\n\n        Note:\n            Default behavior is non-magnetic (\u03bc\u1d63 = 1), but can be overridden\n            by setting self.mu_r in subclasses.\n        \"\"\"\n        # Create identity matrix with same shape as eps_tensor\n        shape = eps_tensor.shape[:-2] + (3, 3)\n        mu_tensor = np.zeros(shape, dtype=np.complex128)\n\n        # Fill diagonal with mu_r\n        if len(shape) == 2:  # Simple 3x3 case\n            np.fill_diagonal(mu_tensor, self.mu_r)\n        else:  # Handle batch dimensions\n            # Reshape to 2D, fill diagonal, reshape back\n            original_shape = mu_tensor.shape\n            n_matrices = np.prod(original_shape[:-2])\n            mu_tensor_2d = mu_tensor.reshape(n_matrices, 3, 3)\n            for i in range(n_matrices):\n                np.fill_diagonal(mu_tensor_2d[i], self.mu_r)\n            mu_tensor = mu_tensor_2d.reshape(original_shape)\n\n        return mu_tensor.astype(np.complex128)\n\n    def fetch_magnetic_tensor(self) -&gt; np.ndarray:\n        \"\"\"Fetch magnetic permeability tensor for full frequency range.\n\n        Returns:\n            Complex magnetic permeability tensor with shape matching permittivity\n\n        Note:\n            Default implementation returns isotropic tensor. Override in subclasses\n            for magnetic materials.\n        \"\"\"\n        eps_tensor = self.fetch_permittivity_tensor()\n        return self._create_isotropic_mu_tensor_like(eps_tensor)\n\n    def fetch_magnetic_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Fetch magnetic permeability tensor for specific frequency.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9\n\n        Returns:\n            Complex magnetic permeability tensor at the requested frequency\n        \"\"\"\n        eps_tensor = self.fetch_permittivity_tensor_for_freq(requested_frequency)\n        return self._create_isotropic_mu_tensor_like(eps_tensor)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial.__init__","title":"<code>__init__(frequency_length=410)</code>","text":"<p>Initialize base material with frequency array length.</p> <p>Parameters:</p> Name Type Description Default <code>frequency_length</code> <code>int</code> <p>Number of frequency points for dispersion calculations</p> <code>410</code> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(self, frequency_length: int = 410) -&gt; None:\n    \"\"\"Initialize base material with frequency array length.\n\n    Args:\n        frequency_length: Number of frequency points for dispersion calculations\n    \"\"\"\n    self.frequency_length = frequency_length\n    self.name = \"Base Material\"\n    self.frequency = None\n    self.mu_r = 1.0  # Default magnetic permeability\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial.fetch_magnetic_tensor","title":"<code>fetch_magnetic_tensor()</code>","text":"<p>Fetch magnetic permeability tensor for full frequency range.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Complex magnetic permeability tensor with shape matching permittivity</p> Note <p>Default implementation returns isotropic tensor. Override in subclasses for magnetic materials.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor(self) -&gt; np.ndarray:\n    \"\"\"Fetch magnetic permeability tensor for full frequency range.\n\n    Returns:\n        Complex magnetic permeability tensor with shape matching permittivity\n\n    Note:\n        Default implementation returns isotropic tensor. Override in subclasses\n        for magnetic materials.\n    \"\"\"\n    eps_tensor = self.fetch_permittivity_tensor()\n    return self._create_isotropic_mu_tensor_like(eps_tensor)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.BaseMaterial.fetch_magnetic_tensor_for_freq","title":"<code>fetch_magnetic_tensor_for_freq(requested_frequency)</code>","text":"<p>Fetch magnetic permeability tensor for specific frequency.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Complex magnetic permeability tensor at the requested frequency</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Fetch magnetic permeability tensor for specific frequency.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9\n\n    Returns:\n        Complex magnetic permeability tensor at the requested frequency\n    \"\"\"\n    eps_tensor = self.fetch_permittivity_tensor_for_freq(requested_frequency)\n    return self._create_isotropic_mu_tensor_like(eps_tensor)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Calcite","title":"<code>Calcite</code>","text":"<p>               Bases: <code>ParameterizedUniaxialMaterial</code></p> <p>Calcite material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Calcite(ParameterizedUniaxialMaterial):\n    \"\"\"Calcite material implementation.\"\"\"\n\n    def __init__(\n        self,\n        freq_min: float | None = None,\n        freq_max: float | None = None,\n        variant: str | None = None,\n        mu_r: float = 1.0,\n    ) -&gt; None:\n        \"\"\"Initialize Calcite (CaCO\u2083) material with specified reststrahlen band.\n\n        Args:\n            freq_min: Override minimum frequency\n            freq_max: Override maximum frequency\n            variant: 'lower' for 860-920 cm\u207b\u00b9 or 'upper' for 1300-1600 cm\u207b\u00b9\n            mu_r: Relative magnetic permeability (default: 1.0)\n\n        Raises:\n            ValueError: If variant is not 'lower' or 'upper'\n\n        Note:\n            Calcite must be instantiated through CalciteLower or CalciteUpper\n            subclasses rather than directly.\n        \"\"\"\n        if variant is None:\n            raise ValueError(\n                \"Calcite material must be instantiated with a variant ('lower' or 'upper')\"\n            )\n\n        calcite_config = load_material_parameters()[\"uniaxial_materials\"][\"calcite\"]\n        super().__init__(\"calcite\", freq_min, freq_max, mu_r)\n\n        if variant not in calcite_config[\"variants\"]:\n            raise ValueError(\"Calcite variant must be either 'lower' or 'upper'\")\n\n        variant_params = calcite_config[\"variants\"][variant]\n        self.name = variant_params.get(\"name\", self.name)\n        self._initialize_frequency_range(variant_params, freq_min, freq_max)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Calcite.__init__","title":"<code>__init__(freq_min=None, freq_max=None, variant=None, mu_r=1.0)</code>","text":"<p>Initialize Calcite (CaCO\u2083) material with specified reststrahlen band.</p> <p>Parameters:</p> Name Type Description Default <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency</p> <code>None</code> <code>variant</code> <code>str | None</code> <p>'lower' for 860-920 cm\u207b\u00b9 or 'upper' for 1300-1600 cm\u207b\u00b9</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0)</p> <code>1.0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If variant is not 'lower' or 'upper'</p> Note <p>Calcite must be instantiated through CalciteLower or CalciteUpper subclasses rather than directly.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self,\n    freq_min: float | None = None,\n    freq_max: float | None = None,\n    variant: str | None = None,\n    mu_r: float = 1.0,\n) -&gt; None:\n    \"\"\"Initialize Calcite (CaCO\u2083) material with specified reststrahlen band.\n\n    Args:\n        freq_min: Override minimum frequency\n        freq_max: Override maximum frequency\n        variant: 'lower' for 860-920 cm\u207b\u00b9 or 'upper' for 1300-1600 cm\u207b\u00b9\n        mu_r: Relative magnetic permeability (default: 1.0)\n\n    Raises:\n        ValueError: If variant is not 'lower' or 'upper'\n\n    Note:\n        Calcite must be instantiated through CalciteLower or CalciteUpper\n        subclasses rather than directly.\n    \"\"\"\n    if variant is None:\n        raise ValueError(\n            \"Calcite material must be instantiated with a variant ('lower' or 'upper')\"\n        )\n\n    calcite_config = load_material_parameters()[\"uniaxial_materials\"][\"calcite\"]\n    super().__init__(\"calcite\", freq_min, freq_max, mu_r)\n\n    if variant not in calcite_config[\"variants\"]:\n        raise ValueError(\"Calcite variant must be either 'lower' or 'upper'\")\n\n    variant_params = calcite_config[\"variants\"][variant]\n    self.name = variant_params.get(\"name\", self.name)\n    self._initialize_frequency_range(variant_params, freq_min, freq_max)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.CalciteLower","title":"<code>CalciteLower</code>","text":"<p>               Bases: <code>Calcite</code></p> <p>Lower frequency range Calcite implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class CalciteLower(Calcite):\n    \"\"\"Lower frequency range Calcite implementation.\"\"\"\n\n    def __init__(\n        self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n    ) -&gt; None:\n        \"\"\"Initialize Calcite lower reststrahlen band (860-920 cm\u207b\u00b9).\n\n        Args:\n            freq_min: Override minimum frequency\n            freq_max: Override maximum frequency\n            mu_r: Relative magnetic permeability (default: 1.0)\n        \"\"\"\n        super().__init__(freq_min, freq_max, variant=\"lower\", mu_r=mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.CalciteLower.__init__","title":"<code>__init__(freq_min=None, freq_max=None, mu_r=1.0)</code>","text":"<p>Initialize Calcite lower reststrahlen band (860-920 cm\u207b\u00b9).</p> <p>Parameters:</p> Name Type Description Default <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0)</p> <code>1.0</code> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n) -&gt; None:\n    \"\"\"Initialize Calcite lower reststrahlen band (860-920 cm\u207b\u00b9).\n\n    Args:\n        freq_min: Override minimum frequency\n        freq_max: Override maximum frequency\n        mu_r: Relative magnetic permeability (default: 1.0)\n    \"\"\"\n    super().__init__(freq_min, freq_max, variant=\"lower\", mu_r=mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.CalciteUpper","title":"<code>CalciteUpper</code>","text":"<p>               Bases: <code>Calcite</code></p> <p>Upper frequency range Calcite implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class CalciteUpper(Calcite):\n    \"\"\"Upper frequency range Calcite implementation.\"\"\"\n\n    def __init__(\n        self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n    ) -&gt; None:\n        \"\"\"Initialize Calcite upper reststrahlen band (1300-1600 cm\u207b\u00b9).\n\n        Args:\n            freq_min: Override minimum frequency\n            freq_max: Override maximum frequency\n            mu_r: Relative magnetic permeability (default: 1.0)\n\n        Note:\n            The upper band exhibits type-II hyperbolic dispersion (\u03b5_\u2225 &lt; 0, \u03b5_\u22a5 &gt; 0).\n        \"\"\"\n        super().__init__(freq_min, freq_max, variant=\"upper\", mu_r=mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.CalciteUpper.__init__","title":"<code>__init__(freq_min=None, freq_max=None, mu_r=1.0)</code>","text":"<p>Initialize Calcite upper reststrahlen band (1300-1600 cm\u207b\u00b9).</p> <p>Parameters:</p> Name Type Description Default <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0)</p> <code>1.0</code> Note <p>The upper band exhibits type-II hyperbolic dispersion (\u03b5_\u2225 &lt; 0, \u03b5_\u22a5 &gt; 0).</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n) -&gt; None:\n    \"\"\"Initialize Calcite upper reststrahlen band (1300-1600 cm\u207b\u00b9).\n\n    Args:\n        freq_min: Override minimum frequency\n        freq_max: Override maximum frequency\n        mu_r: Relative magnetic permeability (default: 1.0)\n\n    Note:\n        The upper band exhibits type-II hyperbolic dispersion (\u03b5_\u2225 &lt; 0, \u03b5_\u22a5 &gt; 0).\n    \"\"\"\n    super().__init__(freq_min, freq_max, variant=\"upper\", mu_r=mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide","title":"<code>GalliumOxide</code>","text":"<p>               Bases: <code>MonoclinicMaterial</code></p> <p>Gallium Oxide implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class GalliumOxide(MonoclinicMaterial):\n    \"\"\"Gallium Oxide implementation.\"\"\"\n\n    def __init__(\n        self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n    ) -&gt; None:\n        \"\"\"Initialize \u03b2-Ga\u2082O\u2083 (monoclinic) material.\n\n        Args:\n            freq_min: Override minimum frequency (default: 350 cm\u207b\u00b9)\n            freq_max: Override maximum frequency (default: 800 cm\u207b\u00b9)\n            mu_r: Relative magnetic permeability (default: 1.0)\n\n        Note:\n            Gallium oxide is a monoclinic crystal with non-zero \u03b5_xy coupling,\n            supporting hyperbolic polaritons with in-plane anisotropy.\n        \"\"\"\n        super().__init__()\n        params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"]\n        self.name = params[\"name\"]\n        self.mu_r = mu_r\n        self._initialize_frequency_range(params, freq_min, freq_max)\n\n    def permittivity_parameters(self) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Get Gallium Oxide symmetry mode parameters.\n\n        Returns:\n            Dictionary with 'Au' and 'Bu' mode parameters including oscillator\n            strengths, frequencies, dampings, and orientation angles\n        \"\"\"\n        params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"][\"parameters\"]\n        # Convert all numeric values to numpy arrays\n        result = {}\n        for mode, mode_params in params.items():\n            result[mode] = {}\n            for key, value in mode_params.items():\n                if isinstance(value, dict):\n                    result[mode][key] = value  # Keep high_freq dict as is\n                elif isinstance(value, list):\n                    result[mode][key] = np.array(value, dtype=np.complex128)\n                else:\n                    result[mode][key] = np.complex128(value)\n        return result\n\n    def _create_permittivity_tensor(\n        self, eps_xx: np.ndarray, eps_yy: np.ndarray, eps_zz: np.ndarray, eps_xy: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"Create full permittivity tensor with off-diagonal coupling.\n\n        Args:\n            eps_xx: xx component\n            eps_yy: yy component\n            eps_zz: zz component\n            eps_xy: xy coupling component\n\n        Returns:\n            Full 3\u00d73 permittivity tensor with monoclinic symmetry\n\n        Note:\n            The tensor has the form:\n            [eps_xx  eps_xy    0   ]\n            [eps_xy  eps_yy    0   ]\n            [  0       0    eps_zz]\n        \"\"\"\n        zeros = np.zeros_like(eps_xx)\n        tensor = np.array(\n            [[eps_xx, eps_xy, zeros], [eps_xy, eps_yy, zeros], [zeros, zeros, eps_zz]],\n            dtype=np.complex128,\n        )\n\n        # Move frequency axis to first dimension if needed\n        if tensor.shape[-1] != 3:\n            tensor = np.moveaxis(tensor, -1, 0)\n\n        return tensor\n\n    def permittivity_calc(self) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Calculate all permittivity tensor components over frequency range.\n\n        Returns:\n            Tuple of (eps_xx, eps_yy, eps_zz, eps_xy) arrays\n        \"\"\"\n        parameters = self.permittivity_parameters()\n        frequency = self.frequency[:, np.newaxis]\n\n        eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n        eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n        eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu\n        eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu\n        eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu\n        eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au\n\n        return eps_xx, eps_yy, eps_zz, eps_xy\n\n    def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n        \"\"\"Fetch full permittivity tensor for all frequencies.\n\n        Returns:\n            Permittivity tensor with shape [N, 3, 3]\n        \"\"\"\n        eps_xx, eps_yy, eps_zz, eps_xy = self.permittivity_calc()\n        return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Fetch permittivity tensor at specific frequency.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9\n\n        Returns:\n            Permittivity tensor with shape [3, 3]\n        \"\"\"\n        parameters = self.permittivity_parameters()\n        frequency = np.array([[requested_frequency]], dtype=np.float64)\n\n        eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n        eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n        eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu[0]\n        eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu[0]\n        eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu[0]\n        eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au[0]\n\n        return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.__init__","title":"<code>__init__(freq_min=None, freq_max=None, mu_r=1.0)</code>","text":"<p>Initialize \u03b2-Ga\u2082O\u2083 (monoclinic) material.</p> <p>Parameters:</p> Name Type Description Default <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency (default: 350 cm\u207b\u00b9)</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency (default: 800 cm\u207b\u00b9)</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0)</p> <code>1.0</code> Note <p>Gallium oxide is a monoclinic crystal with non-zero \u03b5_xy coupling, supporting hyperbolic polaritons with in-plane anisotropy.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n) -&gt; None:\n    \"\"\"Initialize \u03b2-Ga\u2082O\u2083 (monoclinic) material.\n\n    Args:\n        freq_min: Override minimum frequency (default: 350 cm\u207b\u00b9)\n        freq_max: Override maximum frequency (default: 800 cm\u207b\u00b9)\n        mu_r: Relative magnetic permeability (default: 1.0)\n\n    Note:\n        Gallium oxide is a monoclinic crystal with non-zero \u03b5_xy coupling,\n        supporting hyperbolic polaritons with in-plane anisotropy.\n    \"\"\"\n    super().__init__()\n    params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"]\n    self.name = params[\"name\"]\n    self.mu_r = mu_r\n    self._initialize_frequency_range(params, freq_min, freq_max)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Fetch full permittivity tensor for all frequencies.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Permittivity tensor with shape [N, 3, 3]</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n    \"\"\"Fetch full permittivity tensor for all frequencies.\n\n    Returns:\n        Permittivity tensor with shape [N, 3, 3]\n    \"\"\"\n    eps_xx, eps_yy, eps_zz, eps_xy = self.permittivity_calc()\n    return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Fetch permittivity tensor at specific frequency.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Permittivity tensor with shape [3, 3]</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Fetch permittivity tensor at specific frequency.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9\n\n    Returns:\n        Permittivity tensor with shape [3, 3]\n    \"\"\"\n    parameters = self.permittivity_parameters()\n    frequency = np.array([[requested_frequency]], dtype=np.float64)\n\n    eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n    eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n    eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu[0]\n    eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu[0]\n    eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu[0]\n    eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au[0]\n\n    return self._create_permittivity_tensor(eps_xx, eps_yy, eps_zz, eps_xy)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.permittivity_calc","title":"<code>permittivity_calc()</code>","text":"<p>Calculate all permittivity tensor components over frequency range.</p> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple of (eps_xx, eps_yy, eps_zz, eps_xy) arrays</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_calc(self) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Calculate all permittivity tensor components over frequency range.\n\n    Returns:\n        Tuple of (eps_xx, eps_yy, eps_zz, eps_xy) arrays\n    \"\"\"\n    parameters = self.permittivity_parameters()\n    frequency = self.frequency[:, np.newaxis]\n\n    eps_xx_bu, eps_xy_bu, eps_yy_bu = self._calculate_bu_components(parameters, frequency)\n    eps_zz_au = self._calculate_au_component(parameters, frequency)\n\n    eps_xx = parameters[\"Bu\"][\"high_freq\"][\"xx\"] + eps_xx_bu\n    eps_xy = parameters[\"Bu\"][\"high_freq\"][\"xy\"] + eps_xy_bu\n    eps_yy = parameters[\"Bu\"][\"high_freq\"][\"yy\"] + eps_yy_bu\n    eps_zz = parameters[\"Au\"][\"high_freq\"] + eps_zz_au\n\n    return eps_xx, eps_yy, eps_zz, eps_xy\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.GalliumOxide.permittivity_parameters","title":"<code>permittivity_parameters()</code>","text":"<p>Get Gallium Oxide symmetry mode parameters.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, Any]]</code> <p>Dictionary with 'Au' and 'Bu' mode parameters including oscillator</p> <code>dict[str, dict[str, Any]]</code> <p>strengths, frequencies, dampings, and orientation angles</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_parameters(self) -&gt; dict[str, dict[str, Any]]:\n    \"\"\"Get Gallium Oxide symmetry mode parameters.\n\n    Returns:\n        Dictionary with 'Au' and 'Bu' mode parameters including oscillator\n        strengths, frequencies, dampings, and orientation angles\n    \"\"\"\n    params = load_material_parameters()[\"monoclinic_materials\"][\"gallium_oxide\"][\"parameters\"]\n    # Convert all numeric values to numpy arrays\n    result = {}\n    for mode, mode_params in params.items():\n        result[mode] = {}\n        for key, value in mode_params.items():\n            if isinstance(value, dict):\n                result[mode][key] = value  # Keep high_freq dict as is\n            elif isinstance(value, list):\n                result[mode][key] = np.array(value, dtype=np.complex128)\n            else:\n                result[mode][key] = np.complex128(value)\n    return result\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial","title":"<code>IsotropicMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Base class for isotropic materials like air.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class IsotropicMaterial(BaseMaterial):\n    \"\"\"Base class for isotropic materials like air.\"\"\"\n\n    def __init__(\n        self,\n        permittivity: float | complex | dict[str, float] | None = None,\n        permeability: float | complex | dict[str, float] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize isotropic material with scalar permittivity and permeability.\n\n        Args:\n            permittivity: Relative permittivity (scalar or dict with 'real'/'imag')\n            permeability: Relative permeability (scalar or dict with 'real'/'imag')\n\n        Note:\n            For isotropic materials, all diagonal tensor components are equal\n            and off-diagonal components are zero.\n        \"\"\"\n        super().__init__()\n        self.permittivity = self._process_permittivity(permittivity)\n        self.permeability = (\n            self._process_permittivity(permeability)\n            if permeability is not None\n            else complex(1.0, 0.0)\n        )\n\n    def _process_permittivity(\n        self, permittivity: float | complex | dict[str, float] | None\n    ) -&gt; complex:\n        \"\"\"Convert permittivity input to complex number.\n\n        Args:\n            permittivity: Input in various formats\n\n        Returns:\n            Complex permittivity value\n\n        Note:\n            Handles None (defaults to 1.0), scalars, and dicts with 'real'/'imag'.\n        \"\"\"\n        if permittivity is None:\n            return complex(1.0, 0.0)\n\n        if isinstance(permittivity, dict):\n            return complex(permittivity.get(\"real\", 0), permittivity.get(\"imag\", 0))\n        if isinstance(permittivity, (int, float, complex)):\n            return complex(permittivity)\n        return permittivity\n\n    def construct_tensor_singular(self) -&gt; np.ndarray:\n        \"\"\"Create diagonal tensor with scalar permittivity value.\n\n        Returns:\n            3\u00d73 diagonal tensor with permittivity on diagonal\n        \"\"\"\n        return np.array(\n            [\n                [self.permittivity, 0.0, 0.0],\n                [0.0, self.permittivity, 0.0],\n                [0.0, 0.0, self.permittivity],\n            ],\n            dtype=np.complex128,\n        )\n\n    def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n        \"\"\"Get permittivity tensor for isotropic material.\n\n        Returns:\n            3\u00d73 diagonal permittivity tensor\n        \"\"\"\n        return self.construct_tensor_singular()\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Get frequency-independent permittivity tensor.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n        Returns:\n            3\u00d73 diagonal permittivity tensor\n        \"\"\"\n        return self.construct_tensor_singular()\n\n    def fetch_magnetic_tensor(self) -&gt; np.ndarray:\n        \"\"\"Get magnetic permeability tensor for isotropic material.\n\n        Returns:\n            3\u00d73 diagonal permeability tensor\n        \"\"\"\n        return np.array(\n            [\n                [self.permeability, 0.0, 0.0],\n                [0.0, self.permeability, 0.0],\n                [0.0, 0.0, self.permeability],\n            ],\n            dtype=np.complex128,\n        )\n\n    def fetch_magnetic_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Get frequency-independent magnetic tensor.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n        Returns:\n            3\u00d73 diagonal permeability tensor\n        \"\"\"\n        return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.__init__","title":"<code>__init__(permittivity=None, permeability=None)</code>","text":"<p>Initialize isotropic material with scalar permittivity and permeability.</p> <p>Parameters:</p> Name Type Description Default <code>permittivity</code> <code>float | complex | dict[str, float] | None</code> <p>Relative permittivity (scalar or dict with 'real'/'imag')</p> <code>None</code> <code>permeability</code> <code>float | complex | dict[str, float] | None</code> <p>Relative permeability (scalar or dict with 'real'/'imag')</p> <code>None</code> Note <p>For isotropic materials, all diagonal tensor components are equal and off-diagonal components are zero.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self,\n    permittivity: float | complex | dict[str, float] | None = None,\n    permeability: float | complex | dict[str, float] | None = None,\n) -&gt; None:\n    \"\"\"Initialize isotropic material with scalar permittivity and permeability.\n\n    Args:\n        permittivity: Relative permittivity (scalar or dict with 'real'/'imag')\n        permeability: Relative permeability (scalar or dict with 'real'/'imag')\n\n    Note:\n        For isotropic materials, all diagonal tensor components are equal\n        and off-diagonal components are zero.\n    \"\"\"\n    super().__init__()\n    self.permittivity = self._process_permittivity(permittivity)\n    self.permeability = (\n        self._process_permittivity(permeability)\n        if permeability is not None\n        else complex(1.0, 0.0)\n    )\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.construct_tensor_singular","title":"<code>construct_tensor_singular()</code>","text":"<p>Create diagonal tensor with scalar permittivity value.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 diagonal tensor with permittivity on diagonal</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def construct_tensor_singular(self) -&gt; np.ndarray:\n    \"\"\"Create diagonal tensor with scalar permittivity value.\n\n    Returns:\n        3\u00d73 diagonal tensor with permittivity on diagonal\n    \"\"\"\n    return np.array(\n        [\n            [self.permittivity, 0.0, 0.0],\n            [0.0, self.permittivity, 0.0],\n            [0.0, 0.0, self.permittivity],\n        ],\n        dtype=np.complex128,\n    )\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_magnetic_tensor","title":"<code>fetch_magnetic_tensor()</code>","text":"<p>Get magnetic permeability tensor for isotropic material.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 diagonal permeability tensor</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor(self) -&gt; np.ndarray:\n    \"\"\"Get magnetic permeability tensor for isotropic material.\n\n    Returns:\n        3\u00d73 diagonal permeability tensor\n    \"\"\"\n    return np.array(\n        [\n            [self.permeability, 0.0, 0.0],\n            [0.0, self.permeability, 0.0],\n            [0.0, 0.0, self.permeability],\n        ],\n        dtype=np.complex128,\n    )\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_magnetic_tensor_for_freq","title":"<code>fetch_magnetic_tensor_for_freq(requested_frequency)</code>","text":"<p>Get frequency-independent magnetic tensor.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9 (ignored)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 diagonal permeability tensor</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_magnetic_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Get frequency-independent magnetic tensor.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n    Returns:\n        3\u00d73 diagonal permeability tensor\n    \"\"\"\n    return self.fetch_magnetic_tensor()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Get permittivity tensor for isotropic material.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 diagonal permittivity tensor</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n    \"\"\"Get permittivity tensor for isotropic material.\n\n    Returns:\n        3\u00d73 diagonal permittivity tensor\n    \"\"\"\n    return self.construct_tensor_singular()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.IsotropicMaterial.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Get frequency-independent permittivity tensor.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9 (ignored)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3\u00d73 diagonal permittivity tensor</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Get frequency-independent permittivity tensor.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9 (ignored)\n\n    Returns:\n        3\u00d73 diagonal permittivity tensor\n    \"\"\"\n    return self.construct_tensor_singular()\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.MonoclinicMaterial","title":"<code>MonoclinicMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Base class for monoclinic materials with more complex permittivity tensors.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class MonoclinicMaterial(BaseMaterial):\n    \"\"\"Base class for monoclinic materials with more complex permittivity tensors.\"\"\"\n\n    def _calculate_bu_components(\n        self, parameters: dict[str, Any], frequency: np.ndarray\n    ) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Calculate Bu symmetry mode contributions to permittivity.\n\n        Args:\n            parameters: Material parameters including Bu mode data\n            frequency: Frequency array in cm\u207b\u00b9\n\n        Returns:\n            Tuple of (eps_xx_bu, eps_xy_bu, eps_yy_bu) contributions\n\n        Note:\n            Bu modes couple x and y components, creating off-diagonal permittivity\n            elements characteristic of monoclinic crystals.\n        \"\"\"\n        partial_calc_tn_bu = parameters[\"Bu\"][\"amplitude\"] ** 2.0 / (\n            parameters[\"Bu\"][\"omega_tn\"] ** 2.0\n            - frequency**2.0\n            - 1j * frequency * parameters[\"Bu\"][\"gamma_tn\"]\n        )\n\n        alpha_rad = parameters[\"Bu\"][\"alpha_tn\"] * np.pi / 180.0\n        cos_alpha = np.cos(alpha_rad)\n        sin_alpha = np.sin(alpha_rad)\n\n        eps_xx_bu = np.sum(partial_calc_tn_bu * cos_alpha**2.0, axis=1)\n        eps_xy_bu = np.sum(partial_calc_tn_bu * sin_alpha * cos_alpha, axis=1)\n        eps_yy_bu = np.sum(partial_calc_tn_bu * sin_alpha**2.0, axis=1)\n\n        return eps_xx_bu, eps_xy_bu, eps_yy_bu\n\n    def _calculate_au_component(\n        self, parameters: dict[str, Any], frequency: np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"Calculate Au symmetry mode contribution to zz permittivity component.\n\n        Args:\n            parameters: Material parameters including Au mode data\n            frequency: Frequency array in cm\u207b\u00b9\n\n        Returns:\n            eps_zz contribution from Au modes\n\n        Note:\n            Au modes affect only the zz component and are decoupled from\n            in-plane components.\n        \"\"\"\n        partial_calc_tn_au = parameters[\"Au\"][\"amplitude\"] ** 2.0 / (\n            parameters[\"Au\"][\"omega_tn\"] ** 2.0\n            - frequency**2.0\n            - 1j * frequency * parameters[\"Au\"][\"gamma_tn\"]\n        )\n        return np.sum(partial_calc_tn_au, axis=1)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ParameterizedUniaxialMaterial","title":"<code>ParameterizedUniaxialMaterial</code>","text":"<p>               Bases: <code>UniaxialMaterial</code></p> <p>Base class for uniaxial materials with parameters from configuration.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class ParameterizedUniaxialMaterial(UniaxialMaterial):\n    \"\"\"Base class for uniaxial materials with parameters from configuration.\"\"\"\n\n    def __init__(\n        self,\n        material_type: str,\n        freq_min: float | None = None,\n        freq_max: float | None = None,\n        mu_r: float = 1.0,\n    ) -&gt; None:\n        \"\"\"Initialize uniaxial material from parameter configuration.\n\n        Args:\n            material_type: Material identifier in configuration ('quartz', 'sapphire', etc.)\n            freq_min: Override minimum frequency in cm\u207b\u00b9\n            freq_max: Override maximum frequency in cm\u207b\u00b9\n            mu_r: Relative magnetic permeability (default: 1.0 for non-magnetic)\n        \"\"\"\n        super().__init__()\n        params = load_material_parameters()[\"uniaxial_materials\"][material_type]\n        self.name = params.get(\"name\", \"Unnamed Material\")\n        self.material_type = material_type\n        self.mu_r = mu_r\n\n        if \"frequency_range\" in params:\n            self._initialize_frequency_range(params, freq_min, freq_max)\n        else:\n            self.frequency = None\n\n    def permittivity_parameters(self) -&gt; dict[str, dict[str, np.ndarray]]:\n        \"\"\"Get permittivity parameters from JSON configuration.\n\n        Returns:\n            Dictionary containing ordinary and extraordinary axis parameters\n        \"\"\"\n        params = load_material_parameters()[\"uniaxial_materials\"][self.material_type][\"parameters\"]\n        return {\n            axis: {key: np.array(value, dtype=np.complex128) for key, value in axis_params.items()}\n            for axis, axis_params in params.items()\n        }\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ParameterizedUniaxialMaterial.__init__","title":"<code>__init__(material_type, freq_min=None, freq_max=None, mu_r=1.0)</code>","text":"<p>Initialize uniaxial material from parameter configuration.</p> <p>Parameters:</p> Name Type Description Default <code>material_type</code> <code>str</code> <p>Material identifier in configuration ('quartz', 'sapphire', etc.)</p> required <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency in cm\u207b\u00b9</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency in cm\u207b\u00b9</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0 for non-magnetic)</p> <code>1.0</code> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self,\n    material_type: str,\n    freq_min: float | None = None,\n    freq_max: float | None = None,\n    mu_r: float = 1.0,\n) -&gt; None:\n    \"\"\"Initialize uniaxial material from parameter configuration.\n\n    Args:\n        material_type: Material identifier in configuration ('quartz', 'sapphire', etc.)\n        freq_min: Override minimum frequency in cm\u207b\u00b9\n        freq_max: Override maximum frequency in cm\u207b\u00b9\n        mu_r: Relative magnetic permeability (default: 1.0 for non-magnetic)\n    \"\"\"\n    super().__init__()\n    params = load_material_parameters()[\"uniaxial_materials\"][material_type]\n    self.name = params.get(\"name\", \"Unnamed Material\")\n    self.material_type = material_type\n    self.mu_r = mu_r\n\n    if \"frequency_range\" in params:\n        self._initialize_frequency_range(params, freq_min, freq_max)\n    else:\n        self.frequency = None\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.ParameterizedUniaxialMaterial.permittivity_parameters","title":"<code>permittivity_parameters()</code>","text":"<p>Get permittivity parameters from JSON configuration.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, ndarray]]</code> <p>Dictionary containing ordinary and extraordinary axis parameters</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_parameters(self) -&gt; dict[str, dict[str, np.ndarray]]:\n    \"\"\"Get permittivity parameters from JSON configuration.\n\n    Returns:\n        Dictionary containing ordinary and extraordinary axis parameters\n    \"\"\"\n    params = load_material_parameters()[\"uniaxial_materials\"][self.material_type][\"parameters\"]\n    return {\n        axis: {key: np.array(value, dtype=np.complex128) for key, value in axis_params.items()}\n        for axis, axis_params in params.items()\n    }\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Quartz","title":"<code>Quartz</code>","text":"<p>               Bases: <code>ParameterizedUniaxialMaterial</code></p> <p>Quartz material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Quartz(ParameterizedUniaxialMaterial):\n    \"\"\"Quartz material implementation.\"\"\"\n\n    # Quartz\n    def __init__(\n        self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n    ) -&gt; None:\n        \"\"\"Initialize Quartz (\u03b1-SiO\u2082) material.\n\n        Args:\n            freq_min: Override minimum frequency (default: 410 cm\u207b\u00b9)\n            freq_max: Override maximum frequency (default: 600 cm\u207b\u00b9)\n            mu_r: Relative magnetic permeability (default: 1.0)\n\n        Note:\n            Quartz is a uniaxial positive crystal supporting hyperbolic phonon\n            polaritons in the far-infrared.\n        \"\"\"\n        super().__init__(\"quartz\", freq_min, freq_max, mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Quartz.__init__","title":"<code>__init__(freq_min=None, freq_max=None, mu_r=1.0)</code>","text":"<p>Initialize Quartz (\u03b1-SiO\u2082) material.</p> <p>Parameters:</p> Name Type Description Default <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency (default: 410 cm\u207b\u00b9)</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency (default: 600 cm\u207b\u00b9)</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0)</p> <code>1.0</code> Note <p>Quartz is a uniaxial positive crystal supporting hyperbolic phonon polaritons in the far-infrared.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n) -&gt; None:\n    \"\"\"Initialize Quartz (\u03b1-SiO\u2082) material.\n\n    Args:\n        freq_min: Override minimum frequency (default: 410 cm\u207b\u00b9)\n        freq_max: Override maximum frequency (default: 600 cm\u207b\u00b9)\n        mu_r: Relative magnetic permeability (default: 1.0)\n\n    Note:\n        Quartz is a uniaxial positive crystal supporting hyperbolic phonon\n        polaritons in the far-infrared.\n    \"\"\"\n    super().__init__(\"quartz\", freq_min, freq_max, mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Sapphire","title":"<code>Sapphire</code>","text":"<p>               Bases: <code>ParameterizedUniaxialMaterial</code></p> <p>Sapphire material implementation.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class Sapphire(ParameterizedUniaxialMaterial):\n    \"\"\"Sapphire material implementation.\"\"\"\n\n    def __init__(\n        self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n    ) -&gt; None:\n        \"\"\"Initialize Sapphire (\u03b1-Al\u2082O\u2083) material.\n\n        Args:\n            freq_min: Override minimum frequency (default: 210 cm\u207b\u00b9)\n            freq_max: Override maximum frequency (default: 1000 cm\u207b\u00b9)\n            mu_r: Relative magnetic permeability (default: 1.0)\n\n        Note:\n            Sapphire is a uniaxial crystal with hyperbolic\n            dispersion.\n        \"\"\"\n        super().__init__(\"sapphire\", freq_min, freq_max, mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.Sapphire.__init__","title":"<code>__init__(freq_min=None, freq_max=None, mu_r=1.0)</code>","text":"<p>Initialize Sapphire (\u03b1-Al\u2082O\u2083) material.</p> <p>Parameters:</p> Name Type Description Default <code>freq_min</code> <code>float | None</code> <p>Override minimum frequency (default: 210 cm\u207b\u00b9)</p> <code>None</code> <code>freq_max</code> <code>float | None</code> <p>Override maximum frequency (default: 1000 cm\u207b\u00b9)</p> <code>None</code> <code>mu_r</code> <code>float</code> <p>Relative magnetic permeability (default: 1.0)</p> <code>1.0</code> Note <p>Sapphire is a uniaxial crystal with hyperbolic dispersion.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def __init__(\n    self, freq_min: float | None = None, freq_max: float | None = None, mu_r: float = 1.0\n) -&gt; None:\n    \"\"\"Initialize Sapphire (\u03b1-Al\u2082O\u2083) material.\n\n    Args:\n        freq_min: Override minimum frequency (default: 210 cm\u207b\u00b9)\n        freq_max: Override maximum frequency (default: 1000 cm\u207b\u00b9)\n        mu_r: Relative magnetic permeability (default: 1.0)\n\n    Note:\n        Sapphire is a uniaxial crystal with hyperbolic\n        dispersion.\n    \"\"\"\n    super().__init__(\"sapphire\", freq_min, freq_max, mu_r)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial","title":"<code>UniaxialMaterial</code>","text":"<p>               Bases: <code>BaseMaterial</code></p> <p>Base class for anisotropic materials with a single optical axis.</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>class UniaxialMaterial(BaseMaterial):\n    \"\"\"Base class for anisotropic materials with a single optical axis.\"\"\"\n\n    def permittivity_calc_for_freq(\n        self,\n        frequency: float,\n        high_freq: float,\n        omega_tn: np.ndarray,\n        gamma_tn: np.ndarray,\n        omega_ln: np.ndarray,\n        gamma_ln: np.ndarray,\n    ) -&gt; complex:\n        \"\"\"Calculate permittivity at a single frequency using Lorentz oscillator model.\n\n        Args:\n            frequency: Frequency in cm\u207b\u00b9\n            high_freq: High-frequency dielectric constant (\u03b5\u221e)\n            omega_tn: Transverse optical phonon frequencies\n            gamma_tn: Transverse phonon damping constants\n            omega_ln: Longitudinal optical phonon frequencies\n            gamma_ln: Longitudinal phonon damping constants\n\n        Returns:\n            Complex permittivity at the specified frequency\n\n        Note:\n            Uses the factorized form: \u03b5(\u03c9) = \u03b5\u221e \u220f\u1d62 (\u03c9\u2097\u1d62\u00b2 - \u03c9\u00b2 - i\u03c9\u03b3\u2097\u1d62)/(\u03c9\u209c\u1d62\u00b2 - \u03c9\u00b2 - i\u03c9\u03b3\u209c\u1d62)\n        \"\"\"\n        frequency = np.array([frequency], dtype=np.float64)\n\n        # Convert parameters to numpy arrays\n        omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n        gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n        omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n        gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n        # Expand dimensions for broadcasting\n        omega_ln_expanded = omega_ln[:, np.newaxis]\n        gamma_ln_expanded = gamma_ln[:, np.newaxis]\n        omega_tn_expanded = omega_tn[:, np.newaxis]\n        gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n        top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n        bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n        result = top_line / bottom_line\n\n        return (high_freq * np.prod(result, axis=0))[0]\n\n    def permittivity_calc(\n        self,\n        high_freq: float,\n        omega_tn: np.ndarray,\n        gamma_tn: np.ndarray,\n        omega_ln: np.ndarray,\n        gamma_ln: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"Calculate permittivity over full frequency range.\n\n        Args:\n            high_freq: High-frequency dielectric constant\n            omega_tn: Transverse optical phonon frequencies\n            gamma_tn: Transverse phonon damping constants\n            omega_ln: Longitudinal optical phonon frequencies\n            gamma_ln: Longitudinal phonon damping constants\n\n        Returns:\n            Complex permittivity array over all frequencies\n        \"\"\"\n        frequency = np.expand_dims(self.frequency, 0)\n\n        # Convert parameters to numpy arrays\n        omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n        gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n        omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n        gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n        omega_ln_expanded = omega_ln[:, np.newaxis]\n        gamma_ln_expanded = gamma_ln[:, np.newaxis]\n        omega_tn_expanded = omega_tn[:, np.newaxis]\n        gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n        top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n        bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n        result = top_line / bottom_line\n\n        return high_freq * np.prod(result, axis=0)\n\n    def _create_permittivity_tensor(\n        self, eps_ext: complex | np.ndarray, eps_ord: complex | np.ndarray\n    ) -&gt; np.ndarray:\n        \"\"\"Create diagonal permittivity tensor from extraordinary and ordinary values.\n\n        Args:\n            eps_ext: Extraordinary (parallel to optical axis) permittivity\n            eps_ord: Ordinary (perpendicular to optical axis) permittivity\n\n        Returns:\n            Diagonal tensor with [eps_ord, eps_ord, eps_ext] on diagonal\n\n        Note:\n            For uniaxial materials, two components are equal (ordinary) and one\n            is different (extraordinary).\n        \"\"\"\n        if np.isscalar(eps_ext):\n            # Single frequency case\n            return np.diag([eps_ord, eps_ord, eps_ext]).astype(np.complex128)\n        else:\n            # Multiple frequency case\n            diag_tensors = np.stack([eps_ord, eps_ord, eps_ext], axis=-1)\n            # Create diagonal matrices\n            result = np.zeros(diag_tensors.shape[:-1] + (3, 3), dtype=np.complex128)\n            for i in range(result.shape[0]):\n                result[i] = np.diag(diag_tensors[i])\n            return result\n\n    def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n        \"\"\"Fetch full permittivity tensor for all frequencies.\n\n        Returns:\n            Permittivity tensor with shape [N, 3, 3] where N is number of frequencies\n        \"\"\"\n        eps_ext, eps_ord = self.permittivity_fetch()\n        return self._create_permittivity_tensor(eps_ext, eps_ord)\n\n    def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n        \"\"\"Fetch permittivity tensor at specific frequency.\n\n        Args:\n            requested_frequency: Frequency in cm\u207b\u00b9\n\n        Returns:\n            Permittivity tensor with shape [3, 3]\n        \"\"\"\n        params = self.permittivity_parameters()\n        eps_ext = self.permittivity_calc_for_freq(requested_frequency, **params[\"extraordinary\"])\n        eps_ord = self.permittivity_calc_for_freq(requested_frequency, **params[\"ordinary\"])\n        return self._create_permittivity_tensor(eps_ext, eps_ord)\n\n    def permittivity_fetch(self) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Fetch extraordinary and ordinary permittivity values.\n\n        Returns:\n            Tuple of (eps_extraordinary, eps_ordinary) arrays\n        \"\"\"\n        params = self.permittivity_parameters()\n        eps_ext = self.permittivity_calc(**params[\"extraordinary\"])\n        eps_ord = self.permittivity_calc(**params[\"ordinary\"])\n        return eps_ext, eps_ord\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.fetch_permittivity_tensor","title":"<code>fetch_permittivity_tensor()</code>","text":"<p>Fetch full permittivity tensor for all frequencies.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Permittivity tensor with shape [N, 3, 3] where N is number of frequencies</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor(self) -&gt; np.ndarray:\n    \"\"\"Fetch full permittivity tensor for all frequencies.\n\n    Returns:\n        Permittivity tensor with shape [N, 3, 3] where N is number of frequencies\n    \"\"\"\n    eps_ext, eps_ord = self.permittivity_fetch()\n    return self._create_permittivity_tensor(eps_ext, eps_ord)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.fetch_permittivity_tensor_for_freq","title":"<code>fetch_permittivity_tensor_for_freq(requested_frequency)</code>","text":"<p>Fetch permittivity tensor at specific frequency.</p> <p>Parameters:</p> Name Type Description Default <code>requested_frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Permittivity tensor with shape [3, 3]</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def fetch_permittivity_tensor_for_freq(self, requested_frequency: float) -&gt; np.ndarray:\n    \"\"\"Fetch permittivity tensor at specific frequency.\n\n    Args:\n        requested_frequency: Frequency in cm\u207b\u00b9\n\n    Returns:\n        Permittivity tensor with shape [3, 3]\n    \"\"\"\n    params = self.permittivity_parameters()\n    eps_ext = self.permittivity_calc_for_freq(requested_frequency, **params[\"extraordinary\"])\n    eps_ord = self.permittivity_calc_for_freq(requested_frequency, **params[\"ordinary\"])\n    return self._create_permittivity_tensor(eps_ext, eps_ord)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.permittivity_calc","title":"<code>permittivity_calc(high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln)</code>","text":"<p>Calculate permittivity over full frequency range.</p> <p>Parameters:</p> Name Type Description Default <code>high_freq</code> <code>float</code> <p>High-frequency dielectric constant</p> required <code>omega_tn</code> <code>ndarray</code> <p>Transverse optical phonon frequencies</p> required <code>gamma_tn</code> <code>ndarray</code> <p>Transverse phonon damping constants</p> required <code>omega_ln</code> <code>ndarray</code> <p>Longitudinal optical phonon frequencies</p> required <code>gamma_ln</code> <code>ndarray</code> <p>Longitudinal phonon damping constants</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Complex permittivity array over all frequencies</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_calc(\n    self,\n    high_freq: float,\n    omega_tn: np.ndarray,\n    gamma_tn: np.ndarray,\n    omega_ln: np.ndarray,\n    gamma_ln: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Calculate permittivity over full frequency range.\n\n    Args:\n        high_freq: High-frequency dielectric constant\n        omega_tn: Transverse optical phonon frequencies\n        gamma_tn: Transverse phonon damping constants\n        omega_ln: Longitudinal optical phonon frequencies\n        gamma_ln: Longitudinal phonon damping constants\n\n    Returns:\n        Complex permittivity array over all frequencies\n    \"\"\"\n    frequency = np.expand_dims(self.frequency, 0)\n\n    # Convert parameters to numpy arrays\n    omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n    gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n    omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n    gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n    omega_ln_expanded = omega_ln[:, np.newaxis]\n    gamma_ln_expanded = gamma_ln[:, np.newaxis]\n    omega_tn_expanded = omega_tn[:, np.newaxis]\n    gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n    top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n    bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n    result = top_line / bottom_line\n\n    return high_freq * np.prod(result, axis=0)\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.permittivity_calc_for_freq","title":"<code>permittivity_calc_for_freq(frequency, high_freq, omega_tn, gamma_tn, omega_ln, gamma_ln)</code>","text":"<p>Calculate permittivity at a single frequency using Lorentz oscillator model.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency in cm\u207b\u00b9</p> required <code>high_freq</code> <code>float</code> <p>High-frequency dielectric constant (\u03b5\u221e)</p> required <code>omega_tn</code> <code>ndarray</code> <p>Transverse optical phonon frequencies</p> required <code>gamma_tn</code> <code>ndarray</code> <p>Transverse phonon damping constants</p> required <code>omega_ln</code> <code>ndarray</code> <p>Longitudinal optical phonon frequencies</p> required <code>gamma_ln</code> <code>ndarray</code> <p>Longitudinal phonon damping constants</p> required <p>Returns:</p> Type Description <code>complex</code> <p>Complex permittivity at the specified frequency</p> Note <p>Uses the factorized form: \u03b5(\u03c9) = \u03b5\u221e \u220f\u1d62 (\u03c9\u2097\u1d62\u00b2 - \u03c9\u00b2 - i\u03c9\u03b3\u2097\u1d62)/(\u03c9\u209c\u1d62\u00b2 - \u03c9\u00b2 - i\u03c9\u03b3\u209c\u1d62)</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_calc_for_freq(\n    self,\n    frequency: float,\n    high_freq: float,\n    omega_tn: np.ndarray,\n    gamma_tn: np.ndarray,\n    omega_ln: np.ndarray,\n    gamma_ln: np.ndarray,\n) -&gt; complex:\n    \"\"\"Calculate permittivity at a single frequency using Lorentz oscillator model.\n\n    Args:\n        frequency: Frequency in cm\u207b\u00b9\n        high_freq: High-frequency dielectric constant (\u03b5\u221e)\n        omega_tn: Transverse optical phonon frequencies\n        gamma_tn: Transverse phonon damping constants\n        omega_ln: Longitudinal optical phonon frequencies\n        gamma_ln: Longitudinal phonon damping constants\n\n    Returns:\n        Complex permittivity at the specified frequency\n\n    Note:\n        Uses the factorized form: \u03b5(\u03c9) = \u03b5\u221e \u220f\u1d62 (\u03c9\u2097\u1d62\u00b2 - \u03c9\u00b2 - i\u03c9\u03b3\u2097\u1d62)/(\u03c9\u209c\u1d62\u00b2 - \u03c9\u00b2 - i\u03c9\u03b3\u209c\u1d62)\n    \"\"\"\n    frequency = np.array([frequency], dtype=np.float64)\n\n    # Convert parameters to numpy arrays\n    omega_ln = np.asarray(omega_ln, dtype=np.complex128)\n    gamma_ln = np.asarray(gamma_ln, dtype=np.complex128)\n    omega_tn = np.asarray(omega_tn, dtype=np.complex128)\n    gamma_tn = np.asarray(gamma_tn, dtype=np.complex128)\n\n    # Expand dimensions for broadcasting\n    omega_ln_expanded = omega_ln[:, np.newaxis]\n    gamma_ln_expanded = gamma_ln[:, np.newaxis]\n    omega_tn_expanded = omega_tn[:, np.newaxis]\n    gamma_tn_expanded = gamma_tn[:, np.newaxis]\n\n    top_line = omega_ln_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_ln_expanded\n    bottom_line = omega_tn_expanded**2.0 - frequency**2.0 - 1j * frequency * gamma_tn_expanded\n    result = top_line / bottom_line\n\n    return (high_freq * np.prod(result, axis=0))[0]\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.UniaxialMaterial.permittivity_fetch","title":"<code>permittivity_fetch()</code>","text":"<p>Fetch extraordinary and ordinary permittivity values.</p> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Tuple of (eps_extraordinary, eps_ordinary) arrays</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def permittivity_fetch(self) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Fetch extraordinary and ordinary permittivity values.\n\n    Returns:\n        Tuple of (eps_extraordinary, eps_ordinary) arrays\n    \"\"\"\n    params = self.permittivity_parameters()\n    eps_ext = self.permittivity_calc(**params[\"extraordinary\"])\n    eps_ord = self.permittivity_calc(**params[\"ordinary\"])\n    return eps_ext, eps_ord\n</code></pre>"},{"location":"api/materials/#hyperbolic_optics.materials.load_material_parameters","title":"<code>load_material_parameters()</code>","text":"<p>Load material parameters from JSON configuration file.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing all material parameters organized by material type</p> <code>dict[str, Any]</code> <p>(uniaxial, monoclinic, arbitrary, isotropic)</p> Note <p>The configuration file is located at hyperbolic_optics/material_params.json</p> Source code in <code>hyperbolic_optics/materials.py</code> <pre><code>def load_material_parameters() -&gt; dict[str, Any]:\n    \"\"\"Load material parameters from JSON configuration file.\n\n    Returns:\n        Dictionary containing all material parameters organized by material type\n        (uniaxial, monoclinic, arbitrary, isotropic)\n\n    Note:\n        The configuration file is located at hyperbolic_optics/material_params.json\n    \"\"\"\n    config_path = Path(__file__).parent / \"material_params.json\"\n    with open(config_path, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/mueller/","title":"Mueller API","text":""},{"location":"api/mueller/#hyperbolic_optics.mueller","title":"<code>hyperbolic_optics.mueller</code>","text":"<p>Mueller matrix calculus for polarization analysis.</p> <p>This module provides the Mueller class for analyzing polarization transformations in optical systems. Mueller matrices are 4\u00d74 real matrices that describe how Stokes parameters (polarization states) transform upon interaction with optical elements.</p> <p>The Mueller formalism handles: - Arbitrary incident polarization states (linear, circular, elliptical) - Polarization-dependent reflection from anisotropic samples - Ideal optical components (polarizers, wave plates) - Sequential component combinations</p> Key relationships <p>S_out = M \u00b7 S_in (Stokes vector transformation) M = A \u00b7 F \u00b7 A\u207b\u00b9 (Mueller from Jones matrix F)</p> <p>Reference: Chipman, Lam &amp; Young, \"Polarized Light and Optical Systems\" (2018)</p>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller","title":"<code>Mueller</code>","text":"<p>Mueller matrix analyzer for polarization calculations.</p> <p>...existing docstring...</p> <p>Examples:</p> <p>Analyzing p-polarized reflection:</p> <pre><code>&gt;&gt;&gt; structure = Structure()\n&gt;&gt;&gt; structure.execute(payload)\n&gt;&gt;&gt; mueller = Mueller(structure)\n&gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=0)\n&gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n&gt;&gt;&gt; params = mueller.get_all_parameters()\n&gt;&gt;&gt; print(f\"Reflectance: {params['S0']:.4f}\")\n&gt;&gt;&gt; print(f\"DOP: {params['DOP']:.4f}\")\n</code></pre> <p>Crossed polarizer configuration:</p> <pre><code>&gt;&gt;&gt; mueller = Mueller(structure)\n&gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=0)\n&gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 0)\n&gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n&gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 90)\n&gt;&gt;&gt; extinction_ratio = mueller.get_reflectivity()\n</code></pre> <p>Converting linear to circular polarization:</p> <pre><code>&gt;&gt;&gt; mueller = Mueller(structure)\n&gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=45)\n&gt;&gt;&gt; mueller.add_optical_component('quarter_wave_plate', 45)\n&gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n&gt;&gt;&gt; stokes = mueller.get_stokes_parameters()\n&gt;&gt;&gt; circularity = abs(stokes['S3'] / stokes['S0'])\n&gt;&gt;&gt; print(f\"Circular component: {circularity:.2%}\")\n</code></pre> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>class Mueller:\n    \"\"\"Mueller matrix analyzer for polarization calculations.\n\n    ...existing docstring...\n\n    Examples:\n        Analyzing p-polarized reflection:\n\n        &gt;&gt;&gt; structure = Structure()\n        &gt;&gt;&gt; structure.execute(payload)\n        &gt;&gt;&gt; mueller = Mueller(structure)\n        &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=0)\n        &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n        &gt;&gt;&gt; params = mueller.get_all_parameters()\n        &gt;&gt;&gt; print(f\"Reflectance: {params['S0']:.4f}\")\n        &gt;&gt;&gt; print(f\"DOP: {params['DOP']:.4f}\")\n\n        Crossed polarizer configuration:\n\n        &gt;&gt;&gt; mueller = Mueller(structure)\n        &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=0)\n        &gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 0)\n        &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n        &gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 90)\n        &gt;&gt;&gt; extinction_ratio = mueller.get_reflectivity()\n\n        Converting linear to circular polarization:\n\n        &gt;&gt;&gt; mueller = Mueller(structure)\n        &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=45)\n        &gt;&gt;&gt; mueller.add_optical_component('quarter_wave_plate', 45)\n        &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n        &gt;&gt;&gt; stokes = mueller.get_stokes_parameters()\n        &gt;&gt;&gt; circularity = abs(stokes['S3'] / stokes['S0'])\n        &gt;&gt;&gt; print(f\"Circular component: {circularity:.2%}\")\n    \"\"\"\n\n    def __init__(self, structure: Structure, debug: bool = False) -&gt; None:\n        \"\"\"Initialize Mueller matrix analyzer for polarization calculations.\n\n        Args:\n            structure: The Structure object containing reflection coefficients\n            debug: Enable detailed debug output for troubleshooting\n\n        Example:\n            &gt;&gt;&gt; structure = Structure()\n            &gt;&gt;&gt; structure.execute(payload)\n            &gt;&gt;&gt; mueller = Mueller(structure)\n            &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=45)\n            &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n        \"\"\"\n        self.structure = structure\n        self.mueller_matrix = None\n        self.stokes_parameters = None\n        self.incident_stokes = np.array(\n            [1, 0, 0, 0], dtype=np.float64\n        )  # Default to unpolarized light\n        self.optical_components = []\n        self.anisotropic_sample_added = False\n\n    def set_incident_polarization(self, polarization_type: str, **kwargs: Any) -&gt; None:\n        \"\"\"Set the incident polarization state using Stokes parameters.\n\n        Args:\n            polarization_type: Type of polarization ('linear', 'circular', 'elliptical')\n            **kwargs: Additional arguments depending on type:\n                - linear: angle (float) - polarization angle in degrees\n                - circular: handedness (str) - 'right' or 'left'\n                - elliptical: alpha (float) - azimuth in degrees,\n                            ellipticity (float) - ellipticity angle in degrees\n\n        Raises:\n            ValueError: If polarization_type is not recognized\n\n        Example:\n            &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=0)  # p-polarized\n            &gt;&gt;&gt; mueller.set_incident_polarization('circular', handedness='right')\n            &gt;&gt;&gt; mueller.set_incident_polarization('elliptical', alpha=30, ellipticity=20)\n        \"\"\"\n        if polarization_type == \"linear\":\n            angle = kwargs.get(\"angle\", 0)\n            self.incident_stokes = self._linear_polarization(angle)\n        elif polarization_type == \"circular\":\n            handedness = kwargs.get(\"handedness\", \"right\")\n            self.incident_stokes = self._circular_polarization(handedness)\n        elif polarization_type == \"elliptical\":\n            alpha = kwargs.get(\"alpha\", 0)\n            ellipticity = kwargs.get(\"ellipticity\", 0)\n            self.incident_stokes = self._elliptical_polarization(alpha, ellipticity)\n        else:\n            raise ValueError(f\"Unsupported polarization type: {polarization_type}\")\n\n    def _linear_polarization(self, angle: float) -&gt; np.ndarray:\n        \"\"\"Create Stokes vector for linear polarization at specified angle.\n\n        Args:\n            angle: Polarization angle in degrees (0\u00b0 = p-pol, 90\u00b0 = s-pol)\n\n        Returns:\n            Stokes vector [S0, S1, S2, S3] = [1, cos(2\u03b8), sin(2\u03b8), 0]\n\n        Note:\n            Linear polarization has S3 = 0 (no circular component).\n        \"\"\"\n        angle_rad = np.radians(angle)\n        return np.array([1, np.cos(2 * angle_rad), np.sin(2 * angle_rad), 0], dtype=np.float64)\n\n    def _circular_polarization(self, handedness: str) -&gt; np.ndarray:\n        \"\"\"Create Stokes vector for circular polarization.\n\n        Args:\n            handedness: 'right' for right-handed or 'left' for left-handed\n\n        Returns:\n            Stokes vector [S0, S1, S2, S3] = [1, 0, 0, \u00b11]\n\n        Note:\n            Circular polarization has S1 = S2 = 0 and S3 = \u00b11.\n        \"\"\"\n        s3 = 1 if handedness == \"right\" else -1\n        return np.array([1, 0, 0, s3], dtype=np.float64)\n\n    def _elliptical_polarization(self, alpha: float, ellipticity: float) -&gt; np.ndarray:\n        \"\"\"Create Stokes vector for elliptical polarization.\n\n        Args:\n            alpha: Azimuth angle of ellipse major axis in degrees\n            ellipticity: Ellipticity angle in degrees (-45\u00b0 to 45\u00b0)\n\n        Returns:\n            Stokes vector [S0, S1, S2, S3]\n\n        Note:\n            Ellipticity = 0\u00b0 gives linear, \u00b145\u00b0 gives circular polarization.\n        \"\"\"\n        alpha_rad = np.radians(alpha)\n        ellipticity_rad = np.radians(ellipticity)\n        return np.array(\n            [\n                1,\n                np.cos(2 * ellipticity_rad) * np.cos(2 * alpha_rad),\n                np.cos(2 * ellipticity_rad) * np.sin(2 * alpha_rad),\n                np.sin(2 * ellipticity_rad),\n            ],\n            dtype=np.float64,\n        )\n\n    def linear_polarizer(self, angle: float) -&gt; np.ndarray:\n        \"\"\"Create Mueller matrix for ideal linear polarizer.\n\n        Args:\n            angle: Polarizer transmission axis angle in degrees\n\n        Returns:\n            4\u00d74 Mueller matrix for linear polarizer\n\n        Note:\n            Ideal polarizer fully transmits light along transmission axis\n            and fully blocks light perpendicular to it.\n        \"\"\"\n        angle_rad = np.float64(np.radians(angle) * 2.0)\n\n        cos_angle = np.cos(angle_rad)\n        sin_angle = np.sin(angle_rad)\n\n        return 0.5 * np.array(\n            [\n                [1, cos_angle, sin_angle, 0],\n                [cos_angle, cos_angle**2.0, cos_angle * sin_angle, 0],\n                [sin_angle, cos_angle * sin_angle, sin_angle**2.0, 0],\n                [0, 0, 0, 0],\n            ],\n            dtype=np.float64,\n        )\n\n    def quarter_wave_plate(self, angle: float) -&gt; np.ndarray:\n        \"\"\"Create Mueller matrix for quarter-wave plate (QWP).\n\n        Args:\n            angle: Fast axis orientation angle in degrees\n\n        Returns:\n            4\u00d74 Mueller matrix for QWP\n\n        Note:\n            QWP introduces \u03c0/2 phase shift between fast and slow axes.\n            Can convert linear to circular polarization and vice versa.\n        \"\"\"\n        angle_rad = np.float64(np.radians(angle))\n        cos_angle = np.cos(2 * angle_rad)\n        sin_angle = np.sin(2 * angle_rad)\n\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, cos_angle**2, cos_angle * sin_angle, -sin_angle],\n                [0, cos_angle * sin_angle, sin_angle**2, cos_angle],\n                [0, sin_angle, -cos_angle, 0],\n            ],\n            dtype=np.float64,\n        )\n\n    def half_wave_plate(self, angle: float) -&gt; np.ndarray:\n        \"\"\"Create Mueller matrix for half-wave plate (HWP).\n\n        Args:\n            angle: Fast axis orientation angle in degrees\n\n        Returns:\n            4\u00d74 Mueller matrix for HWP\n\n        Note:\n            HWP introduces \u03c0 phase shift, effectively rotating linear\n            polarization by 2\u03b8 where \u03b8 is the plate angle.\n        \"\"\"\n        angle_rad = np.float64(np.radians(angle))\n        cos_angle = np.cos(2 * angle_rad)\n        sin_angle = np.sin(2 * angle_rad)\n\n        return np.array(\n            [\n                [1, 0, 0, 0],\n                [0, cos_angle**2 - sin_angle**2, 2 * cos_angle * sin_angle, 0],\n                [0, 2 * cos_angle * sin_angle, sin_angle**2 - cos_angle**2, 0],\n                [0, 0, 0, -1],\n            ],\n            dtype=np.float64,\n        )\n\n    def calculate_mueller_matrix(self) -&gt; None:\n        \"\"\"Calculate Mueller matrix from reflection coefficients.\n\n        Converts the complex 2\u00d72 Jones matrix to a real 4\u00d74 Mueller matrix\n        using the transformation: M = A\u00b7F\u00b7A\u207b\u00b9 where F is formed from\n        r_pp, r_ss, r_ps, r_sp.\n\n        Note:\n            The Mueller matrix fully describes how the sample transforms\n            arbitrary incident polarization states to reflected states.\n        \"\"\"\n        r_pp = self.structure.r_pp\n        r_ps = self.structure.r_ps\n        r_sp = self.structure.r_sp\n        r_ss = self.structure.r_ss\n\n        f_matrix = np.array(\n            [\n                [\n                    r_pp * np.conj(r_pp),\n                    r_pp * np.conj(r_ps),\n                    r_ps * np.conj(r_pp),\n                    r_ps * np.conj(r_ps),\n                ],\n                [\n                    r_pp * np.conj(r_sp),\n                    r_pp * np.conj(r_ss),\n                    r_ps * np.conj(r_sp),\n                    r_ps * np.conj(r_ss),\n                ],\n                [\n                    r_sp * np.conj(r_pp),\n                    r_sp * np.conj(r_ps),\n                    r_ss * np.conj(r_pp),\n                    r_ss * np.conj(r_ps),\n                ],\n                [\n                    r_sp * np.conj(r_sp),\n                    r_sp * np.conj(r_ss),\n                    r_ss * np.conj(r_sp),\n                    r_ss * np.conj(r_ss),\n                ],\n            ],\n            dtype=np.complex128,\n        )\n\n        # Handle different scenario types\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, f_matrix is just [4, 4], no need to transpose\n            pass\n        else:\n            # For other scenarios, transpose as before\n            f_matrix = np.transpose(f_matrix, axes=[2, 3, 0, 1])\n\n        a_matrix = np.array(\n            [[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, 1j, -1j, 0]],\n            dtype=np.complex128,\n        )\n\n        # Add batch dimensions if needed\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, just compute matrix multiplication directly\n            self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n        else:\n            # For other scenarios, add batch dimensions\n            a_matrix = a_matrix[np.newaxis, np.newaxis, ...]\n            self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n\n    def add_optical_component(self, component_type: str, *args: Any) -&gt; None:\n        \"\"\"Add optical component to the propagation path.\n\n        Args:\n            component_type: Type of component ('anisotropic_sample',\n                        'linear_polarizer', 'quarter_wave_plate',\n                        'half_wave_plate')\n            *args: Component-specific parameters (e.g., angle for polarizers)\n\n        Raises:\n            ValueError: If component type is not recognized or anisotropic\n                    sample is added more than once\n\n        Example:\n            &gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 0)\n            &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n            &gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 90)\n        \"\"\"\n        if component_type == \"linear_polarizer\":\n            self.optical_components.append(self.linear_polarizer(*args))\n        elif component_type == \"anisotropic_sample\":\n            if self.anisotropic_sample_added:\n                raise ValueError(\"Anisotropic sample has already been added\")\n            self.calculate_mueller_matrix()\n            self.optical_components.append(self.mueller_matrix)\n            self.anisotropic_sample_added = True\n        elif component_type == \"quarter_wave_plate\":\n            self.optical_components.append(self.quarter_wave_plate(*args))\n        elif component_type == \"half_wave_plate\":\n            self.optical_components.append(self.half_wave_plate(*args))\n        else:\n            raise ValueError(f\"Unsupported optical component type: {component_type}\")\n\n    def calculate_stokes_parameters(self) -&gt; np.ndarray:\n        \"\"\"Calculate output Stokes parameters after all optical components.\n\n        Propagates the incident Stokes vector through all added optical\n        components by sequential Mueller matrix multiplication.\n\n        Returns:\n            Output Stokes vector [S0, S1, S2, S3] with shape matching scenario\n\n        Note:\n            S0 = total intensity (reflectance)\n            S1 = horizontal vs vertical linear polarization\n            S2 = +45\u00b0 vs -45\u00b0 linear polarization\n            S3 = right vs left circular polarization\n        \"\"\"\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, start with just the incident vector [4,]\n            stokes_vector = self.incident_stokes.reshape([4, 1])\n        else:\n            # For other scenarios, add batch dimensions\n            stokes_vector = self.incident_stokes.reshape([1, 1, 4, 1])\n\n        for i, component in enumerate(self.optical_components):\n            if self.structure.scenario.type == \"Simple\":\n                # For Simple scenario, component should be [4, 4]\n                stokes_vector = component @ stokes_vector\n            else:\n                # For other scenarios, component has batch dimensions\n                stokes_vector = component @ stokes_vector\n\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, remove the last dimension [4, 1] -&gt; [4]\n            self.stokes_parameters = stokes_vector[:, 0]\n        else:\n            # For other scenarios, remove the last dimension [..., 4, 1] -&gt; [..., 4]\n            self.stokes_parameters = stokes_vector[..., 0]\n\n        return self.stokes_parameters\n\n    def get_reflectivity(self) -&gt; np.ndarray:\n        \"\"\"Get total reflectance (S0 Stokes parameter).\n\n        Returns:\n            Reflectance array with shape matching scenario type\n\n        Note:\n            Automatically calculates Stokes parameters if not already computed.\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        return self.stokes_parameters[..., 0]\n\n    def get_degree_of_polarisation(self) -&gt; np.ndarray:\n        \"\"\"Calculate degree of polarization (DOP).\n\n        Returns:\n            DOP array with values clipped to [0, 1]\n\n        Note:\n            DOP = \u221a(S1\u00b2 + S2\u00b2 + S3\u00b2) / S0\n            DOP = 1: fully polarized\n            DOP = 0: unpolarized (random)\n            0 &lt; DOP &lt; 1: partially polarized\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        s0 = self.stokes_parameters[..., 0]\n        s1 = self.stokes_parameters[..., 1]\n        s2 = self.stokes_parameters[..., 2]\n        s3 = self.stokes_parameters[..., 3]\n\n        # Avoid division by zero\n        epsilon = 1e-10\n        s0_safe = np.maximum(s0, epsilon)\n\n        dop = np.sqrt(s1**2 + s2**2 + s3**2) / s0_safe\n\n        # Clip to ensure DOP is always between 0 and 1\n        dop = np.clip(dop, 0.0, 1.0)\n\n        return dop\n\n    def get_ellipticity(self) -&gt; np.ndarray:\n        \"\"\"Calculate ellipticity angle of polarization ellipse.\n\n        Returns:\n            Ellipticity angle in radians (-\u03c0/4 to \u03c0/4)\n\n        Note:\n            Ellipticity = 0: linear polarization\n            Ellipticity = \u00b1\u03c0/4: circular polarization\n            Intermediate values: elliptical polarization\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        s3 = self.stokes_parameters[..., 3]\n        s1 = self.stokes_parameters[..., 1]\n        s2 = self.stokes_parameters[..., 2]\n\n        return 0.5 * np.arctan2(s3, np.sqrt(s1**2 + s2**2))\n\n    def get_azimuth(self) -&gt; np.ndarray:\n        \"\"\"Calculate azimuth angle of polarization ellipse major axis.\n\n        Returns:\n            Azimuth angle in radians\n\n        Note:\n            Defines orientation of the polarization ellipse in the plane\n            perpendicular to propagation direction.\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        s1 = self.stokes_parameters[..., 1]\n        s2 = self.stokes_parameters[..., 2]\n\n        return 0.5 * np.arctan2(s2, s1)\n\n    def get_stokes_parameters(self) -&gt; dict[str, np.ndarray]:\n        \"\"\"Get all four Stokes parameters.\n\n        Returns:\n            Dictionary with keys 'S0', 'S1', 'S2', 'S3' containing parameter arrays\n\n        Note:\n            Automatically calculates if not already computed.\n        \"\"\"\n        if self.stokes_parameters is None:\n            self.calculate_stokes_parameters()\n\n        return {\n            \"S0\": self.stokes_parameters[..., 0],\n            \"S1\": self.stokes_parameters[..., 1],\n            \"S2\": self.stokes_parameters[..., 2],\n            \"S3\": self.stokes_parameters[..., 3],\n        }\n\n    def get_polarisation_parameters(self) -&gt; dict[str, np.ndarray]:\n        \"\"\"Get derived polarization properties.\n\n        Returns:\n            Dictionary with 'DOP', 'Ellipticity', 'Azimuth' arrays\n        \"\"\"\n        return {\n            \"DOP\": self.get_degree_of_polarisation(),\n            \"Ellipticity\": self.get_ellipticity(),\n            \"Azimuth\": self.get_azimuth(),\n        }\n\n    def get_all_parameters(self) -&gt; dict[str, np.ndarray]:\n        \"\"\"Get comprehensive set of all Stokes and polarization parameters.\n\n        Returns:\n            Dictionary containing S0, S1, S2, S3, DOP, Ellipticity, Azimuth\n\n        Example:\n            &gt;&gt;&gt; params = mueller.get_all_parameters()\n            &gt;&gt;&gt; print(f\"Reflectance: {params['S0'].mean():.3f}\")\n            &gt;&gt;&gt; print(f\"Average DOP: {params['DOP'].mean():.3f}\")\n        \"\"\"\n        stokes = self.get_stokes_parameters()\n        polarisation = self.get_polarisation_parameters()\n        all_params = {**stokes, **polarisation}\n\n        return all_params\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset Mueller object to initial state.\n\n        Clears all calculated matrices, Stokes parameters, optical components,\n        and resets incident polarization to unpolarized state.\n\n        Note:\n            Call this before setting up a new calculation sequence.\n        \"\"\"\n        self.mueller_matrix = None\n        self.stokes_parameters = None\n        self.incident_stokes = np.array([1, 0, 0, 0], dtype=np.float64)\n        self.optical_components = []\n        self.anisotropic_sample_added = False\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.__init__","title":"<code>__init__(structure, debug=False)</code>","text":"<p>Initialize Mueller matrix analyzer for polarization calculations.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>The Structure object containing reflection coefficients</p> required <code>debug</code> <code>bool</code> <p>Enable detailed debug output for troubleshooting</p> <code>False</code> Example <p>structure = Structure() structure.execute(payload) mueller = Mueller(structure) mueller.set_incident_polarization('linear', angle=45) mueller.add_optical_component('anisotropic_sample')</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def __init__(self, structure: Structure, debug: bool = False) -&gt; None:\n    \"\"\"Initialize Mueller matrix analyzer for polarization calculations.\n\n    Args:\n        structure: The Structure object containing reflection coefficients\n        debug: Enable detailed debug output for troubleshooting\n\n    Example:\n        &gt;&gt;&gt; structure = Structure()\n        &gt;&gt;&gt; structure.execute(payload)\n        &gt;&gt;&gt; mueller = Mueller(structure)\n        &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=45)\n        &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n    \"\"\"\n    self.structure = structure\n    self.mueller_matrix = None\n    self.stokes_parameters = None\n    self.incident_stokes = np.array(\n        [1, 0, 0, 0], dtype=np.float64\n    )  # Default to unpolarized light\n    self.optical_components = []\n    self.anisotropic_sample_added = False\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.add_optical_component","title":"<code>add_optical_component(component_type, *args)</code>","text":"<p>Add optical component to the propagation path.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>str</code> <p>Type of component ('anisotropic_sample',         'linear_polarizer', 'quarter_wave_plate',         'half_wave_plate')</p> required <code>*args</code> <code>Any</code> <p>Component-specific parameters (e.g., angle for polarizers)</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component type is not recognized or anisotropic     sample is added more than once</p> Example <p>mueller.add_optical_component('linear_polarizer', 0) mueller.add_optical_component('anisotropic_sample') mueller.add_optical_component('linear_polarizer', 90)</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def add_optical_component(self, component_type: str, *args: Any) -&gt; None:\n    \"\"\"Add optical component to the propagation path.\n\n    Args:\n        component_type: Type of component ('anisotropic_sample',\n                    'linear_polarizer', 'quarter_wave_plate',\n                    'half_wave_plate')\n        *args: Component-specific parameters (e.g., angle for polarizers)\n\n    Raises:\n        ValueError: If component type is not recognized or anisotropic\n                sample is added more than once\n\n    Example:\n        &gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 0)\n        &gt;&gt;&gt; mueller.add_optical_component('anisotropic_sample')\n        &gt;&gt;&gt; mueller.add_optical_component('linear_polarizer', 90)\n    \"\"\"\n    if component_type == \"linear_polarizer\":\n        self.optical_components.append(self.linear_polarizer(*args))\n    elif component_type == \"anisotropic_sample\":\n        if self.anisotropic_sample_added:\n            raise ValueError(\"Anisotropic sample has already been added\")\n        self.calculate_mueller_matrix()\n        self.optical_components.append(self.mueller_matrix)\n        self.anisotropic_sample_added = True\n    elif component_type == \"quarter_wave_plate\":\n        self.optical_components.append(self.quarter_wave_plate(*args))\n    elif component_type == \"half_wave_plate\":\n        self.optical_components.append(self.half_wave_plate(*args))\n    else:\n        raise ValueError(f\"Unsupported optical component type: {component_type}\")\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.calculate_mueller_matrix","title":"<code>calculate_mueller_matrix()</code>","text":"<p>Calculate Mueller matrix from reflection coefficients.</p> <p>Converts the complex 2\u00d72 Jones matrix to a real 4\u00d74 Mueller matrix using the transformation: M = A\u00b7F\u00b7A\u207b\u00b9 where F is formed from r_pp, r_ss, r_ps, r_sp.</p> Note <p>The Mueller matrix fully describes how the sample transforms arbitrary incident polarization states to reflected states.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def calculate_mueller_matrix(self) -&gt; None:\n    \"\"\"Calculate Mueller matrix from reflection coefficients.\n\n    Converts the complex 2\u00d72 Jones matrix to a real 4\u00d74 Mueller matrix\n    using the transformation: M = A\u00b7F\u00b7A\u207b\u00b9 where F is formed from\n    r_pp, r_ss, r_ps, r_sp.\n\n    Note:\n        The Mueller matrix fully describes how the sample transforms\n        arbitrary incident polarization states to reflected states.\n    \"\"\"\n    r_pp = self.structure.r_pp\n    r_ps = self.structure.r_ps\n    r_sp = self.structure.r_sp\n    r_ss = self.structure.r_ss\n\n    f_matrix = np.array(\n        [\n            [\n                r_pp * np.conj(r_pp),\n                r_pp * np.conj(r_ps),\n                r_ps * np.conj(r_pp),\n                r_ps * np.conj(r_ps),\n            ],\n            [\n                r_pp * np.conj(r_sp),\n                r_pp * np.conj(r_ss),\n                r_ps * np.conj(r_sp),\n                r_ps * np.conj(r_ss),\n            ],\n            [\n                r_sp * np.conj(r_pp),\n                r_sp * np.conj(r_ps),\n                r_ss * np.conj(r_pp),\n                r_ss * np.conj(r_ps),\n            ],\n            [\n                r_sp * np.conj(r_sp),\n                r_sp * np.conj(r_ss),\n                r_ss * np.conj(r_sp),\n                r_ss * np.conj(r_ss),\n            ],\n        ],\n        dtype=np.complex128,\n    )\n\n    # Handle different scenario types\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, f_matrix is just [4, 4], no need to transpose\n        pass\n    else:\n        # For other scenarios, transpose as before\n        f_matrix = np.transpose(f_matrix, axes=[2, 3, 0, 1])\n\n    a_matrix = np.array(\n        [[1, 0, 0, 1], [1, 0, 0, -1], [0, 1, 1, 0], [0, 1j, -1j, 0]],\n        dtype=np.complex128,\n    )\n\n    # Add batch dimensions if needed\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, just compute matrix multiplication directly\n        self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n    else:\n        # For other scenarios, add batch dimensions\n        a_matrix = a_matrix[np.newaxis, np.newaxis, ...]\n        self.mueller_matrix = (a_matrix @ f_matrix @ np.linalg.inv(a_matrix)).astype(np.float64)\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.calculate_stokes_parameters","title":"<code>calculate_stokes_parameters()</code>","text":"<p>Calculate output Stokes parameters after all optical components.</p> <p>Propagates the incident Stokes vector through all added optical components by sequential Mueller matrix multiplication.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Output Stokes vector [S0, S1, S2, S3] with shape matching scenario</p> Note <p>S0 = total intensity (reflectance) S1 = horizontal vs vertical linear polarization S2 = +45\u00b0 vs -45\u00b0 linear polarization S3 = right vs left circular polarization</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def calculate_stokes_parameters(self) -&gt; np.ndarray:\n    \"\"\"Calculate output Stokes parameters after all optical components.\n\n    Propagates the incident Stokes vector through all added optical\n    components by sequential Mueller matrix multiplication.\n\n    Returns:\n        Output Stokes vector [S0, S1, S2, S3] with shape matching scenario\n\n    Note:\n        S0 = total intensity (reflectance)\n        S1 = horizontal vs vertical linear polarization\n        S2 = +45\u00b0 vs -45\u00b0 linear polarization\n        S3 = right vs left circular polarization\n    \"\"\"\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, start with just the incident vector [4,]\n        stokes_vector = self.incident_stokes.reshape([4, 1])\n    else:\n        # For other scenarios, add batch dimensions\n        stokes_vector = self.incident_stokes.reshape([1, 1, 4, 1])\n\n    for i, component in enumerate(self.optical_components):\n        if self.structure.scenario.type == \"Simple\":\n            # For Simple scenario, component should be [4, 4]\n            stokes_vector = component @ stokes_vector\n        else:\n            # For other scenarios, component has batch dimensions\n            stokes_vector = component @ stokes_vector\n\n    if self.structure.scenario.type == \"Simple\":\n        # For Simple scenario, remove the last dimension [4, 1] -&gt; [4]\n        self.stokes_parameters = stokes_vector[:, 0]\n    else:\n        # For other scenarios, remove the last dimension [..., 4, 1] -&gt; [..., 4]\n        self.stokes_parameters = stokes_vector[..., 0]\n\n    return self.stokes_parameters\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_all_parameters","title":"<code>get_all_parameters()</code>","text":"<p>Get comprehensive set of all Stokes and polarization parameters.</p> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>Dictionary containing S0, S1, S2, S3, DOP, Ellipticity, Azimuth</p> Example <p>params = mueller.get_all_parameters() print(f\"Reflectance: {params['S0'].mean():.3f}\") print(f\"Average DOP: {params['DOP'].mean():.3f}\")</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_all_parameters(self) -&gt; dict[str, np.ndarray]:\n    \"\"\"Get comprehensive set of all Stokes and polarization parameters.\n\n    Returns:\n        Dictionary containing S0, S1, S2, S3, DOP, Ellipticity, Azimuth\n\n    Example:\n        &gt;&gt;&gt; params = mueller.get_all_parameters()\n        &gt;&gt;&gt; print(f\"Reflectance: {params['S0'].mean():.3f}\")\n        &gt;&gt;&gt; print(f\"Average DOP: {params['DOP'].mean():.3f}\")\n    \"\"\"\n    stokes = self.get_stokes_parameters()\n    polarisation = self.get_polarisation_parameters()\n    all_params = {**stokes, **polarisation}\n\n    return all_params\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_azimuth","title":"<code>get_azimuth()</code>","text":"<p>Calculate azimuth angle of polarization ellipse major axis.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth angle in radians</p> Note <p>Defines orientation of the polarization ellipse in the plane perpendicular to propagation direction.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_azimuth(self) -&gt; np.ndarray:\n    \"\"\"Calculate azimuth angle of polarization ellipse major axis.\n\n    Returns:\n        Azimuth angle in radians\n\n    Note:\n        Defines orientation of the polarization ellipse in the plane\n        perpendicular to propagation direction.\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    s1 = self.stokes_parameters[..., 1]\n    s2 = self.stokes_parameters[..., 2]\n\n    return 0.5 * np.arctan2(s2, s1)\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_degree_of_polarisation","title":"<code>get_degree_of_polarisation()</code>","text":"<p>Calculate degree of polarization (DOP).</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>DOP array with values clipped to [0, 1]</p> Note <p>DOP = \u221a(S1\u00b2 + S2\u00b2 + S3\u00b2) / S0 DOP = 1: fully polarized DOP = 0: unpolarized (random) 0 &lt; DOP &lt; 1: partially polarized</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_degree_of_polarisation(self) -&gt; np.ndarray:\n    \"\"\"Calculate degree of polarization (DOP).\n\n    Returns:\n        DOP array with values clipped to [0, 1]\n\n    Note:\n        DOP = \u221a(S1\u00b2 + S2\u00b2 + S3\u00b2) / S0\n        DOP = 1: fully polarized\n        DOP = 0: unpolarized (random)\n        0 &lt; DOP &lt; 1: partially polarized\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    s0 = self.stokes_parameters[..., 0]\n    s1 = self.stokes_parameters[..., 1]\n    s2 = self.stokes_parameters[..., 2]\n    s3 = self.stokes_parameters[..., 3]\n\n    # Avoid division by zero\n    epsilon = 1e-10\n    s0_safe = np.maximum(s0, epsilon)\n\n    dop = np.sqrt(s1**2 + s2**2 + s3**2) / s0_safe\n\n    # Clip to ensure DOP is always between 0 and 1\n    dop = np.clip(dop, 0.0, 1.0)\n\n    return dop\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_ellipticity","title":"<code>get_ellipticity()</code>","text":"<p>Calculate ellipticity angle of polarization ellipse.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Ellipticity angle in radians (-\u03c0/4 to \u03c0/4)</p> Note <p>Ellipticity = 0: linear polarization Ellipticity = \u00b1\u03c0/4: circular polarization Intermediate values: elliptical polarization</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_ellipticity(self) -&gt; np.ndarray:\n    \"\"\"Calculate ellipticity angle of polarization ellipse.\n\n    Returns:\n        Ellipticity angle in radians (-\u03c0/4 to \u03c0/4)\n\n    Note:\n        Ellipticity = 0: linear polarization\n        Ellipticity = \u00b1\u03c0/4: circular polarization\n        Intermediate values: elliptical polarization\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    s3 = self.stokes_parameters[..., 3]\n    s1 = self.stokes_parameters[..., 1]\n    s2 = self.stokes_parameters[..., 2]\n\n    return 0.5 * np.arctan2(s3, np.sqrt(s1**2 + s2**2))\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_polarisation_parameters","title":"<code>get_polarisation_parameters()</code>","text":"<p>Get derived polarization properties.</p> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>Dictionary with 'DOP', 'Ellipticity', 'Azimuth' arrays</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_polarisation_parameters(self) -&gt; dict[str, np.ndarray]:\n    \"\"\"Get derived polarization properties.\n\n    Returns:\n        Dictionary with 'DOP', 'Ellipticity', 'Azimuth' arrays\n    \"\"\"\n    return {\n        \"DOP\": self.get_degree_of_polarisation(),\n        \"Ellipticity\": self.get_ellipticity(),\n        \"Azimuth\": self.get_azimuth(),\n    }\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_reflectivity","title":"<code>get_reflectivity()</code>","text":"<p>Get total reflectance (S0 Stokes parameter).</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Reflectance array with shape matching scenario type</p> Note <p>Automatically calculates Stokes parameters if not already computed.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_reflectivity(self) -&gt; np.ndarray:\n    \"\"\"Get total reflectance (S0 Stokes parameter).\n\n    Returns:\n        Reflectance array with shape matching scenario type\n\n    Note:\n        Automatically calculates Stokes parameters if not already computed.\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    return self.stokes_parameters[..., 0]\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.get_stokes_parameters","title":"<code>get_stokes_parameters()</code>","text":"<p>Get all four Stokes parameters.</p> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>Dictionary with keys 'S0', 'S1', 'S2', 'S3' containing parameter arrays</p> Note <p>Automatically calculates if not already computed.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def get_stokes_parameters(self) -&gt; dict[str, np.ndarray]:\n    \"\"\"Get all four Stokes parameters.\n\n    Returns:\n        Dictionary with keys 'S0', 'S1', 'S2', 'S3' containing parameter arrays\n\n    Note:\n        Automatically calculates if not already computed.\n    \"\"\"\n    if self.stokes_parameters is None:\n        self.calculate_stokes_parameters()\n\n    return {\n        \"S0\": self.stokes_parameters[..., 0],\n        \"S1\": self.stokes_parameters[..., 1],\n        \"S2\": self.stokes_parameters[..., 2],\n        \"S3\": self.stokes_parameters[..., 3],\n    }\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.half_wave_plate","title":"<code>half_wave_plate(angle)</code>","text":"<p>Create Mueller matrix for half-wave plate (HWP).</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Fast axis orientation angle in degrees</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>4\u00d74 Mueller matrix for HWP</p> Note <p>HWP introduces \u03c0 phase shift, effectively rotating linear polarization by 2\u03b8 where \u03b8 is the plate angle.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def half_wave_plate(self, angle: float) -&gt; np.ndarray:\n    \"\"\"Create Mueller matrix for half-wave plate (HWP).\n\n    Args:\n        angle: Fast axis orientation angle in degrees\n\n    Returns:\n        4\u00d74 Mueller matrix for HWP\n\n    Note:\n        HWP introduces \u03c0 phase shift, effectively rotating linear\n        polarization by 2\u03b8 where \u03b8 is the plate angle.\n    \"\"\"\n    angle_rad = np.float64(np.radians(angle))\n    cos_angle = np.cos(2 * angle_rad)\n    sin_angle = np.sin(2 * angle_rad)\n\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, cos_angle**2 - sin_angle**2, 2 * cos_angle * sin_angle, 0],\n            [0, 2 * cos_angle * sin_angle, sin_angle**2 - cos_angle**2, 0],\n            [0, 0, 0, -1],\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.linear_polarizer","title":"<code>linear_polarizer(angle)</code>","text":"<p>Create Mueller matrix for ideal linear polarizer.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Polarizer transmission axis angle in degrees</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>4\u00d74 Mueller matrix for linear polarizer</p> Note <p>Ideal polarizer fully transmits light along transmission axis and fully blocks light perpendicular to it.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def linear_polarizer(self, angle: float) -&gt; np.ndarray:\n    \"\"\"Create Mueller matrix for ideal linear polarizer.\n\n    Args:\n        angle: Polarizer transmission axis angle in degrees\n\n    Returns:\n        4\u00d74 Mueller matrix for linear polarizer\n\n    Note:\n        Ideal polarizer fully transmits light along transmission axis\n        and fully blocks light perpendicular to it.\n    \"\"\"\n    angle_rad = np.float64(np.radians(angle) * 2.0)\n\n    cos_angle = np.cos(angle_rad)\n    sin_angle = np.sin(angle_rad)\n\n    return 0.5 * np.array(\n        [\n            [1, cos_angle, sin_angle, 0],\n            [cos_angle, cos_angle**2.0, cos_angle * sin_angle, 0],\n            [sin_angle, cos_angle * sin_angle, sin_angle**2.0, 0],\n            [0, 0, 0, 0],\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.quarter_wave_plate","title":"<code>quarter_wave_plate(angle)</code>","text":"<p>Create Mueller matrix for quarter-wave plate (QWP).</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Fast axis orientation angle in degrees</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>4\u00d74 Mueller matrix for QWP</p> Note <p>QWP introduces \u03c0/2 phase shift between fast and slow axes. Can convert linear to circular polarization and vice versa.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def quarter_wave_plate(self, angle: float) -&gt; np.ndarray:\n    \"\"\"Create Mueller matrix for quarter-wave plate (QWP).\n\n    Args:\n        angle: Fast axis orientation angle in degrees\n\n    Returns:\n        4\u00d74 Mueller matrix for QWP\n\n    Note:\n        QWP introduces \u03c0/2 phase shift between fast and slow axes.\n        Can convert linear to circular polarization and vice versa.\n    \"\"\"\n    angle_rad = np.float64(np.radians(angle))\n    cos_angle = np.cos(2 * angle_rad)\n    sin_angle = np.sin(2 * angle_rad)\n\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, cos_angle**2, cos_angle * sin_angle, -sin_angle],\n            [0, cos_angle * sin_angle, sin_angle**2, cos_angle],\n            [0, sin_angle, -cos_angle, 0],\n        ],\n        dtype=np.float64,\n    )\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.reset","title":"<code>reset()</code>","text":"<p>Reset Mueller object to initial state.</p> <p>Clears all calculated matrices, Stokes parameters, optical components, and resets incident polarization to unpolarized state.</p> Note <p>Call this before setting up a new calculation sequence.</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset Mueller object to initial state.\n\n    Clears all calculated matrices, Stokes parameters, optical components,\n    and resets incident polarization to unpolarized state.\n\n    Note:\n        Call this before setting up a new calculation sequence.\n    \"\"\"\n    self.mueller_matrix = None\n    self.stokes_parameters = None\n    self.incident_stokes = np.array([1, 0, 0, 0], dtype=np.float64)\n    self.optical_components = []\n    self.anisotropic_sample_added = False\n</code></pre>"},{"location":"api/mueller/#hyperbolic_optics.mueller.Mueller.set_incident_polarization","title":"<code>set_incident_polarization(polarization_type, **kwargs)</code>","text":"<p>Set the incident polarization state using Stokes parameters.</p> <p>Parameters:</p> Name Type Description Default <code>polarization_type</code> <code>str</code> <p>Type of polarization ('linear', 'circular', 'elliptical')</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments depending on type: - linear: angle (float) - polarization angle in degrees - circular: handedness (str) - 'right' or 'left' - elliptical: alpha (float) - azimuth in degrees,             ellipticity (float) - ellipticity angle in degrees</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If polarization_type is not recognized</p> Example <p>mueller.set_incident_polarization('linear', angle=0)  # p-polarized mueller.set_incident_polarization('circular', handedness='right') mueller.set_incident_polarization('elliptical', alpha=30, ellipticity=20)</p> Source code in <code>hyperbolic_optics/mueller.py</code> <pre><code>def set_incident_polarization(self, polarization_type: str, **kwargs: Any) -&gt; None:\n    \"\"\"Set the incident polarization state using Stokes parameters.\n\n    Args:\n        polarization_type: Type of polarization ('linear', 'circular', 'elliptical')\n        **kwargs: Additional arguments depending on type:\n            - linear: angle (float) - polarization angle in degrees\n            - circular: handedness (str) - 'right' or 'left'\n            - elliptical: alpha (float) - azimuth in degrees,\n                        ellipticity (float) - ellipticity angle in degrees\n\n    Raises:\n        ValueError: If polarization_type is not recognized\n\n    Example:\n        &gt;&gt;&gt; mueller.set_incident_polarization('linear', angle=0)  # p-polarized\n        &gt;&gt;&gt; mueller.set_incident_polarization('circular', handedness='right')\n        &gt;&gt;&gt; mueller.set_incident_polarization('elliptical', alpha=30, ellipticity=20)\n    \"\"\"\n    if polarization_type == \"linear\":\n        angle = kwargs.get(\"angle\", 0)\n        self.incident_stokes = self._linear_polarization(angle)\n    elif polarization_type == \"circular\":\n        handedness = kwargs.get(\"handedness\", \"right\")\n        self.incident_stokes = self._circular_polarization(handedness)\n    elif polarization_type == \"elliptical\":\n        alpha = kwargs.get(\"alpha\", 0)\n        ellipticity = kwargs.get(\"ellipticity\", 0)\n        self.incident_stokes = self._elliptical_polarization(alpha, ellipticity)\n    else:\n        raise ValueError(f\"Unsupported polarization type: {polarization_type}\")\n</code></pre>"},{"location":"api/plots/","title":"Plots API","text":""},{"location":"api/plots/#hyperbolic_optics.plots","title":"<code>hyperbolic_optics.plots</code>","text":"<p>Publication-quality plotting functions for simulation results.</p> <p>This module provides plotting utilities for various visualization types: - Material permittivity spectra - Frequency vs incident angle (kx-\u03c9 diagrams) - Frequency vs azimuthal angle (\u03b2-\u03c9 diagrams) - k-space dispersion (kx-ky isofrequency contours) - Stokes parameter distributions - Mueller matrix elements</p> <p>All plots use consistent styling for publication-ready figures with proper axis labels, colorbars, and typography.</p>"},{"location":"api/plots/#hyperbolic_optics.plots.PlotStyle","title":"<code>PlotStyle</code>","text":"<p>Manages consistent plotting styles across all figures.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>class PlotStyle:\n    \"\"\"Manages consistent plotting styles across all figures.\"\"\"\n\n    @staticmethod\n    def initialize() -&gt; None:\n        \"\"\"Initialize global matplotlib parameters for consistent plotting style.\n\n        Sets font family, sizes, tick parameters, and math text rendering\n        for publication-quality plots.\n        \"\"\"\n        plt.rcParams.update(\n            {\n                \"font.family\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n                \"font.size\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                \"axes.labelsize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                \"axes.titlesize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                \"xtick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n                \"ytick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n                \"mathtext.fontset\": \"custom\",\n                \"mathtext.rm\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n                \"mathtext.it\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:italic\",\n                \"mathtext.bf\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:bold\",\n            }\n        )\n\n    @staticmethod\n    def style_axis(ax: plt.Axes, show_labels: bool = True) -&gt; None:\n        \"\"\"Apply consistent styling to matplotlib axis.\n\n        Args:\n            ax: Matplotlib axes object to style\n            show_labels: Whether to show axis labels\n\n        Note:\n            Sets tick width, length, direction, and padding.\n        \"\"\"\n        ax.tick_params(\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n        )\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.PlotStyle.initialize","title":"<code>initialize()</code>  <code>staticmethod</code>","text":"<p>Initialize global matplotlib parameters for consistent plotting style.</p> <p>Sets font family, sizes, tick parameters, and math text rendering for publication-quality plots.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>@staticmethod\ndef initialize() -&gt; None:\n    \"\"\"Initialize global matplotlib parameters for consistent plotting style.\n\n    Sets font family, sizes, tick parameters, and math text rendering\n    for publication-quality plots.\n    \"\"\"\n    plt.rcParams.update(\n        {\n            \"font.family\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n            \"font.size\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            \"axes.labelsize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            \"axes.titlesize\": CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            \"xtick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            \"ytick.labelsize\": CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            \"mathtext.fontset\": \"custom\",\n            \"mathtext.rm\": CONFIG[\"PLOT\"][\"FONT_FAMILY\"],\n            \"mathtext.it\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:italic\",\n            \"mathtext.bf\": f\"{CONFIG['PLOT']['FONT_FAMILY']}:bold\",\n        }\n    )\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.PlotStyle.style_axis","title":"<code>style_axis(ax, show_labels=True)</code>  <code>staticmethod</code>","text":"<p>Apply consistent styling to matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Matplotlib axes object to style</p> required <code>show_labels</code> <code>bool</code> <p>Whether to show axis labels</p> <code>True</code> Note <p>Sets tick width, length, direction, and padding.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>@staticmethod\ndef style_axis(ax: plt.Axes, show_labels: bool = True) -&gt; None:\n    \"\"\"Apply consistent styling to matplotlib axis.\n\n    Args:\n        ax: Matplotlib axes object to style\n        show_labels: Whether to show axis labels\n\n    Note:\n        Sets tick width, length, direction, and padding.\n    \"\"\"\n    ax.tick_params(\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n    )\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_kx_frequency","title":"<code>plot_kx_frequency(structure, param, title=None, rotation_y=None, save_name=None, label='a')</code>","text":"<p>Plot frequency vs parallel wavevector (kx) dispersion diagram.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with incident_angle, frequency, eps_prism</p> required <code>param</code> <code>ndarray</code> <p>2D parameter array [410, 360]</p> required <code>title</code> <code>str | None</code> <p>Optional plot title</p> <code>None</code> <code>rotation_y</code> <code>float | None</code> <p>Optional rotation angle to display in plot</p> <code>None</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving</p> <code>None</code> <code>label</code> <code>str</code> <p>Subplot label</p> <code>'a'</code> Note <p>Shows polariton dispersion with kx/k0 on x-axis and frequency on y-axis. Useful for identifying resonance branches.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_kx_frequency(\n    structure: Structure,\n    param: np.ndarray,\n    title: str | None = None,\n    rotation_y: float | None = None,\n    save_name: str | None = None,\n    label: str = \"a\",\n) -&gt; None:\n    \"\"\"Plot frequency vs parallel wavevector (kx) dispersion diagram.\n\n    Args:\n        structure: Structure object with incident_angle, frequency, eps_prism\n        param: 2D parameter array [410, 360]\n        title: Optional plot title\n        rotation_y: Optional rotation angle to display in plot\n        save_name: Optional filename for saving\n        label: Subplot label\n\n    Note:\n        Shows polariton dispersion with kx/k0 on x-axis and frequency on\n        y-axis. Useful for identifying resonance branches.\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(nrows=1, ncols=1, wspace=0.2, left=0.1, right=0.9, top=0.9, bottom=0.15)\n\n    # Create axis with gridspec\n    ax = fig.add_subplot(gs[0])\n\n    # Calculate kx values from structure properties\n    n_prism = np.sqrt(float(structure.eps_prism))\n    incident_angles = structure.incident_angle\n    kx = n_prism * np.sin(incident_angles)\n    frequency = structure.frequency\n\n    # Create the color plot\n    im = ax.pcolormesh(kx, frequency, param, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Set x-axis limits and generate ticks\n    max_kx = n_prism\n    ax.set_xlim(-max_kx, max_kx)\n\n    # Determine step size based on the range\n    if max_kx &lt; 3:\n        step = 1  # Half-integer steps for small ranges\n    elif max_kx &lt; 8:\n        step = 2  # Integer steps for medium ranges\n    elif max_kx &lt; 15:\n        step = 3  # Steps of 3 for larger ranges\n    else:\n        step = 5  # Steps of 5 for very large ranges\n\n    # Calculate maximum tick value\n    max_tick = (int(max_kx) // step) * step\n\n    # Generate symmetrical ticks around zero\n    positive_ticks = np.arange(0, max_tick + step / 2, step)\n    negative_ticks = -np.arange(step, max_tick + step / 2, step)\n    ticks = np.concatenate([negative_ticks, positive_ticks])\n    ticks = ticks[np.abs(ticks) &lt;= max_kx]\n    ax.set_xticks(ticks)\n\n    # Set y-axis limits\n    ax.set_ylim(frequency[0], frequency[-1])\n\n    # Apply paper-quality tick styling\n    ax.tick_params(\n        labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n        top=False,\n        right=False,\n    )\n\n    # Set axis labels with LaTeX formatting\n    ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n    ax.set_ylabel(\n        r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n        fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n        labelpad=10,\n    )\n\n    # Add subplot label in top left corner\n    ax.text(\n        0.06,\n        0.94,\n        f\"({label})\",\n        transform=ax.transAxes,\n        fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n        va=\"top\",\n        ha=\"left\",\n    )\n\n    # Add rotation angle if provided\n    if rotation_y is not None:\n        ax.text(\n            0.98,\n            0.96,\n            rf\"$\\varphi = {rotation_y}^{{\\circ}}$\",\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            ha=\"right\",\n            va=\"top\",\n        )\n\n    # Add title if provided\n    if title:\n        ax.text(\n            0.5,\n            1.02,\n            title,\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            ha=\"center\",\n        )\n\n    # Set aspect ratio to make plot square\n    ax.set_box_aspect(1)\n\n    # Add custom positioned colorbar\n    pos = ax.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_kx_frequency_pair","title":"<code>plot_kx_frequency_pair(structure, param1, param2, rotation_y1=None, rotation_y2=None, title1=None, title2=None, save_name=None)</code>","text":"<p>Plot two kx-frequency diagrams side-by-side.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with dispersion data</p> required <code>param1</code> <code>ndarray</code> <p>First parameter array</p> required <code>param2</code> <code>ndarray</code> <p>Second parameter array</p> required <code>rotation_y1</code> <code>float | None</code> <p>Rotation angle for first plot</p> <code>None</code> <code>rotation_y2</code> <code>float | None</code> <p>Rotation angle for second plot</p> <code>None</code> <code>title1</code> <code>str | None</code> <p>Title for left panel</p> <code>None</code> <code>title2</code> <code>str | None</code> <p>Title for right panel</p> <code>None</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving</p> <code>None</code> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_kx_frequency_pair(\n    structure: Structure,\n    param1: np.ndarray,\n    param2: np.ndarray,\n    rotation_y1: float | None = None,\n    rotation_y2: float | None = None,\n    title1: str | None = None,\n    title2: str | None = None,\n    save_name: str | None = None,\n) -&gt; None:\n    \"\"\"Plot two kx-frequency diagrams side-by-side.\n\n    Args:\n        structure: Structure object with dispersion data\n        param1: First parameter array\n        param2: Second parameter array\n        rotation_y1: Rotation angle for first plot\n        rotation_y2: Rotation angle for second plot\n        title1: Title for left panel\n        title2: Title for right panel\n        save_name: Optional filename for saving\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=CONFIG[\"PLOT\"][\"FIGURE_SIZE\"])\n    gs = fig.add_gridspec(\n        nrows=1,\n        ncols=2,\n        width_ratios=[1, 1],\n        wspace=0.2,\n        left=0.1,\n        right=0.9,\n        top=0.9,\n        bottom=0.15,\n    )\n\n    # Calculate common data\n    n_prism = np.sqrt(float(structure.eps_prism))\n    incident_angles = structure.incident_angle\n    kx = n_prism * np.sin(incident_angles)\n    frequency = structure.frequency\n    max_kx = n_prism\n\n    # Create first subplot\n    ax1 = fig.add_subplot(gs[0])\n    ax1.pcolormesh(kx, frequency, param1, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Create second subplot\n    ax2 = fig.add_subplot(gs[1], sharey=ax1)\n    im2 = ax2.pcolormesh(kx, frequency, param2, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Style both subplots\n    [rotation_y1, rotation_y2]\n    for idx, (ax, title, rot_y) in enumerate(\n        [(ax1, title1, rotation_y1), (ax2, title2, rotation_y2)]\n    ):\n        # Set limits and generate ticks\n        ax.set_xlim(-max_kx, max_kx)\n\n        # Determine step size\n        if max_kx &lt; 3:\n            step = 0.5\n        elif max_kx &lt; 8:\n            step = 1\n        elif max_kx &lt; 15:\n            step = 3\n        else:\n            step = 5\n\n        max_tick = (int(max_kx) // step) * step\n        positive_ticks = np.arange(0, max_tick + step / 2, step)\n        negative_ticks = -np.arange(step, max_tick + step / 2, step)\n        ticks = np.concatenate([negative_ticks, positive_ticks])\n        ticks = ticks[np.abs(ticks) &lt;= max_kx]\n        ax.set_xticks(ticks)\n\n        ax.set_ylim(frequency[0], frequency[-1])\n\n        # Apply tick styling\n        ax.tick_params(\n            labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n            top=False,\n            right=False,\n        )\n\n        # Set labels\n        ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        if idx == 0:  # Only add ylabel to first subplot\n            ax.set_ylabel(\n                r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                labelpad=10,\n            )\n        else:\n            ax.tick_params(labelleft=False)\n\n        # Add subplot label\n        ax.text(\n            0.06,\n            0.94,\n            f'({[\"a\", \"b\"][idx]})',\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            va=\"top\",\n            ha=\"left\",\n        )\n\n        # Add rotation angle if provided\n        if rot_y is not None:\n            ax.text(\n                0.98,\n                0.96,\n                rf\"$\\varphi = {rot_y}^{{\\circ}}$\",\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n                ha=\"right\",\n                va=\"top\",\n            )\n\n        if title:\n            ax.text(\n                0.5,\n                1.02,\n                title,\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                ha=\"center\",\n            )\n\n        ax.set_box_aspect(1)\n\n    # Add colorbar to the right of the second subplot\n    pos = ax2.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im2, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_azimuthal","title":"<code>plot_mueller_azimuthal(structure, param, title=None, save_name=None, label='a')</code>","text":"<p>Plot frequency vs azimuthal angle with publication styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with azimuthal_angle and frequency arrays</p> required <code>param</code> <code>ndarray</code> <p>2D parameter array to plot (typically reflectivity) [410, 360]</p> required <code>title</code> <code>str | None</code> <p>Optional plot title</p> <code>None</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving (without extension)</p> <code>None</code> <code>label</code> <code>str</code> <p>Subplot label (e.g., 'a', 'b')</p> <code>'a'</code> Note <p>Creates color plot with frequency on y-axis and azimuthal angle (\u03b2) on x-axis, suitable for studying rotational anisotropy.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_azimuthal(\n    structure: Structure,\n    param: np.ndarray,\n    title: str | None = None,\n    save_name: str | None = None,\n    label: str = \"a\",\n) -&gt; None:\n    \"\"\"Plot frequency vs azimuthal angle with publication styling.\n\n    Args:\n        structure: Structure object with azimuthal_angle and frequency arrays\n        param: 2D parameter array to plot (typically reflectivity) [410, 360]\n        title: Optional plot title\n        save_name: Optional filename for saving (without extension)\n        label: Subplot label (e.g., 'a', 'b')\n\n    Note:\n        Creates color plot with frequency on y-axis and azimuthal angle\n        (\u03b2) on x-axis, suitable for studying rotational anisotropy.\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(nrows=1, ncols=1, wspace=0.2, left=0.1, right=0.9, top=0.9, bottom=0.15)\n\n    # Create axis with gridspec\n    ax = fig.add_subplot(gs[0])\n\n    # Calculate axis values\n    x_axis = np.round(np.degrees(structure.azimuthal_angle), 1)\n    frequency = structure.frequency\n\n    # Create the color plot using pcolormesh\n    im = ax.pcolormesh(x_axis, frequency, param, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Set axis limits and ticks\n    ax.set_xlim(0, 360)\n    ax.set_xticks([0, 90, 180, 270, 360])\n    ax.set_ylim(frequency[0], frequency[-1])\n\n    # Apply paper-quality tick styling\n    ax.tick_params(\n        labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n        top=False,\n        right=False,\n    )\n\n    # Set axis labels with LaTeX formatting\n    ax.set_xlabel(r\"$\\beta$ (degree)\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n    ax.set_ylabel(\n        r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n        fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n        labelpad=10,\n    )\n\n    # Add subplot label in top left corner\n    ax.text(\n        0.06,\n        0.94,\n        f\"({label})\",\n        transform=ax.transAxes,\n        fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n        va=\"top\",\n        ha=\"left\",\n    )\n\n    # Add title if provided\n    if title:\n        ax.text(\n            0.5,\n            1.02,\n            title,\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            ha=\"center\",\n        )\n\n    # Set aspect ratio to make plot square\n    ax.set_box_aspect(1)\n\n    # Add custom positioned colorbar\n    pos = ax.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save the plot if a filename is provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_azimuthal_pair","title":"<code>plot_mueller_azimuthal_pair(structure, param1, param2, title1=None, title2=None, save_name=None)</code>","text":"<p>Plot two azimuthal plots side-by-side for comparison.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with angle and frequency data</p> required <code>param1</code> <code>ndarray</code> <p>First parameter array [410, 360]</p> required <code>param2</code> <code>ndarray</code> <p>Second parameter array [410, 360]</p> required <code>title1</code> <code>str | None</code> <p>Title for left panel</p> <code>None</code> <code>title2</code> <code>str | None</code> <p>Title for right panel</p> <code>None</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving</p> <code>None</code> Note <p>Useful for comparing different polarizations or materials.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_azimuthal_pair(\n    structure: Structure,\n    param1: np.ndarray,\n    param2: np.ndarray,\n    title1: str | None = None,\n    title2: str | None = None,\n    save_name: str | None = None,\n) -&gt; None:\n    \"\"\"Plot two azimuthal plots side-by-side for comparison.\n\n    Args:\n        structure: Structure object with angle and frequency data\n        param1: First parameter array [410, 360]\n        param2: Second parameter array [410, 360]\n        title1: Title for left panel\n        title2: Title for right panel\n        save_name: Optional filename for saving\n\n    Note:\n        Useful for comparing different polarizations or materials.\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=CONFIG[\"PLOT\"][\"FIGURE_SIZE\"])\n    gs = fig.add_gridspec(\n        nrows=1,\n        ncols=2,\n        width_ratios=[1, 1],\n        wspace=0.2,\n        left=0.1,\n        right=0.9,\n        top=0.9,\n        bottom=0.15,\n    )\n\n    # Create first subplot\n    ax1 = fig.add_subplot(gs[0])\n    x_axis = np.round(np.degrees(structure.azimuthal_angle), 1)\n    frequency = structure.frequency\n\n    ax1.pcolormesh(x_axis, frequency, param1, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Create second subplot\n    ax2 = fig.add_subplot(gs[1], sharey=ax1)\n    im2 = ax2.pcolormesh(x_axis, frequency, param2, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Style both subplots\n    for idx, (ax, title) in enumerate([(ax1, title1), (ax2, title2)]):\n        ax.set_xlim(0, 360)\n        ax.set_xticks([0, 90, 180, 270, 360])\n        ax.set_ylim(frequency[0], frequency[-1])\n\n        ax.tick_params(\n            labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n            top=False,\n            right=False,\n        )\n\n        ax.set_xlabel(r\"$\\beta$ (degree)\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        if idx == 0:  # Only add ylabel to first subplot\n            ax.set_ylabel(\n                r\"$\\omega/2\\pi c$ (cm$^{-1}$)\",\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                labelpad=10,\n            )\n        else:\n            ax.tick_params(labelleft=False)\n\n        # Add subplot label\n        ax.text(\n            0.06,\n            0.94,\n            f'({[\"a\", \"b\"][idx]})',\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            va=\"top\",\n            ha=\"left\",\n        )\n\n        if title:\n            ax.text(\n                0.5,\n                1.02,\n                title,\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                ha=\"center\",\n            )\n\n        ax.set_box_aspect(1)\n\n    # Add colorbar to the right of the second subplot\n    pos = ax2.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im2, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save the plot if a filename is provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_dispersion","title":"<code>plot_mueller_dispersion(structure, param, title=None, rotation_y=None, save_name=None, label='a')</code>","text":"<p>Plot k-space dispersion in kx-ky coordinates at fixed frequency.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with incident_angle, azimuthal_angle arrays</p> required <code>param</code> <code>ndarray</code> <p>2D parameter array [180, 480]</p> required <code>title</code> <code>str | None</code> <p>Optional plot title</p> <code>None</code> <code>rotation_y</code> <code>float | None</code> <p>Optional rotation angle to display</p> <code>None</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving</p> <code>None</code> <code>label</code> <code>str</code> <p>Subplot label</p> <code>'a'</code> Note <p>Shows isofrequency contours in momentum space. The unit circle indicates the light cone (k = k0). Features outside indicate evanescent modes.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_dispersion(\n    structure: Structure,\n    param: np.ndarray,\n    title: str | None = None,\n    rotation_y: float | None = None,\n    save_name: str | None = None,\n    label: str = \"a\",\n) -&gt; None:\n    \"\"\"Plot k-space dispersion in kx-ky coordinates at fixed frequency.\n\n    Args:\n        structure: Structure object with incident_angle, azimuthal_angle arrays\n        param: 2D parameter array [180, 480]\n        title: Optional plot title\n        rotation_y: Optional rotation angle to display\n        save_name: Optional filename for saving\n        label: Subplot label\n\n    Note:\n        Shows isofrequency contours in momentum space. The unit circle\n        indicates the light cone (k = k0). Features outside indicate\n        evanescent modes.\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(nrows=1, ncols=1, wspace=0.2, left=0.1, right=0.9, top=0.9, bottom=0.15)\n\n    # Create axis with gridspec\n    ax = fig.add_subplot(gs[0])\n\n    # Calculate k-space coordinates\n    incident_angle = structure.incident_angle\n    z_rotation = structure.azimuthal_angle\n    max_k = np.sqrt(float(structure.eps_prism))  # Maximum k value from prism\n\n    # Create meshgrid for incident angle and z-rotation\n    incident_angle, z_rotation = np.meshgrid(incident_angle, z_rotation)\n\n    # Convert polar coordinates to Cartesian (kx, ky)\n    kx = max_k * np.sin(incident_angle) * np.cos(z_rotation)\n    ky = max_k * np.sin(incident_angle) * np.sin(z_rotation)\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"The input coordinates to pcolormesh\")\n        im = ax.pcolormesh(kx, ky, param.T, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Set plot limits and aspect ratio\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(-max_k * 1.1, max_k * 1.1)\n    ax.set_ylim(-max_k * 1.1, max_k * 1.1)\n\n    # Determine step size based on the range (same logic as plot_kx_frequency)\n    if max_k &lt; 3:\n        step = 1  # Integer steps for small ranges\n    elif max_k &lt; 8:\n        step = 2  # Steps of 2 for medium ranges\n    elif max_k &lt; 15:\n        step = 3  # Steps of 3 for larger ranges\n    else:\n        step = 5  # Steps of 5 for very large ranges\n\n    # Calculate maximum tick value\n    max_tick = (int(max_k) // step) * step\n\n    # Generate symmetrical ticks around zero\n    positive_ticks = np.arange(0, max_tick + step / 2, step)\n    negative_ticks = -np.arange(step, max_tick + step / 2, step)\n    ticks = np.concatenate([negative_ticks, positive_ticks])\n    ticks = ticks[np.abs(ticks) &lt;= max_k]\n\n    ax.set_xticks(ticks)\n    ax.set_yticks(ticks)\n\n    # Apply paper-quality tick styling\n    ax.tick_params(\n        labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n        width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n        length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n        direction=\"in\",\n        pad=5,\n        top=False,\n        right=False,\n    )\n\n    # Set axis labels with LaTeX formatting\n    ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n    ax.set_ylabel(r\"$k_y/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n\n    # Add subplot label in top left corner\n    ax.text(\n        0.06,\n        0.94,\n        f\"({label})\",\n        transform=ax.transAxes,\n        fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n        va=\"top\",\n        ha=\"left\",\n    )\n\n    # Add rotation angle if provided\n    if rotation_y is not None:\n        ax.text(\n            0.98,\n            0.96,\n            rf\"$\\varphi = {rotation_y}^{{\\circ}}$\",\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            ha=\"right\",\n            va=\"top\",\n        )\n\n    # Add title if provided\n    if title:\n        ax.text(\n            0.5,\n            1.02,\n            title,\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n            ha=\"center\",\n        )\n\n    # Add unit circle to indicate light cone\n    circle = plt.Circle((0, 0), 1, fill=False, color=\"white\", linestyle=\"-\", linewidth=1.5)\n    ax.add_patch(circle)\n\n    # Set aspect ratio to make plot square\n    ax.set_box_aspect(1)\n\n    # Add custom positioned colorbar\n    pos = ax.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_mueller_dispersion_pair","title":"<code>plot_mueller_dispersion_pair(structure, param1, param2, rotation_y1=None, rotation_y2=None, title1=None, title2=None, save_name=None)</code>","text":"<p>Plot two k-space dispersion diagrams side-by-side.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with dispersion data</p> required <code>param1</code> <code>ndarray</code> <p>First parameter array [180, 480]</p> required <code>param2</code> <code>ndarray</code> <p>Second parameter array [180, 480]</p> required <code>rotation_y1</code> <code>float | None</code> <p>Rotation angle for first plot</p> <code>None</code> <code>rotation_y2</code> <code>float | None</code> <p>Rotation angle for second plot</p> <code>None</code> <code>title1</code> <code>str | None</code> <p>Title for left panel</p> <code>None</code> <code>title2</code> <code>str | None</code> <p>Title for right panel</p> <code>None</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving</p> <code>None</code> Note <p>Both plots share colorbar and have unit circles indicating light cone boundaries.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_mueller_dispersion_pair(\n    structure: Structure,\n    param1: np.ndarray,\n    param2: np.ndarray,\n    rotation_y1: float | None = None,\n    rotation_y2: float | None = None,\n    title1: str | None = None,\n    title2: str | None = None,\n    save_name: str | None = None,\n) -&gt; None:\n    \"\"\"Plot two k-space dispersion diagrams side-by-side.\n\n    Args:\n        structure: Structure object with dispersion data\n        param1: First parameter array [180, 480]\n        param2: Second parameter array [180, 480]\n        rotation_y1: Rotation angle for first plot\n        rotation_y2: Rotation angle for second plot\n        title1: Title for left panel\n        title2: Title for right panel\n        save_name: Optional filename for saving\n\n    Note:\n        Both plots share colorbar and have unit circles indicating\n        light cone boundaries.\n    \"\"\"\n    PlotStyle.initialize()\n\n    # Create figure with gridspec for precise layout control\n    fig = plt.figure(figsize=(10, 5))\n    gs = fig.add_gridspec(\n        nrows=1,\n        ncols=2,\n        width_ratios=[1, 1],\n        wspace=0.2,\n        left=0.1,\n        right=0.9,\n        top=0.9,\n        bottom=0.15,\n    )\n\n    # Calculate common k-space coordinates\n    incident_angle = structure.incident_angle\n    z_rotation = structure.azimuthal_angle\n    max_k = np.sqrt(float(structure.eps_prism))\n\n    incident_angle, z_rotation = np.meshgrid(incident_angle, z_rotation)\n    kx = max_k * np.sin(incident_angle) * np.cos(z_rotation)\n    ky = max_k * np.sin(incident_angle) * np.sin(z_rotation)\n\n    # Create first subplot\n    ax1 = fig.add_subplot(gs[0])\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"The input coordinates to pcolormesh\")\n        ax1.pcolormesh(kx, ky, param1.T, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Create second subplot\n    ax2 = fig.add_subplot(gs[1], sharey=ax1)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"The input coordinates to pcolormesh\")\n        im2 = ax2.pcolormesh(kx, ky, param2.T, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"], vmin=0, vmax=1)\n\n    # Style both subplots\n    for idx, (ax, title, rot_y) in enumerate(\n        [(ax1, title1, rotation_y1), (ax2, title2, rotation_y2)]\n    ):\n        # Set plot limits and aspect ratio\n        ax.set_aspect(\"equal\")\n        ax.set_xlim(-max_k * 1.05, max_k * 1.05)\n        ax.set_ylim(-max_k * 1.05, max_k * 1.05)\n\n        # Set ticks based on max_k\n        if max_k &lt; 3:\n            tick_spacing = 1\n        elif max_k &lt; 6:\n            tick_spacing = 2\n        else:\n            tick_spacing = 3\n\n        # Generate negative ticks (going backwards from 0)\n        neg_ticks = np.arange(0, -int(max_k) - 1, -tick_spacing)\n        # Generate positive ticks (going forwards from 0)\n        pos_ticks = np.arange(0, int(max_k) + 1, tick_spacing)\n        # Combine them, excluding the duplicate 0\n        ticks = np.concatenate([neg_ticks[1:], pos_ticks])\n\n        ax.set_xticks(ticks)\n        ax.set_yticks(ticks)\n\n        # Apply tick styling\n        ax.tick_params(\n            labelsize=CONFIG[\"PLOT\"][\"TICK_SIZE\"],\n            width=CONFIG[\"PLOT\"][\"TICK_WIDTH\"],\n            length=CONFIG[\"PLOT\"][\"TICK_LENGTH\"],\n            direction=\"in\",\n            pad=5,\n            top=False,\n            right=False,\n        )\n\n        # Set labels\n        ax.set_xlabel(r\"$k_x/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        if idx == 0:  # Only add ylabel to first subplot\n            ax.set_ylabel(r\"$k_y/k_0$\", fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"], labelpad=10)\n        else:\n            ax.tick_params(labelleft=False)\n\n        # Add subplot label\n        ax.text(\n            0.06,\n            0.94,\n            f'({[\"a\", \"b\"][idx]})',\n            transform=ax.transAxes,\n            fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n            va=\"top\",\n            ha=\"left\",\n        )\n\n        # Add rotation angle if provided\n        if rot_y is not None:\n            ax.text(\n                0.98,\n                0.96,\n                rf\"$\\varphi = {rot_y}^{{\\circ}}$\",\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"TEXT_SIZE\"],\n                ha=\"right\",\n                va=\"top\",\n            )\n\n        if title:\n            ax.text(\n                0.5,\n                1.02,\n                title,\n                transform=ax.transAxes,\n                fontsize=CONFIG[\"PLOT\"][\"LABEL_SIZE\"],\n                ha=\"center\",\n            )\n\n        # Add unit circle\n        circle = plt.Circle((0, 0), 1, fill=False, color=\"white\", linestyle=\"-\", linewidth=1.5)\n        ax.add_patch(circle)\n\n        ax.set_box_aspect(1)\n\n    # Add colorbar to the right of the second subplot\n    pos = ax2.get_position()\n    cbar_ax = fig.add_axes([pos.x1 + 0.01, pos.y0 + 0.12, 0.01, pos.height * 0.8])\n\n    cbar = fig.colorbar(im2, cax=cbar_ax, shrink=0.8, aspect=2, ticks=[0, 0.5, 1])\n    cbar.set_label(\"Reflectance\", size=16)\n    cbar.ax.yaxis.set_tick_params(\n        labelsize=14, width=0, length=0, direction=\"in\", right=True, left=True, top=True\n    )\n\n    # Save plot if filename provided\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n            pad_inches=0.1,\n        )\n\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_permittivity","title":"<code>plot_permittivity(material, eps_ext, eps_ord, save_name=None)</code>","text":"<p>Plot real and imaginary parts of permittivity spectra.</p> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>BaseMaterial</code> <p>Material object containing frequency array</p> required <code>eps_ext</code> <code>ndarray</code> <p>Extraordinary permittivity (parallel to optical axis)</p> required <code>eps_ord</code> <code>ndarray</code> <p>Ordinary permittivity (perpendicular to optical axis)</p> required <code>save_name</code> <code>str | None</code> <p>Optional filename for saving (without extension)</p> <code>None</code> Note <p>Creates two-panel plot with Re(\u03b5) and Im(\u03b5) vs frequency.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_permittivity(\n    material: BaseMaterial, eps_ext: np.ndarray, eps_ord: np.ndarray, save_name: str | None = None\n) -&gt; None:\n    \"\"\"Plot real and imaginary parts of permittivity spectra.\n\n    Args:\n        material: Material object containing frequency array\n        eps_ext: Extraordinary permittivity (parallel to optical axis)\n        eps_ord: Ordinary permittivity (perpendicular to optical axis)\n        save_name: Optional filename for saving (without extension)\n\n    Note:\n        Creates two-panel plot with Re(\u03b5) and Im(\u03b5) vs frequency.\n    \"\"\"\n    PlotStyle.initialize()\n\n    fig, axs = plt.subplots(2, figsize=(9, 7), sharex=True, gridspec_kw={\"hspace\": 0.1})\n\n    # Plot real part\n    axs[0].plot(\n        material.frequency,\n        eps_ext.real,\n        label=r\"$\\mathrm{Re}(\\varepsilon_\\mathrm{ext})$\",\n    )\n    axs[0].plot(\n        material.frequency,\n        eps_ord.real,\n        label=r\"$\\mathrm{Re}(\\varepsilon_\\mathrm{ord})$\",\n    )\n    axs[0].axhline(y=0, color=\"black\", linewidth=1)\n    axs[0].set(ylabel=r\"$\\mathrm{Re}(\\epsilon)$\")\n    axs[0].legend()\n    PlotStyle.style_axis(axs[0])\n\n    # Plot imaginary part\n    axs[1].plot(\n        material.frequency,\n        eps_ext.imag,\n        label=r\"$\\mathrm{Im}(\\varepsilon_\\mathrm{ext})$\",\n    )\n    axs[1].plot(\n        material.frequency,\n        eps_ord.imag,\n        label=r\"$\\mathrm{Im}(\\varepsilon_\\mathrm{ord})$\",\n    )\n    axs[1].set(xlabel=r\"Wavenumber (cm$^{-1}$)\", ylabel=r\"$\\mathrm{Im}(\\epsilon)$\")\n    axs[1].set_xlim(material.frequency[0], material.frequency[-1])\n    axs[1].set_ylim(\n        0,\n    )\n    axs[1].legend()\n    PlotStyle.style_axis(axs[1])\n\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n        )\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/plots/#hyperbolic_optics.plots.plot_stokes_parameters","title":"<code>plot_stokes_parameters(structure, params, plot_type='incidence', save_name=None)</code>","text":"<p>Plot all Stokes parameters and DOP in 2\u00d73 grid.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Structure object with angle and frequency arrays</p> required <code>params</code> <code>dict[str, ndarray]</code> <p>Dictionary with S0, S1, S2, S3, DOP, Ellipticity keys</p> required <code>plot_type</code> <code>str</code> <p>'incidence' or 'azimuthal' to determine x-axis</p> <code>'incidence'</code> <code>save_name</code> <code>str | None</code> <p>Optional filename for saving</p> <code>None</code> Note <p>Creates comprehensive visualization of complete polarization state across parameter space.</p> Source code in <code>hyperbolic_optics/plots.py</code> <pre><code>def plot_stokes_parameters(\n    structure: Structure,\n    params: dict[str, np.ndarray],\n    plot_type: str = \"incidence\",\n    save_name: str | None = None,\n) -&gt; None:\n    \"\"\"Plot all Stokes parameters and DOP in 2\u00d73 grid.\n\n    Args:\n        structure: Structure object with angle and frequency arrays\n        params: Dictionary with S0, S1, S2, S3, DOP, Ellipticity keys\n        plot_type: 'incidence' or 'azimuthal' to determine x-axis\n        save_name: Optional filename for saving\n\n    Note:\n        Creates comprehensive visualization of complete polarization state\n        across parameter space.\n    \"\"\"\n    PlotStyle.initialize()\n\n    fig, ax = plt.subplots(2, 3, figsize=(18, 12))\n\n    ax_to_plot = [\n        (params[\"S0\"], \"S0\", 0, 0),\n        (params[\"S1\"], \"S1\", 0, 1),\n        (params[\"S2\"], \"S2\", 0, 2),\n        (params[\"S3\"], \"S3\", 1, 0),\n        (params[\"DOP\"], \"DOP\", 1, 1),\n        (params[\"Ellipticity\"], \"Ellipticity\", 1, 2),\n    ]\n\n    if plot_type == \"incidence\":\n        x_axis = np.round(np.degrees(structure.incident_angle), 1)\n        xlabel = r\"Incident Angle / $^\\circ$\"\n    else:  # azimuthal\n        x_axis = np.round(np.degrees(structure.azimuthal_angle), 1)\n        xlabel = r\"Azimuthal Rotation / $^\\circ$\"\n\n    frequency = structure.frequency\n\n    for data, title, row, col in ax_to_plot:\n        im = ax[row, col].pcolormesh(x_axis, frequency, data, cmap=CONFIG[\"PLOT\"][\"COLORMAP\"])\n        cbar = plt.colorbar(im, ax=ax[row, col])\n        cbar.set_label(title, size=CONFIG[\"PLOT\"][\"LABEL_SIZE\"])\n        ax[row, col].set_title(title, size=CONFIG[\"PLOT\"][\"LABEL_SIZE\"])\n        ax[row, col].set_xlabel(xlabel)\n        ax[row, col].set_ylabel(r\"$\\omega/2\\pi c$ (cm$^{-1}$)\")\n        PlotStyle.style_axis(ax[row, col])\n\n    plt.tight_layout()\n\n    if save_name:\n        CONFIG[\"PLOT\"][\"SAVE_PATH\"].mkdir(exist_ok=True)\n        plt.savefig(\n            CONFIG[\"PLOT\"][\"SAVE_PATH\"] / f\"{save_name}.png\",\n            dpi=CONFIG[\"PLOT\"][\"DPI\"],\n            bbox_inches=\"tight\",\n        )\n    plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/scenario/","title":"Scenario API","text":""},{"location":"api/scenario/#hyperbolic_optics.scenario","title":"<code>hyperbolic_optics.scenario</code>","text":"<p>Simulation scenario configuration and setup.</p> <p>This module defines four scenario types for different analysis needs:</p> <ol> <li>Simple: Single-point calculation (scalar angles and frequency)</li> <li>Incident: Angle sweep at multiple frequencies (kx-\u03c9 plots)</li> <li>Azimuthal: Sample rotation at fixed incident angle (\u03b2-\u03c9 plots)</li> <li>Dispersion: k-space map at fixed frequency (kx-ky plots)</li> </ol> <p>Each scenario type automatically sets up appropriate angle and frequency arrays with correct dimensions for batch processing.</p>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup","title":"<code>ScenarioSetup</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for a scenario setup</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>class ScenarioSetup(ABC):\n    \"\"\"\n    Abstract class for a scenario setup\n    \"\"\"\n\n    def __init__(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Initialize scenario configuration for simulation.\n\n        Args:\n            data: Dictionary with 'type' and scenario-specific parameters\n\n        Raises:\n            NotImplementedError: If scenario type is not recognized\n\n        Example:\n            &gt;&gt;&gt; data = {\"type\": \"Simple\", \"incidentAngle\": 45.0,\n            ...         \"azimuthal_angle\": 0.0, \"frequency\": 1460.0}\n            &gt;&gt;&gt; scenario = ScenarioSetup(data)\n        \"\"\"\n        self.type = data.get(\"type\")\n        self.incident_angle = data.get(\"incidentAngle\", None)\n        self.azimuthal_angle = data.get(\"azimuthal_angle\", None)\n        self.frequency = data.get(\"frequency\", None)\n        self.create_scenario()\n\n    def create_scenario(self) -&gt; None:\n        \"\"\"Create scenario-specific angle and frequency arrays.\n\n        Dispatches to appropriate scenario creation method based on type.\n\n        Raises:\n            NotImplementedError: If scenario type is not implemented\n        \"\"\"\n        if self.type == \"Incident\":\n            self.create_incident_scenario()\n        elif self.type == \"Azimuthal\":\n            self.create_azimuthal_scenario()\n        elif self.type == \"Dispersion\":\n            self.create_dispersion_scenario()\n        elif self.type == \"Simple\":\n            self.create_simple_scenario()\n        else:\n            raise NotImplementedError(f\"Scenario type {self.type} not implemented\")\n\n    def create_incident_scenario(self) -&gt; None:\n        \"\"\"Create incident angle sweep scenario.\n\n        Sets up 360 incident angles from -\u03c0/2 to \u03c0/2 for analyzing angle-dependent\n        reflectivity across the material's frequency range.\n\n        Note:\n            Frequency range is determined by the material in the final layer.\n            Creates arrays suitable for generating kx vs frequency plots.\n        \"\"\"\n\n        self.incident_angle = np.linspace(\n            -m.pi / 2.0 + 1.0e-9, m.pi / 2.0 - 1.0e-9, 360, dtype=np.float64\n        )\n\n    def create_azimuthal_scenario(self) -&gt; None:\n        \"\"\"Create azimuthal rotation scenario at fixed incident angle.\n\n        Rotates the sample through 360 azimuthal angles (0 to 2\u03c0) while\n        maintaining constant incident angle.\n\n        Note:\n            Useful for studying in-plane anisotropy and rotational symmetry.\n            incidentAngle must be provided in input data.\n        \"\"\"\n        self.incident_angle = np.float64(m.radians(self.incident_angle))\n        self.azimuthal_angle = np.linspace(\n            0.0 + 1.0e-15, 2.0 * m.pi - 1.0e-15, 360, dtype=np.float64\n        )\n\n    def create_dispersion_scenario(self) -&gt; None:\n        \"\"\"Create k-space dispersion scenario at fixed frequency.\n\n        Sets up grid of incident angles (180 points) and azimuthal angles\n        (480 points) for mapping isofrequency contours in kx-ky space.\n\n        Note:\n            Requires 'frequency' to be specified in input data.\n            Generates data for kx vs ky momentum-space plots.\n        \"\"\"\n        self.incident_angle = np.linspace(0.0 + 1.0e-8, m.pi / 2.0 - 1.0e-8, 180, dtype=np.float64)\n\n        self.azimuthal_angle = np.linspace(1.0e-5, 2.0 * m.pi - 1.0e-5, 480, dtype=np.float64)\n\n        self.frequency = float(self.frequency)\n\n    def create_simple_scenario(self) -&gt; None:\n        \"\"\"Create single-point scenario with scalar values.\n\n        Converts incident angle, azimuthal angle, and frequency to scalar\n        values for quick single-point calculations.\n\n        Note:\n            All three parameters (incidentAngle, azimuthal_angle, frequency)\n            must be provided in input data.\n        \"\"\"\n        # Convert to scalar values for consistency\n        self.incident_angle = np.float64(m.radians(self.incident_angle) + 1.0e-15)\n        self.azimuthal_angle = np.float64(m.radians(self.azimuthal_angle) + 1.0e-15)\n        self.frequency = float(self.frequency)\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.__init__","title":"<code>__init__(data)</code>","text":"<p>Initialize scenario configuration for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary with 'type' and scenario-specific parameters</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If scenario type is not recognized</p> Example <p>data = {\"type\": \"Simple\", \"incidentAngle\": 45.0, ...         \"azimuthal_angle\": 0.0, \"frequency\": 1460.0} scenario = ScenarioSetup(data)</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def __init__(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"Initialize scenario configuration for simulation.\n\n    Args:\n        data: Dictionary with 'type' and scenario-specific parameters\n\n    Raises:\n        NotImplementedError: If scenario type is not recognized\n\n    Example:\n        &gt;&gt;&gt; data = {\"type\": \"Simple\", \"incidentAngle\": 45.0,\n        ...         \"azimuthal_angle\": 0.0, \"frequency\": 1460.0}\n        &gt;&gt;&gt; scenario = ScenarioSetup(data)\n    \"\"\"\n    self.type = data.get(\"type\")\n    self.incident_angle = data.get(\"incidentAngle\", None)\n    self.azimuthal_angle = data.get(\"azimuthal_angle\", None)\n    self.frequency = data.get(\"frequency\", None)\n    self.create_scenario()\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_azimuthal_scenario","title":"<code>create_azimuthal_scenario()</code>","text":"<p>Create azimuthal rotation scenario at fixed incident angle.</p> <p>Rotates the sample through 360 azimuthal angles (0 to 2\u03c0) while maintaining constant incident angle.</p> Note <p>Useful for studying in-plane anisotropy and rotational symmetry. incidentAngle must be provided in input data.</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_azimuthal_scenario(self) -&gt; None:\n    \"\"\"Create azimuthal rotation scenario at fixed incident angle.\n\n    Rotates the sample through 360 azimuthal angles (0 to 2\u03c0) while\n    maintaining constant incident angle.\n\n    Note:\n        Useful for studying in-plane anisotropy and rotational symmetry.\n        incidentAngle must be provided in input data.\n    \"\"\"\n    self.incident_angle = np.float64(m.radians(self.incident_angle))\n    self.azimuthal_angle = np.linspace(\n        0.0 + 1.0e-15, 2.0 * m.pi - 1.0e-15, 360, dtype=np.float64\n    )\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_dispersion_scenario","title":"<code>create_dispersion_scenario()</code>","text":"<p>Create k-space dispersion scenario at fixed frequency.</p> <p>Sets up grid of incident angles (180 points) and azimuthal angles (480 points) for mapping isofrequency contours in kx-ky space.</p> Note <p>Requires 'frequency' to be specified in input data. Generates data for kx vs ky momentum-space plots.</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_dispersion_scenario(self) -&gt; None:\n    \"\"\"Create k-space dispersion scenario at fixed frequency.\n\n    Sets up grid of incident angles (180 points) and azimuthal angles\n    (480 points) for mapping isofrequency contours in kx-ky space.\n\n    Note:\n        Requires 'frequency' to be specified in input data.\n        Generates data for kx vs ky momentum-space plots.\n    \"\"\"\n    self.incident_angle = np.linspace(0.0 + 1.0e-8, m.pi / 2.0 - 1.0e-8, 180, dtype=np.float64)\n\n    self.azimuthal_angle = np.linspace(1.0e-5, 2.0 * m.pi - 1.0e-5, 480, dtype=np.float64)\n\n    self.frequency = float(self.frequency)\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_incident_scenario","title":"<code>create_incident_scenario()</code>","text":"<p>Create incident angle sweep scenario.</p> <p>Sets up 360 incident angles from -\u03c0/2 to \u03c0/2 for analyzing angle-dependent reflectivity across the material's frequency range.</p> Note <p>Frequency range is determined by the material in the final layer. Creates arrays suitable for generating kx vs frequency plots.</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_incident_scenario(self) -&gt; None:\n    \"\"\"Create incident angle sweep scenario.\n\n    Sets up 360 incident angles from -\u03c0/2 to \u03c0/2 for analyzing angle-dependent\n    reflectivity across the material's frequency range.\n\n    Note:\n        Frequency range is determined by the material in the final layer.\n        Creates arrays suitable for generating kx vs frequency plots.\n    \"\"\"\n\n    self.incident_angle = np.linspace(\n        -m.pi / 2.0 + 1.0e-9, m.pi / 2.0 - 1.0e-9, 360, dtype=np.float64\n    )\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_scenario","title":"<code>create_scenario()</code>","text":"<p>Create scenario-specific angle and frequency arrays.</p> <p>Dispatches to appropriate scenario creation method based on type.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If scenario type is not implemented</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_scenario(self) -&gt; None:\n    \"\"\"Create scenario-specific angle and frequency arrays.\n\n    Dispatches to appropriate scenario creation method based on type.\n\n    Raises:\n        NotImplementedError: If scenario type is not implemented\n    \"\"\"\n    if self.type == \"Incident\":\n        self.create_incident_scenario()\n    elif self.type == \"Azimuthal\":\n        self.create_azimuthal_scenario()\n    elif self.type == \"Dispersion\":\n        self.create_dispersion_scenario()\n    elif self.type == \"Simple\":\n        self.create_simple_scenario()\n    else:\n        raise NotImplementedError(f\"Scenario type {self.type} not implemented\")\n</code></pre>"},{"location":"api/scenario/#hyperbolic_optics.scenario.ScenarioSetup.create_simple_scenario","title":"<code>create_simple_scenario()</code>","text":"<p>Create single-point scenario with scalar values.</p> <p>Converts incident angle, azimuthal angle, and frequency to scalar values for quick single-point calculations.</p> Note <p>All three parameters (incidentAngle, azimuthal_angle, frequency) must be provided in input data.</p> Source code in <code>hyperbolic_optics/scenario.py</code> <pre><code>def create_simple_scenario(self) -&gt; None:\n    \"\"\"Create single-point scenario with scalar values.\n\n    Converts incident angle, azimuthal angle, and frequency to scalar\n    values for quick single-point calculations.\n\n    Note:\n        All three parameters (incidentAngle, azimuthal_angle, frequency)\n        must be provided in input data.\n    \"\"\"\n    # Convert to scalar values for consistency\n    self.incident_angle = np.float64(m.radians(self.incident_angle) + 1.0e-15)\n    self.azimuthal_angle = np.float64(m.radians(self.azimuthal_angle) + 1.0e-15)\n    self.frequency = float(self.frequency)\n</code></pre>"},{"location":"api/structure/","title":"Structure API","text":""},{"location":"api/structure/#hyperbolic_optics.structure","title":"<code>hyperbolic_optics.structure</code>","text":"<p>Main simulation structure and workflow orchestration.</p> <p>The Structure class is the primary interface for running optical simulations. It coordinates the entire calculation workflow:</p> <ol> <li>Parse scenario configuration</li> <li>Create multilayer stack</li> <li>Calculate transfer matrices for each layer</li> <li>Multiply matrices to get total system response</li> <li>Extract reflection coefficients</li> </ol> <p>The transfer matrix method is a recursive approach where each layer's effect is represented by a 4\u00d74 matrix relating field components at its boundaries. The total response is the product of all layer matrices.</p> <p>Reference: Passler &amp; Paarmann, JOSA B 34, 2128-2139 (2017)</p>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure","title":"<code>Structure</code>","text":"<p>Main interface for optical simulations.</p> <p>...existing docstring...</p> <p>Examples:</p> <p>Basic single-point calculation:</p> <pre><code>&gt;&gt;&gt; payload = {\n...     \"ScenarioData\": {\n...         \"type\": \"Simple\",\n...         \"incidentAngle\": 45.0,\n...         \"azimuthal_angle\": 0.0,\n...         \"frequency\": 1460.0\n...     },\n...     \"Layers\": [\n...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n...          \"material\": \"Calcite\", \"rotationY\": 90}\n...     ]\n... }\n&gt;&gt;&gt; structure = Structure()\n&gt;&gt;&gt; structure.execute(payload)\n&gt;&gt;&gt; print(f\"R_pp = {abs(structure.r_pp)**2:.4f}\")\n</code></pre> <p>Multi-layer structure with air gap:</p> <pre><code>&gt;&gt;&gt; payload = {\n...     \"ScenarioData\": {\"type\": \"Incident\"},\n...     \"Layers\": [\n...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n...         {\"type\": \"Isotropic Middle-Stack Layer\",\n...          \"thickness\": 0.5, \"permittivity\": 1.0},\n...         {\"type\": \"Crystal Layer\", \"material\": \"Quartz\",\n...          \"thickness\": 1.0, \"rotationY\": 70},\n...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n...          \"material\": \"Sapphire\", \"rotationY\": 90}\n...     ]\n... }\n&gt;&gt;&gt; structure = Structure()\n&gt;&gt;&gt; structure.execute(payload)\n&gt;&gt;&gt; # Results are arrays: structure.r_pp.shape = (410, 360)\n</code></pre> <p>Custom material with complex permittivity:</p> <pre><code>&gt;&gt;&gt; custom_material = {\n...     \"eps_xx\": {\"real\": 2.5, \"imag\": 0.1},\n...     \"eps_yy\": {\"real\": 3.0, \"imag\": 0.05},\n...     \"eps_zz\": {\"real\": -4.0, \"imag\": 0.5}\n... }\n&gt;&gt;&gt; payload = {\n...     \"ScenarioData\": {\"type\": \"Simple\", \"incidentAngle\": 45.0,\n...                      \"azimuthal_angle\": 0.0, \"frequency\": 1000.0},\n...     \"Layers\": [\n...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 25.0},\n...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n...          \"material\": custom_material, \"rotationY\": 45}\n...     ]\n... }\n&gt;&gt;&gt; structure = Structure()\n&gt;&gt;&gt; structure.execute(payload)\n</code></pre> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>class Structure:\n    \"\"\"Main interface for optical simulations.\n\n    ...existing docstring...\n\n    Examples:\n        Basic single-point calculation:\n\n        &gt;&gt;&gt; payload = {\n        ...     \"ScenarioData\": {\n        ...         \"type\": \"Simple\",\n        ...         \"incidentAngle\": 45.0,\n        ...         \"azimuthal_angle\": 0.0,\n        ...         \"frequency\": 1460.0\n        ...     },\n        ...     \"Layers\": [\n        ...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        ...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n        ...          \"material\": \"Calcite\", \"rotationY\": 90}\n        ...     ]\n        ... }\n        &gt;&gt;&gt; structure = Structure()\n        &gt;&gt;&gt; structure.execute(payload)\n        &gt;&gt;&gt; print(f\"R_pp = {abs(structure.r_pp)**2:.4f}\")\n\n        Multi-layer structure with air gap:\n\n        &gt;&gt;&gt; payload = {\n        ...     \"ScenarioData\": {\"type\": \"Incident\"},\n        ...     \"Layers\": [\n        ...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        ...         {\"type\": \"Isotropic Middle-Stack Layer\",\n        ...          \"thickness\": 0.5, \"permittivity\": 1.0},\n        ...         {\"type\": \"Crystal Layer\", \"material\": \"Quartz\",\n        ...          \"thickness\": 1.0, \"rotationY\": 70},\n        ...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n        ...          \"material\": \"Sapphire\", \"rotationY\": 90}\n        ...     ]\n        ... }\n        &gt;&gt;&gt; structure = Structure()\n        &gt;&gt;&gt; structure.execute(payload)\n        &gt;&gt;&gt; # Results are arrays: structure.r_pp.shape = (410, 360)\n\n        Custom material with complex permittivity:\n\n        &gt;&gt;&gt; custom_material = {\n        ...     \"eps_xx\": {\"real\": 2.5, \"imag\": 0.1},\n        ...     \"eps_yy\": {\"real\": 3.0, \"imag\": 0.05},\n        ...     \"eps_zz\": {\"real\": -4.0, \"imag\": 0.5}\n        ... }\n        &gt;&gt;&gt; payload = {\n        ...     \"ScenarioData\": {\"type\": \"Simple\", \"incidentAngle\": 45.0,\n        ...                      \"azimuthal_angle\": 0.0, \"frequency\": 1000.0},\n        ...     \"Layers\": [\n        ...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 25.0},\n        ...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n        ...          \"material\": custom_material, \"rotationY\": 45}\n        ...     ]\n        ... }\n        &gt;&gt;&gt; structure = Structure()\n        &gt;&gt;&gt; structure.execute(payload)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize empty optical structure for simulation.\n\n        Creates placeholder attributes for scenario, layers, reflection\n        coefficients, and intermediate calculation results.\n        \"\"\"\n        self.scenario = None\n        self.factory = LayerFactory()\n        self.layers = []\n        self.incident_angle = None\n        self.azimuthal_angle = None\n        self.frequency = None\n        self.eps_prism = None\n        self.k_x = None\n        self.k_0 = None\n        self.r_pp = None\n        self.r_ss = None\n        self.r_ps = None\n        self.r_sp = None\n        self.transfer_matrix = None\n\n    def get_scenario(self, scenario_data: dict[str, Any]) -&gt; None:\n        \"\"\"Parse and initialize scenario from configuration data.\n\n        Args:\n            scenario_data: Dictionary with scenario type and parameters\n\n        Note:\n            Automatically sets up angle and frequency arrays based on\n            scenario type.\n        \"\"\"\n        self.scenario = ScenarioSetup(scenario_data)\n        self.setup_attributes()\n\n    def setup_attributes(self) -&gt; None:\n        \"\"\"Transfer scenario attributes to structure for easy access.\n\n        Copies incident_angle, azimuthal_angle, and frequency from scenario\n        to structure attributes.\n        \"\"\"\n        self.incident_angle = self.scenario.incident_angle\n        self.azimuthal_angle = self.scenario.azimuthal_angle\n        self.frequency = self.scenario.frequency\n\n    def get_frequency_range(self, last_layer: dict[str, Any]) -&gt; None:\n        \"\"\"Determine frequency range from material's default range.\n\n        Args:\n            last_layer: Dictionary containing material name\n\n        Raises:\n            NotImplementedError: If material is not recognized\n\n        Note:\n            Automatically uses material-specific frequency range (e.g.,\n            1300-1600 cm\u207b\u00b9 for Calcite upper band).\n        \"\"\"\n        material = last_layer[\"material\"]\n\n        if material == \"Quartz\":\n            self.frequency = Quartz().frequency\n        elif material == \"Sapphire\":\n            self.frequency = Sapphire().frequency\n        elif material == \"Calcite\":\n            self.frequency = CalciteUpper().frequency\n        elif material == \"GalliumOxide\":\n            self.frequency = GalliumOxide().frequency\n        else:\n            raise NotImplementedError(\"Material not implemented\")\n\n    def calculate_kx_k0(self) -&gt; None:\n        \"\"\"Calculate parallel wavevector and free-space wavenumber.\n\n        Computes:\n            kx = n_prism \u00b7 sin(\u03b8) where n_prism = \u221a\u03b5_prism\n            k0 = \u03c9 / c = 2\u03c0 \u00b7 frequency\n\n        Note:\n            kx is conserved across all interfaces (phase matching condition).\n        \"\"\"\n        self.k_x = (\n            np.sqrt(np.float64(self.eps_prism)) * np.sin(self.incident_angle.astype(np.float64))\n        ).astype(np.float64)\n        self.k_0 = self.frequency * 2.0 * m.pi\n\n    def get_layers(self, layer_data_list: list[dict[str, Any]]) -&gt; None:\n        \"\"\"Create all layers in the structure from configuration.\n\n        Args:\n            layer_data_list: List of layer configuration dictionaries\n\n        Note:\n            First layer must be Ambient Incident Layer (prism).\n            Automatically determines frequency range if not specified.\n        \"\"\"\n        # First Layer is prism, so we parse it\n        self.eps_prism = layer_data_list[0].get(\"permittivity\", None)\n        if not self.frequency:\n            last_layer = layer_data_list[-1]\n            if last_layer.get(\"type\") != \"Semi Infinite Isotropic Layer\":\n                self.get_frequency_range(last_layer)\n            else:\n                self.get_frequency_range(layer_data_list[-2])\n        self.calculate_kx_k0()\n\n        # Create prism layer and add it to layers list\n        self.layers.append(\n            self.factory.create_layer(\n                layer_data_list[0],\n                self.scenario,\n                self.k_x,\n                self.k_0,\n            )\n        )\n\n        # Create the rest of the layers and add them to layers list\n        for layer_data in layer_data_list[1:]:\n            self.layers.append(\n                self.factory.create_layer(\n                    layer_data,\n                    self.scenario,\n                    self.k_x,\n                    self.k_0,\n                )\n            )\n\n    def calculate(self) -&gt; None:\n        \"\"\"Calculate total transfer matrix by multiplying layer matrices.\n\n        Performs matrix multiplication of all layer transfer matrices from\n        incident to exit medium: M_total = M_exit \u00b7 ... \u00b7 M_2 \u00b7 M_1 \u00b7 M_prism\n\n        Note:\n            Uses functools.reduce with operator.matmul for efficient\n            sequential multiplication.\n        \"\"\"\n        self.transfer_matrices = [layer.matrix for layer in self.layers]\n        self.transfer_matrix = functools.reduce(operator.matmul, self.transfer_matrices)\n\n    def calculate_reflectivity(self) -&gt; None:\n        \"\"\"Extract reflection coefficients from total transfer matrix.\n\n        Solves the system of equations to obtain r_pp, r_ss, r_ps, r_sp\n        from the boundary conditions encoded in the transfer matrix.\n\n        Note:\n            Reflection coefficients are complex and relate incident field\n            amplitudes to reflected field amplitudes:\n            E_reflected = r \u00b7 E_incident\n        \"\"\"\n        bottom_line = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n        )\n        self.r_pp = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 3, 2]\n            - self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 0, 2]\n        ) / bottom_line\n        self.r_ps = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 1, 2]\n            - (self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 0, 2])\n        ) / bottom_line\n        self.r_sp = (\n            self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 3, 2] * self.transfer_matrix[..., 2, 0]\n        ) / bottom_line\n        self.r_ss = (\n            self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 1, 2] * self.transfer_matrix[..., 2, 0]\n        ) / bottom_line\n\n    def calculate_transmissivity(self) -&gt; None:\n        \"\"\"Extract transmission coefficients from total transfer matrix.\n\n        Calculates t_pp, t_ss, t_ps, t_sp representing transmission through\n        the entire structure.\n\n        Warning:\n            Transmission coefficient support is incomplete and may not be\n            fully validated. Use with caution.\n        \"\"\"\n        bottom_line = (\n            self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n            - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n        )\n        self.t_pp = (self.transfer_matrix[..., 0, 0]) / bottom_line\n        self.t_ps = (-self.transfer_matrix[..., 0, 2]) / bottom_line\n        self.t_sp = (-self.transfer_matrix[..., 2, 0]) / bottom_line\n        self.t_ss = (self.transfer_matrix[..., 2, 2]) / bottom_line\n\n    def display_layer_info(self) -&gt; None:\n        \"\"\"Print information about all layers in the structure.\n\n        Debugging utility to display layer configuration and properties.\n        \"\"\"\n        for layer in self.layers:\n            print(layer)\n\n    def execute(self, payload: dict[str, Any]) -&gt; None:\n        \"\"\"Execute complete simulation from configuration payload.\n\n        Args:\n            payload: Dictionary with 'ScenarioData' and 'Layers' keys\n\n        Example:\n            &gt;&gt;&gt; payload = {\n            ...     \"ScenarioData\": {\"type\": \"Simple\", \"incidentAngle\": 45.0,\n            ...                      \"azimuthal_angle\": 0.0, \"frequency\": 1460.0},\n            ...     \"Layers\": [\n            ...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n            ...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n            ...          \"material\": \"Calcite\", \"rotationY\": 90}\n            ...     ]\n            ... }\n            &gt;&gt;&gt; structure = Structure()\n            &gt;&gt;&gt; structure.execute(payload)\n            &gt;&gt;&gt; R_pp = abs(structure.r_pp)**2\n        \"\"\"\n        # Get the scenario data\n        self.get_scenario(payload.get(\"ScenarioData\"))\n\n        # Get the layers\n        self.get_layers(payload.get(\"Layers\", None))\n\n        # Calculate the transfer matrix\n        self.calculate()\n\n        # Calculate the reflectivity\n        self.calculate_reflectivity()\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.__init__","title":"<code>__init__()</code>","text":"<p>Initialize empty optical structure for simulation.</p> <p>Creates placeholder attributes for scenario, layers, reflection coefficients, and intermediate calculation results.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize empty optical structure for simulation.\n\n    Creates placeholder attributes for scenario, layers, reflection\n    coefficients, and intermediate calculation results.\n    \"\"\"\n    self.scenario = None\n    self.factory = LayerFactory()\n    self.layers = []\n    self.incident_angle = None\n    self.azimuthal_angle = None\n    self.frequency = None\n    self.eps_prism = None\n    self.k_x = None\n    self.k_0 = None\n    self.r_pp = None\n    self.r_ss = None\n    self.r_ps = None\n    self.r_sp = None\n    self.transfer_matrix = None\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate","title":"<code>calculate()</code>","text":"<p>Calculate total transfer matrix by multiplying layer matrices.</p> <p>Performs matrix multiplication of all layer transfer matrices from incident to exit medium: M_total = M_exit \u00b7 ... \u00b7 M_2 \u00b7 M_1 \u00b7 M_prism</p> Note <p>Uses functools.reduce with operator.matmul for efficient sequential multiplication.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate(self) -&gt; None:\n    \"\"\"Calculate total transfer matrix by multiplying layer matrices.\n\n    Performs matrix multiplication of all layer transfer matrices from\n    incident to exit medium: M_total = M_exit \u00b7 ... \u00b7 M_2 \u00b7 M_1 \u00b7 M_prism\n\n    Note:\n        Uses functools.reduce with operator.matmul for efficient\n        sequential multiplication.\n    \"\"\"\n    self.transfer_matrices = [layer.matrix for layer in self.layers]\n    self.transfer_matrix = functools.reduce(operator.matmul, self.transfer_matrices)\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate_kx_k0","title":"<code>calculate_kx_k0()</code>","text":"<p>Calculate parallel wavevector and free-space wavenumber.</p> Computes <p>kx = n_prism \u00b7 sin(\u03b8) where n_prism = \u221a\u03b5_prism k0 = \u03c9 / c = 2\u03c0 \u00b7 frequency</p> Note <p>kx is conserved across all interfaces (phase matching condition).</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate_kx_k0(self) -&gt; None:\n    \"\"\"Calculate parallel wavevector and free-space wavenumber.\n\n    Computes:\n        kx = n_prism \u00b7 sin(\u03b8) where n_prism = \u221a\u03b5_prism\n        k0 = \u03c9 / c = 2\u03c0 \u00b7 frequency\n\n    Note:\n        kx is conserved across all interfaces (phase matching condition).\n    \"\"\"\n    self.k_x = (\n        np.sqrt(np.float64(self.eps_prism)) * np.sin(self.incident_angle.astype(np.float64))\n    ).astype(np.float64)\n    self.k_0 = self.frequency * 2.0 * m.pi\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate_reflectivity","title":"<code>calculate_reflectivity()</code>","text":"<p>Extract reflection coefficients from total transfer matrix.</p> <p>Solves the system of equations to obtain r_pp, r_ss, r_ps, r_sp from the boundary conditions encoded in the transfer matrix.</p> Note <p>Reflection coefficients are complex and relate incident field amplitudes to reflected field amplitudes: E_reflected = r \u00b7 E_incident</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate_reflectivity(self) -&gt; None:\n    \"\"\"Extract reflection coefficients from total transfer matrix.\n\n    Solves the system of equations to obtain r_pp, r_ss, r_ps, r_sp\n    from the boundary conditions encoded in the transfer matrix.\n\n    Note:\n        Reflection coefficients are complex and relate incident field\n        amplitudes to reflected field amplitudes:\n        E_reflected = r \u00b7 E_incident\n    \"\"\"\n    bottom_line = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n    )\n    self.r_pp = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 3, 2]\n        - self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 0, 2]\n    ) / bottom_line\n    self.r_ps = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 1, 2]\n        - (self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 0, 2])\n    ) / bottom_line\n    self.r_sp = (\n        self.transfer_matrix[..., 3, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 3, 2] * self.transfer_matrix[..., 2, 0]\n    ) / bottom_line\n    self.r_ss = (\n        self.transfer_matrix[..., 1, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 1, 2] * self.transfer_matrix[..., 2, 0]\n    ) / bottom_line\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.calculate_transmissivity","title":"<code>calculate_transmissivity()</code>","text":"<p>Extract transmission coefficients from total transfer matrix.</p> <p>Calculates t_pp, t_ss, t_ps, t_sp representing transmission through the entire structure.</p> Warning <p>Transmission coefficient support is incomplete and may not be fully validated. Use with caution.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def calculate_transmissivity(self) -&gt; None:\n    \"\"\"Extract transmission coefficients from total transfer matrix.\n\n    Calculates t_pp, t_ss, t_ps, t_sp representing transmission through\n    the entire structure.\n\n    Warning:\n        Transmission coefficient support is incomplete and may not be\n        fully validated. Use with caution.\n    \"\"\"\n    bottom_line = (\n        self.transfer_matrix[..., 0, 0] * self.transfer_matrix[..., 2, 2]\n        - self.transfer_matrix[..., 0, 2] * self.transfer_matrix[..., 2, 0]\n    )\n    self.t_pp = (self.transfer_matrix[..., 0, 0]) / bottom_line\n    self.t_ps = (-self.transfer_matrix[..., 0, 2]) / bottom_line\n    self.t_sp = (-self.transfer_matrix[..., 2, 0]) / bottom_line\n    self.t_ss = (self.transfer_matrix[..., 2, 2]) / bottom_line\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.display_layer_info","title":"<code>display_layer_info()</code>","text":"<p>Print information about all layers in the structure.</p> <p>Debugging utility to display layer configuration and properties.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def display_layer_info(self) -&gt; None:\n    \"\"\"Print information about all layers in the structure.\n\n    Debugging utility to display layer configuration and properties.\n    \"\"\"\n    for layer in self.layers:\n        print(layer)\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.execute","title":"<code>execute(payload)</code>","text":"<p>Execute complete simulation from configuration payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict[str, Any]</code> <p>Dictionary with 'ScenarioData' and 'Layers' keys</p> required Example <p>payload = { ...     \"ScenarioData\": {\"type\": \"Simple\", \"incidentAngle\": 45.0, ...                      \"azimuthal_angle\": 0.0, \"frequency\": 1460.0}, ...     \"Layers\": [ ...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0}, ...         {\"type\": \"Semi Infinite Anisotropic Layer\", ...          \"material\": \"Calcite\", \"rotationY\": 90} ...     ] ... } structure = Structure() structure.execute(payload) R_pp = abs(structure.r_pp)**2</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def execute(self, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Execute complete simulation from configuration payload.\n\n    Args:\n        payload: Dictionary with 'ScenarioData' and 'Layers' keys\n\n    Example:\n        &gt;&gt;&gt; payload = {\n        ...     \"ScenarioData\": {\"type\": \"Simple\", \"incidentAngle\": 45.0,\n        ...                      \"azimuthal_angle\": 0.0, \"frequency\": 1460.0},\n        ...     \"Layers\": [\n        ...         {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        ...         {\"type\": \"Semi Infinite Anisotropic Layer\",\n        ...          \"material\": \"Calcite\", \"rotationY\": 90}\n        ...     ]\n        ... }\n        &gt;&gt;&gt; structure = Structure()\n        &gt;&gt;&gt; structure.execute(payload)\n        &gt;&gt;&gt; R_pp = abs(structure.r_pp)**2\n    \"\"\"\n    # Get the scenario data\n    self.get_scenario(payload.get(\"ScenarioData\"))\n\n    # Get the layers\n    self.get_layers(payload.get(\"Layers\", None))\n\n    # Calculate the transfer matrix\n    self.calculate()\n\n    # Calculate the reflectivity\n    self.calculate_reflectivity()\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.get_frequency_range","title":"<code>get_frequency_range(last_layer)</code>","text":"<p>Determine frequency range from material's default range.</p> <p>Parameters:</p> Name Type Description Default <code>last_layer</code> <code>dict[str, Any]</code> <p>Dictionary containing material name</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If material is not recognized</p> Note <p>Automatically uses material-specific frequency range (e.g., 1300-1600 cm\u207b\u00b9 for Calcite upper band).</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def get_frequency_range(self, last_layer: dict[str, Any]) -&gt; None:\n    \"\"\"Determine frequency range from material's default range.\n\n    Args:\n        last_layer: Dictionary containing material name\n\n    Raises:\n        NotImplementedError: If material is not recognized\n\n    Note:\n        Automatically uses material-specific frequency range (e.g.,\n        1300-1600 cm\u207b\u00b9 for Calcite upper band).\n    \"\"\"\n    material = last_layer[\"material\"]\n\n    if material == \"Quartz\":\n        self.frequency = Quartz().frequency\n    elif material == \"Sapphire\":\n        self.frequency = Sapphire().frequency\n    elif material == \"Calcite\":\n        self.frequency = CalciteUpper().frequency\n    elif material == \"GalliumOxide\":\n        self.frequency = GalliumOxide().frequency\n    else:\n        raise NotImplementedError(\"Material not implemented\")\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.get_layers","title":"<code>get_layers(layer_data_list)</code>","text":"<p>Create all layers in the structure from configuration.</p> <p>Parameters:</p> Name Type Description Default <code>layer_data_list</code> <code>list[dict[str, Any]]</code> <p>List of layer configuration dictionaries</p> required Note <p>First layer must be Ambient Incident Layer (prism). Automatically determines frequency range if not specified.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def get_layers(self, layer_data_list: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Create all layers in the structure from configuration.\n\n    Args:\n        layer_data_list: List of layer configuration dictionaries\n\n    Note:\n        First layer must be Ambient Incident Layer (prism).\n        Automatically determines frequency range if not specified.\n    \"\"\"\n    # First Layer is prism, so we parse it\n    self.eps_prism = layer_data_list[0].get(\"permittivity\", None)\n    if not self.frequency:\n        last_layer = layer_data_list[-1]\n        if last_layer.get(\"type\") != \"Semi Infinite Isotropic Layer\":\n            self.get_frequency_range(last_layer)\n        else:\n            self.get_frequency_range(layer_data_list[-2])\n    self.calculate_kx_k0()\n\n    # Create prism layer and add it to layers list\n    self.layers.append(\n        self.factory.create_layer(\n            layer_data_list[0],\n            self.scenario,\n            self.k_x,\n            self.k_0,\n        )\n    )\n\n    # Create the rest of the layers and add them to layers list\n    for layer_data in layer_data_list[1:]:\n        self.layers.append(\n            self.factory.create_layer(\n                layer_data,\n                self.scenario,\n                self.k_x,\n                self.k_0,\n            )\n        )\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.get_scenario","title":"<code>get_scenario(scenario_data)</code>","text":"<p>Parse and initialize scenario from configuration data.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_data</code> <code>dict[str, Any]</code> <p>Dictionary with scenario type and parameters</p> required Note <p>Automatically sets up angle and frequency arrays based on scenario type.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def get_scenario(self, scenario_data: dict[str, Any]) -&gt; None:\n    \"\"\"Parse and initialize scenario from configuration data.\n\n    Args:\n        scenario_data: Dictionary with scenario type and parameters\n\n    Note:\n        Automatically sets up angle and frequency arrays based on\n        scenario type.\n    \"\"\"\n    self.scenario = ScenarioSetup(scenario_data)\n    self.setup_attributes()\n</code></pre>"},{"location":"api/structure/#hyperbolic_optics.structure.Structure.setup_attributes","title":"<code>setup_attributes()</code>","text":"<p>Transfer scenario attributes to structure for easy access.</p> <p>Copies incident_angle, azimuthal_angle, and frequency from scenario to structure attributes.</p> Source code in <code>hyperbolic_optics/structure.py</code> <pre><code>def setup_attributes(self) -&gt; None:\n    \"\"\"Transfer scenario attributes to structure for easy access.\n\n    Copies incident_angle, azimuthal_angle, and frequency from scenario\n    to structure attributes.\n    \"\"\"\n    self.incident_angle = self.scenario.incident_angle\n    self.azimuthal_angle = self.scenario.azimuthal_angle\n    self.frequency = self.scenario.frequency\n</code></pre>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>All examples are available in the <code>examples/</code> directory of the repository.</p>"},{"location":"examples/basic/#simple-calcite-reflection","title":"Simple Calcite Reflection","text":"<p>Calculate basic reflection coefficients for a Calcite crystal.</p> examples/calcite.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nBasic Calcite Reflection Example\n\nThis script demonstrates the most basic usage of the hyperbolic-optics package\nby calculating reflection coefficients for a simple Calcite crystal structure.\n\"\"\"\n\n\nimport numpy as np\n\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Calculate basic reflection coefficients for Calcite at a single frequency and angle.\n    \"\"\"\n    print(\"=== Basic Calcite Reflection Example ===\\n\")\n\n    # Define a simple structure with Calcite\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Simple\",\n            \"incidentAngle\": 45.0,  # 45 degree incident angle\n            \"azimuthal_angle\": 0.0,  # No azimuthal rotation\n            \"frequency\": 1460.0,  # Frequency in cm^-1\n        },\n        \"Layers\": [\n            {\n                \"type\": \"Ambient Incident Layer\",\n                \"permittivity\": 50.0,  # High-index prism\n            },\n            {\n                \"type\": \"Isotropic Middle-Stack Layer\",\n                \"thickness\": 0.1,  # Thin air gap (in mm)\n                \"permittivity\": 1.0,  # Air\n            },\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 90,  # Rotate optical axis\n                \"rotationZ\": 0,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    print(\"Creating structure and calculating...\")\n    structure = Structure()\n    structure.execute(payload)\n\n    # Extract reflection coefficients\n    r_pp = structure.r_pp  # p-to-p polarization\n    r_ss = structure.r_ss  # s-to-s polarization\n    r_ps = structure.r_ps  # p-to-s polarization\n    r_sp = structure.r_sp  # s-to-p polarization\n\n    # Calculate reflectivities (|r|\u00b2)\n    R_pp = abs(r_pp) ** 2\n    R_ss = abs(r_ss) ** 2\n    R_ps = abs(r_ps) ** 2\n    R_sp = abs(r_sp) ** 2\n\n    # Display results\n    print(\"Results:\")\n    print(f\"  Incident angle: {structure.scenario.incident_angle * 180/np.pi:.1f}\u00b0\")\n    print(f\"  Frequency: {structure.frequency:.1f} cm\u207b\u00b9\")\n    print(\"  Material: Calcite\")\n    print()\n    print(\"Reflection Coefficients:\")\n    print(f\"  r_pp = {r_pp:.6f}\")\n    print(f\"  r_ss = {r_ss:.6f}\")\n    print(f\"  r_ps = {r_ps:.6f}\")\n    print(f\"  r_sp = {r_sp:.6f}\")\n    print()\n    print(\"Reflectivities (|r|\u00b2):\")\n    print(f\"  R_pp = {R_pp:.4f}\")\n    print(f\"  R_ss = {R_ss:.4f}\")\n    print(f\"  R_ps = {R_ps:.4f}\")\n    print(f\"  R_sp = {R_sp:.4f}\")\n    print()\n    print(f\"Total reflectivity for p-polarized light: {R_pp + R_ps:.4f}\")\n    print(f\"Total reflectivity for s-polarized light: {R_ss + R_sp:.4f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download calcite.py</p>"},{"location":"examples/basic/#frequency-vs-incident-angle","title":"Frequency vs Incident Angle","text":"<p>Generate dispersion plots showing frequency vs kx.</p> examples/frequency_vs_kx.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nk-Space Dispersion Plot Example\n\nThis script demonstrates how to generate k-space dispersion plots (kx vs ky)\nshowing the reflectivity in momentum space for a Calcite crystal.\n\"\"\"\n\n\nfrom hyperbolic_optics.plots import plot_kx_frequency\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Generate a k-space dispersion plot for Calcite.\n    \"\"\"\n    # Define dispersion scenario\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Incident\",\n        },\n        \"Layers\": [\n            {\"type\": \"Ambient Incident Layer\", \"permittivity\": 12.5},\n            {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 90,\n                \"rotationZ\": 90,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    structure = Structure()\n    structure.execute(payload)\n\n    # Calculate total reflectivity\n    R_total = abs(structure.r_pp) ** 2 + abs(structure.r_ps) ** 2\n\n    # Generate the plot using your existing plotting function\n\n    plot_kx_frequency(\n        structure,\n        R_total,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download frequency_vs_kx.py</p>"},{"location":"examples/basic/#k-space-dispersion","title":"k-Space Dispersion","text":"<p>Visualize polariton dispersion in momentum space (kx vs ky).</p> examples/kx_vs_ky.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nk-Space Dispersion Plot Example\n\nThis script demonstrates how to generate k-space dispersion plots (kx vs ky)\nshowing the reflectivity in momentum space for a Calcite crystal.\n\"\"\"\n\n\nfrom hyperbolic_optics.plots import plot_mueller_dispersion\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Generate a k-space dispersion plot for Calcite.\n    \"\"\"\n    # Define dispersion scenario\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Dispersion\",\n            \"frequency\": 1460.0,  # Fixed frequency in cm^-1\n        },\n        \"Layers\": [\n            {\"type\": \"Ambient Incident Layer\", \"permittivity\": 25.0},\n            {\n                \"type\": \"Isotropic Middle-Stack Layer\",\n                \"thickness\": 0.5,\n                \"permittivity\": 1.0,\n            },\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 70,  # Optical axis tilt\n                \"rotationZ\": 0,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    structure = Structure()\n    structure.execute(payload)\n\n    # Calculate total reflectivity\n    R_total = abs(structure.r_pp) ** 2 + abs(structure.r_ps) ** 2\n\n    # Generate the plot using your existing plotting function\n\n    plot_mueller_dispersion(\n        structure,\n        R_total,\n        title=\"The Hyperbolic Ghost Polariton\",\n        rotation_y=70,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download kx_vs_ky.py</p>"},{"location":"examples/basic/#azimuthal-variation","title":"Azimuthal Variation","text":"<p>Study how reflectivity changes with sample rotation.</p> examples/azimuthal_variation.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nk-Space Dispersion Plot Example\n\nThis script demonstrates how to generate k-space dispersion plots (kx vs ky)\nshowing the reflectivity in momentum space for a Calcite crystal.\n\"\"\"\n\n\nfrom hyperbolic_optics.plots import plot_mueller_azimuthal\nfrom hyperbolic_optics.structure import Structure\n\n\ndef main():\n    \"\"\"\n    Generate a k-space dispersion plot for Calcite.\n    \"\"\"\n    # Define dispersion scenario\n    payload = {\n        \"ScenarioData\": {\n            \"type\": \"Azimuthal\",\n            \"incidentAngle\": 40,\n        },\n        \"Layers\": [\n            {\"type\": \"Ambient Incident Layer\", \"permittivity\": 12.5},\n            {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n            {\n                \"type\": \"Semi Infinite Anisotropic Layer\",\n                \"material\": \"Calcite\",\n                \"rotationX\": 0,\n                \"rotationY\": 90,\n                \"rotationZ\": 0,\n            },\n        ],\n    }\n\n    # Create and execute the simulation\n    structure = Structure()\n    structure.execute(payload)\n\n    # Calculate total reflectivity\n    R_total = abs(structure.r_pp) ** 2 + abs(structure.r_ps) ** 2\n\n    # Generate the plot using your existing plotting function\n\n    plot_mueller_azimuthal(\n        structure,\n        R_total,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Download azimuthal_variation.py</p>"},{"location":"examples/basic/#running-the-examples","title":"Running the Examples","text":"<p>Clone the repository and run any example:</p> <pre><code>git clone https://github.com/MarkCunningham0410/hyperbolic_optics.git\ncd hyperbolic_optics\npython examples/calcite.py\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install hyperbolic-optics\n</code></pre>"},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (recommended)","text":"<pre><code>uv add hyperbolic-optics\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute or modify the source code:</p> <pre><code># Clone the repository\ngit clone https://github.com/MarkCunningham0410/hyperbolic_optics.git\ncd hyperbolic_optics\n\n# Install with all extras\nuv sync --all-extras\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test your installation:</p> <pre><code>from hyperbolic_optics.structure import Structure\nprint(\"Installation successful!\")\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>The package automatically installs:</p> <ul> <li>NumPy &gt;= 1.20.0</li> <li>SciPy &gt;= 1.7.0</li> <li>Matplotlib &gt;= 3.5.0</li> </ul>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For development:</p> <pre><code>uv sync --extra dev\n</code></pre> <p>This includes pytest, black, isort, and flake8 for testing and code quality.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#your-first-simulation","title":"Your First Simulation","text":"<p>Let's run a simple simulation to calculate reflection coefficients for a Calcite crystal.</p> <pre><code>from hyperbolic_optics.structure import Structure\n\n# Define the structure\npayload = {\n    \"ScenarioData\": {\n        \"type\": \"Simple\",\n        \"incidentAngle\": 45.0,      # degrees\n        \"azimuthal_angle\": 0.0,      # degrees\n        \"frequency\": 1460.0          # cm^-1\n    },\n    \"Layers\": [\n        {\n            \"type\": \"Ambient Incident Layer\",\n            \"permittivity\": 50.0\n        },\n        {\n            \"type\": \"Isotropic Middle-Stack Layer\",\n            \"thickness\": 0.1,  # mm\n            \"permittivity\": 1.0\n        },\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Calcite\",\n            \"rotationX\": 0,\n            \"rotationY\": 90,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\n# Run simulation\nstructure = Structure()\nstructure.execute(payload)\n\n# Get reflection coefficients\nr_pp = structure.r_pp  # p-to-p\nr_ss = structure.r_ss  # s-to-s\nr_ps = structure.r_ps  # p-to-s\nr_sp = structure.r_sp  # s-to-p\n\n# Calculate reflectivities\nR_pp = abs(r_pp)**2\nR_ss = abs(r_ss)**2\n\nprint(f\"p-polarized reflectivity: {R_pp:.4f}\")\nprint(f\"s-polarized reflectivity: {R_ss:.4f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#adding-mueller-matrix-analysis","title":"Adding Mueller Matrix Analysis","text":"<pre><code>from hyperbolic_optics.mueller import Mueller\n\n# Use the structure from above\nmueller = Mueller(structure)\n\n# Set incident polarization\nmueller.set_incident_polarization('linear', angle=45)\n\n# Add the sample\nmueller.add_optical_component('anisotropic_sample')\n\n# Get all parameters\nparams = mueller.get_all_parameters()\n\nprint(f\"Reflectance (S0): {params['S0']:.4f}\")\nprint(f\"Degree of polarization: {params['DOP']:.4f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#running-different-scenarios","title":"Running Different Scenarios","text":""},{"location":"getting-started/quickstart/#incident-angle-sweep","title":"Incident Angle Sweep","text":"<pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Incident\",  # Sweeps through angles\n    },\n    \"Layers\": [\n        {\"type\": \"Ambient Incident Layer\", \"permittivity\": 12.5},\n        {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Calcite\",\n            \"rotationX\": 0,\n            \"rotationY\": 90,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\nstructure = Structure()\nstructure.execute(payload)\n\n# Results are now arrays: shape (410, 360)\n# 410 frequency points x 360 angle points\n</code></pre>"},{"location":"getting-started/quickstart/#plotting-results","title":"Plotting Results","text":"<pre><code>from hyperbolic_optics.plots import plot_kx_frequency\n\n# Calculate total reflectivity\nR_total = abs(structure.r_pp)**2 + abs(structure.r_ps)**2\n\n# Generate plot\nplot_kx_frequency(structure, R_total, save_name=\"my_simulation\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about different scenarios</li> <li>Explore available materials</li> <li>See more examples</li> <li>Check the API reference</li> </ul>"},{"location":"user-guide/concepts/","title":"Basic Concepts","text":""},{"location":"user-guide/concepts/#overview","title":"Overview","text":"<p>The hyperbolic-optics package uses the 4\u00d74 transfer matrix method to calculate reflection and transmission coefficients for multilayer anisotropic structures.</p>"},{"location":"user-guide/concepts/#key-components","title":"Key Components","text":""},{"location":"user-guide/concepts/#structure","title":"Structure","text":"<p>The <code>Structure</code> class is the main interface for setting up and running simulations. It:</p> <ul> <li>Defines the geometry (layers and materials)</li> <li>Sets up the scenario (angles, frequencies)</li> <li>Calculates reflection coefficients</li> </ul>"},{"location":"user-guide/concepts/#layers","title":"Layers","text":"<p>A structure consists of multiple layers:</p> <ol> <li>Ambient Incident Layer: The incident medium (e.g., prism)</li> <li>Middle Layers: Can be isotropic or anisotropic, finite thickness</li> <li>Exit Layer: Usually semi-infinite, can be isotropic or anisotropic</li> </ol>"},{"location":"user-guide/concepts/#materials","title":"Materials","text":"<p>Materials are defined by their permittivity (\u03b5) and permeability (\u03bc) tensors:</p> <ul> <li>Uniaxial: Single optical axis (Quartz, Calcite, Sapphire)</li> <li>Biaxial/Monoclinic: Two or three optical axes (Gallium Oxide)</li> <li>Isotropic: No optical axis (Air, glass)</li> <li>Arbitrary: Custom-defined tensors</li> </ul>"},{"location":"user-guide/concepts/#reflection-coefficients","title":"Reflection Coefficients","text":"<p>The package calculates four reflection coefficients:</p> <ul> <li>r_pp: p-polarized \u2192 p-polarized</li> <li>r_ss: s-polarized \u2192 s-polarized  </li> <li>r_ps: p-polarized \u2192 s-polarized</li> <li>r_sp: s-polarized \u2192 p-polarized</li> </ul> <p>Reflectivity is calculated as: \\(R = |r|^2\\)</p>"},{"location":"user-guide/concepts/#coordinate-system","title":"Coordinate System","text":"<ul> <li>x-axis: Parallel to the interface, in the plane of incidence</li> <li>y-axis: Parallel to the interface, perpendicular to plane of incidence</li> <li>z-axis: Normal to the interface (propagation direction)</li> </ul>"},{"location":"user-guide/concepts/#rotations","title":"Rotations","text":"<p>Materials can be rotated using Euler angles:</p> <ul> <li>rotationY: Rotation around y-axis (often the optical axis tilt)</li> <li>rotationZ: Rotation around z-axis (azimuthal rotation)</li> </ul>"},{"location":"user-guide/concepts/#transfer-matrix-method","title":"Transfer Matrix Method","text":"<p>The 4\u00d74 transfer matrix method tracks both electric and magnetic field components through each layer. For each layer:</p> <ol> <li>Calculate the Berreman matrix (describes wave propagation)</li> <li>Find eigenvalues and eigenvectors (wave modes)</li> <li>Construct the transfer matrix</li> <li>Multiply matrices for all layers</li> <li>Extract reflection coefficients</li> </ol>"},{"location":"user-guide/concepts/#mueller-matrices","title":"Mueller Matrices","text":"<p>Mueller matrices describe how polarization states transform upon reflection:</p> \\[\\mathbf{S}_{out} = \\mathbf{M} \\cdot \\mathbf{S}_{in}\\] <p>Where \\(\\mathbf{S}\\) is the Stokes vector: \\([S_0, S_1, S_2, S_3]^T\\)</p> <p>The package can: 1. Calculate Mueller matrices from reflection coefficients 2. Simulate optical components (polarizers, wave plates) 3. Calculate Stokes parameters and polarization properties</p>"},{"location":"user-guide/concepts/#units","title":"Units","text":"<ul> <li>Frequency: cm\u207b\u00b9 (wavenumbers)</li> <li>Thickness: mm (converted to cm internally)</li> <li>Angles: degrees (converted to radians internally)</li> <li>Permittivity/Permeability: dimensionless</li> </ul>"},{"location":"user-guide/materials/","title":"Materials","text":""},{"location":"user-guide/materials/#built-in-materials","title":"Built-in Materials","text":""},{"location":"user-guide/materials/#uniaxial-materials","title":"Uniaxial Materials","text":"<p>Materials with a single optical axis (extraordinary axis differs from ordinary axes).</p>"},{"location":"user-guide/materials/#quartz","title":"Quartz","text":"<pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"Quartz\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,  # Optical axis orientation\n    \"rotationZ\": 0\n}\n</code></pre> <ul> <li>Frequency range: 410-600 cm\u207b\u00b9</li> <li>Type: Uniaxial positive</li> <li>Applications: Mid-infrared phonon polaritons</li> </ul>"},{"location":"user-guide/materials/#calcite","title":"Calcite","text":"<p>Two variants available:</p> <p>Upper Reststrahlen Band: <pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"Calcite\",  # or \"CalciteUpper\"\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre></p> <ul> <li>Frequency range: 1300-1600 cm\u207b\u00b9</li> <li>Type: Uniaxial negative (hyperbolic)</li> </ul> <p>Lower Reststrahlen Band: <pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"CalciteLower\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre></p> <ul> <li>Frequency range: 860-920 cm\u207b\u00b9</li> <li>Type: Uniaxial positive</li> </ul>"},{"location":"user-guide/materials/#sapphire","title":"Sapphire","text":"<pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"Sapphire\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre> <ul> <li>Frequency range: 210-1000 cm\u207b\u00b9</li> <li>Type: Uniaxial negative</li> <li>Applications: Wide-band phonon polaritons</li> </ul>"},{"location":"user-guide/materials/#monoclinic-materials","title":"Monoclinic Materials","text":""},{"location":"user-guide/materials/#gallium-oxide-ga2o3","title":"Gallium Oxide (\u03b2-Ga\u2082O\u2083)","text":"<pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": \"GalliumOxide\",\n    \"rotationX\": 0,\n    \"rotationY\": 90,\n    \"rotationZ\": 0\n}\n</code></pre> <ul> <li>Frequency range: 350-800 cm\u207b\u00b9</li> <li>Type: Monoclinic (non-zero off-diagonal elements)</li> <li>Special: Has xy coupling (\u03b5_xy \u2260 0)</li> </ul>"},{"location":"user-guide/materials/#isotropic-materials","title":"Isotropic Materials","text":""},{"location":"user-guide/materials/#air","title":"Air","text":"<p>Used for air gaps and isotropic layers:</p> <pre><code>{\n    \"type\": \"Isotropic Middle-Stack Layer\",\n    \"thickness\": 0.5,\n    \"permittivity\": 1.0  # Air\n}\n</code></pre>"},{"location":"user-guide/materials/#custom-isotropic","title":"Custom Isotropic","text":"<pre><code>{\n    \"type\": \"Isotropic Middle-Stack Layer\",\n    \"thickness\": 0.5,\n    \"permittivity\": {\"real\": 2.5, \"imag\": 0.1}\n}\n</code></pre>"},{"location":"user-guide/materials/#arbitrary-materials","title":"Arbitrary Materials","text":"<p>Define custom materials with full tensors:</p> <pre><code>{\n    \"type\": \"Semi Infinite Anisotropic Layer\",\n    \"material\": {\n        \"eps_xx\": {\"real\": 2.27, \"imag\": 0.001},\n        \"eps_yy\": {\"real\": -4.84, \"imag\": 0.755},\n        \"eps_zz\": {\"real\": -4.84, \"imag\": 0.755},\n        \"eps_xy\": {\"real\": 0.0, \"imag\": 0.0},\n        \"eps_xz\": {\"real\": 0.0, \"imag\": 0.0},\n        \"eps_yz\": {\"real\": 0.0, \"imag\": 0.0}\n    },\n    \"rotationX\": 0,\n    \"rotationY\": 0,\n    \"rotationZ\": 0\n}\n</code></pre>"},{"location":"user-guide/materials/#material-rotations","title":"Material Rotations","text":""},{"location":"user-guide/materials/#rotation-types","title":"Rotation Types","text":"<p>Materials can be rotated using Euler angles (in degrees):</p> <ul> <li>rotationX: Rotation around x-axis (Not really used)</li> <li>rotationY: Rotation around y-axis (typically optical axis tilt)</li> <li>rotationZ: Rotation around z-axis (azimuthal)</li> </ul>"},{"location":"user-guide/materials/#rotation-examples","title":"Rotation Examples","text":"<p>Optical axis perpendicular to interface: <pre><code>\"rotationX\": 0,\n\"rotationY\": 0,\n\"rotationZ\": 0\n</code></pre></p> <p>Optical axis in the plane (70\u00b0 tilt): <pre><code>\"rotationX\": 0,\n\"rotationY\": 70,\n\"rotationZ\": 0\n</code></pre></p> <p>45\u00b0 azimuthal rotation: <pre><code>\"rotationX\": 0,\n\"rotationY\": 90,\n\"rotationZ\": 45\n</code></pre></p>"},{"location":"user-guide/materials/#rotation-types-for-z-rotation","title":"Rotation Types for Z-rotation","text":"<pre><code>\"rotationZ\": 45,\n\"rotationZType\": \"relative\"  # Default: rotates with azimuthal angle\n</code></pre> <p>or</p> <pre><code>\"rotationZ\": 45,\n\"rotationZType\": \"static\"  # Fixed: doesn't rotate with azimuthal angle\n</code></pre>"},{"location":"user-guide/materials/#plotting-material-properties","title":"Plotting Material Properties","text":"<pre><code>from hyperbolic_optics.materials import CalciteUpper\nfrom hyperbolic_optics.plots import plot_permittivity\n\n# Create material\ncalcite = CalciteUpper()\n\n# Get permittivity\neps_ext, eps_ord = calcite.permittivity_fetch()\n\n# Plot\nplot_permittivity(calcite, eps_ext, eps_ord, save_name=\"calcite_permittivity\")\n</code></pre>"},{"location":"user-guide/materials/#material-properties-summary","title":"Material Properties Summary","text":"Material Type Frequency Range Hyperbolic? Quartz Uniaxial 410-600 cm\u207b\u00b9 Yes Calcite Upper Uniaxial 1300-1600 cm\u207b\u00b9 Yes Calcite Lower Uniaxial 860-920 cm\u207b\u00b9 Yes Sapphire Uniaxial 210-1000 cm\u207b\u00b9 Yes Gallium Oxide Monoclinic 350-800 cm\u207b\u00b9 Yes <p>Note: A material is \"hyperbolic\" when the real parts of permittivity components have opposite signs.</p>"},{"location":"user-guide/mueller/","title":"Mueller Matrices","text":"<p>Mueller matrices describe how light's polarization state changes upon reflection from a surface.</p>"},{"location":"user-guide/mueller/#basic-usage","title":"Basic Usage","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.mueller import Mueller\n\n# Create structure\nstructure = Structure()\nstructure.execute(payload)\n\n# Create Mueller analyzer\nmueller = Mueller(structure)\n\n# Set incident polarization\nmueller.set_incident_polarization('linear', angle=45)\n\n# Add the sample\nmueller.add_optical_component('anisotropic_sample')\n\n# Calculate results\nparams = mueller.get_all_parameters()\n</code></pre>"},{"location":"user-guide/mueller/#incident-polarization-states","title":"Incident Polarization States","text":""},{"location":"user-guide/mueller/#linear-polarization","title":"Linear Polarization","text":"<pre><code># p-polarized (0\u00b0)\nmueller.set_incident_polarization('linear', angle=0)\n\n# s-polarized (90\u00b0)\nmueller.set_incident_polarization('linear', angle=90)\n\n# 45\u00b0 linear\nmueller.set_incident_polarization('linear', angle=45)\n</code></pre>"},{"location":"user-guide/mueller/#circular-polarization","title":"Circular Polarization","text":"<pre><code># Right-handed circular\nmueller.set_incident_polarization('circular', handedness='right')\n\n# Left-handed circular\nmueller.set_incident_polarization('circular', handedness='left')\n</code></pre>"},{"location":"user-guide/mueller/#elliptical-polarization","title":"Elliptical Polarization","text":"<pre><code># Elliptical with azimuth 30\u00b0 and ellipticity 20\u00b0\nmueller.set_incident_polarization('elliptical', alpha=30, ellipticity=20)\n</code></pre>"},{"location":"user-guide/mueller/#optical-components","title":"Optical Components","text":""},{"location":"user-guide/mueller/#anisotropic-sample","title":"Anisotropic Sample","text":"<p>The main sample being analyzed:</p> <pre><code>mueller.add_optical_component('anisotropic_sample')\n</code></pre>"},{"location":"user-guide/mueller/#linear-polarizer","title":"Linear Polarizer","text":"<pre><code># Horizontal polarizer (0\u00b0)\nmueller.add_optical_component('linear_polarizer', 0)\n\n# Vertical polarizer (90\u00b0)\nmueller.add_optical_component('linear_polarizer', 90)\n\n# 45\u00b0 polarizer\nmueller.add_optical_component('linear_polarizer', 45)\n</code></pre>"},{"location":"user-guide/mueller/#quarter-wave-plate","title":"Quarter-Wave Plate","text":"<pre><code># QWP with fast axis at 45\u00b0\nmueller.add_optical_component('quarter_wave_plate', 45)\n</code></pre>"},{"location":"user-guide/mueller/#half-wave-plate","title":"Half-Wave Plate","text":"<pre><code># HWP with fast axis at 22.5\u00b0\nmueller.add_optical_component('half_wave_plate', 22.5)\n</code></pre>"},{"location":"user-guide/mueller/#multiple-components","title":"Multiple Components","text":"<p>Place components in series:</p> <pre><code># Polarizer \u2192 Sample \u2192 Analyzer\nmueller.set_incident_polarization('linear', angle=0)\nmueller.add_optical_component('linear_polarizer', 0)  # Input polarizer\nmueller.add_optical_component('anisotropic_sample')    # Sample\nmueller.add_optical_component('linear_polarizer', 90)  # Analyzer (crossed)\n\nreflectivity = mueller.get_reflectivity()\n</code></pre>"},{"location":"user-guide/mueller/#stokes-parameters","title":"Stokes Parameters","text":"<p>The Stokes parameters describe the polarization state:</p> <ul> <li>S0: Total intensity (reflectance)</li> <li>S1: Horizontal vs vertical linear polarization</li> <li>S2: +45\u00b0 vs -45\u00b0 linear polarization</li> <li>S3: Right vs left circular polarization</li> </ul> <pre><code>stokes = mueller.get_stokes_parameters()\n\nprint(f\"Total intensity: {stokes['S0']}\")\nprint(f\"Linear H/V: {stokes['S1']}\")\nprint(f\"Linear \u00b145\u00b0: {stokes['S2']}\")\nprint(f\"Circular R/L: {stokes['S3']}\")\n</code></pre>"},{"location":"user-guide/mueller/#polarization-properties","title":"Polarization Properties","text":""},{"location":"user-guide/mueller/#degree-of-polarization-dop","title":"Degree of Polarization (DOP)","text":"<pre><code>dop = mueller.get_degree_of_polarisation()\n# DOP = 0: unpolarized\n# DOP = 1: fully polarized\n</code></pre>"},{"location":"user-guide/mueller/#ellipticity","title":"Ellipticity","text":"<pre><code>ellipticity = mueller.get_ellipticity()\n# Ellipticity angle in radians\n# 0: linear\n# \u00b1\u03c0/4: circular\n</code></pre>"},{"location":"user-guide/mueller/#azimuth","title":"Azimuth","text":"<pre><code>azimuth = mueller.get_azimuth()\n# Orientation of polarization ellipse major axis\n</code></pre>"},{"location":"user-guide/mueller/#all-parameters-at-once","title":"All Parameters at Once","text":"<pre><code>params = mueller.get_all_parameters()\n\n# Contains: S0, S1, S2, S3, DOP, Ellipticity, Azimuth\nfor key, value in params.items():\n    print(f\"{key}: {value}\")\n</code></pre>"},{"location":"user-guide/mueller/#complete-example","title":"Complete Example","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.mueller import Mueller\n\n# Define structure\npayload = {\n    \"ScenarioData\": {\n        \"type\": \"Incident\"\n    },\n    \"Layers\": [\n        {\"type\": \"Ambient Incident Layer\", \"permittivity\": 50.0},\n        {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.1},\n        {\n            \"type\": \"Semi Infinite Anisotropic Layer\",\n            \"material\": \"Quartz\",\n            \"rotationX\": 0,\n            \"rotationY\": 70,\n            \"rotationZ\": 0\n        }\n    ]\n}\n\n# Run simulation\nstructure = Structure()\nstructure.execute(payload)\n\n# Mueller analysis\nmueller = Mueller(structure)\n\n# Try different incident polarizations\nfor angle in [0, 45, 90]:\n    mueller.set_incident_polarization('linear', angle=angle)\n    mueller.add_optical_component('anisotropic_sample')\n\n    params = mueller.get_all_parameters()\n    print(f\"\\nIncident angle: {angle}\u00b0\")\n    print(f\"Average reflectance: {params['S0'].mean():.4f}\")\n    print(f\"Average DOP: {params['DOP'].mean():.4f}\")\n\n    mueller.reset()  # Reset for next calculation\n</code></pre>"},{"location":"user-guide/mueller/#resetting-the-mueller-object","title":"Resetting the Mueller Object","text":"<pre><code># Clear all settings and start fresh\nmueller.reset()\n</code></pre> <p>This clears: - Mueller matrix - Stokes parameters - Optical components - Resets incident polarization to unpolarized</p>"},{"location":"user-guide/mueller/#physical-interpretation","title":"Physical Interpretation","text":""},{"location":"user-guide/mueller/#reflectance-s0","title":"Reflectance (S0)","text":"<p>Total reflected power, sum of all polarization components.</p>"},{"location":"user-guide/mueller/#degree-of-polarization","title":"Degree of Polarization","text":"<ul> <li>DOP = 1: Fully polarized (pure state)</li> <li>0 &lt; DOP &lt; 1: Partially polarized</li> <li>DOP = 0: Unpolarized (random)</li> </ul>"},{"location":"user-guide/mueller/#understanding-s1-s2-s3","title":"Understanding S1, S2, S3","text":"<ul> <li>S1 &gt; 0: More horizontal than vertical</li> <li>S1 &lt; 0: More vertical than horizontal</li> <li>S2 &gt; 0: More +45\u00b0 than -45\u00b0</li> <li>S2 &lt; 0: More -45\u00b0 than +45\u00b0</li> <li>S3 &gt; 0: More right-circular</li> <li>S3 &lt; 0: More left-circular</li> </ul>"},{"location":"user-guide/scenarios/","title":"Scenarios","text":"<p>The package supports four different scenario types for different analysis needs.</p>"},{"location":"user-guide/scenarios/#simple-scenario","title":"Simple Scenario","text":"<p>Single point calculation at a specific angle, frequency, and orientation.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Simple\",\n        \"incidentAngle\": 45.0,      # degrees\n        \"azimuthal_angle\": 0.0,      # degrees  \n        \"frequency\": 1460.0          # cm^-1\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: Scalar values for reflection coefficients</p> <p>Use case: Quick calculations, debugging, single point analysis</p>"},{"location":"user-guide/scenarios/#incident-scenario","title":"Incident Scenario","text":"<p>Sweeps through incident angles at multiple frequencies.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Incident\"\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: <code>[410, 360]</code> - 410 frequency points \u00d7 360 angle points</p> <p>Use case: Analyzing angle-dependent behavior, finding resonances</p> <p>Plotting: Use <code>plot_kx_frequency()</code> for frequency vs kx plots</p>"},{"location":"user-guide/scenarios/#azimuthal-scenario","title":"Azimuthal Scenario","text":"<p>Rotates the sample azimuthally at a fixed incident angle.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Azimuthal\",\n        \"incidentAngle\": 40.0  # degrees\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: <code>[410, 360]</code> - 410 frequency points \u00d7 360 azimuthal angles</p> <p>Use case: Studying rotational symmetry, in-plane anisotropy</p> <p>Plotting: Use <code>plot_mueller_azimuthal()</code> for frequency vs \u03b2 plots</p>"},{"location":"user-guide/scenarios/#dispersion-scenario","title":"Dispersion Scenario","text":"<p>k-space dispersion at a fixed frequency.</p> <pre><code>payload = {\n    \"ScenarioData\": {\n        \"type\": \"Dispersion\",\n        \"frequency\": 1460.0  # cm^-1\n    },\n    \"Layers\": [...]\n}\n</code></pre> <p>Output shape: <code>[180, 480]</code> - 180 incident angles \u00d7 480 azimuthal angles</p> <p>Use case: Visualizing polariton dispersion, identifying wave modes</p> <p>Plotting: Use <code>plot_mueller_dispersion()</code> for kx vs ky plots</p>"},{"location":"user-guide/scenarios/#choosing-a-scenario","title":"Choosing a Scenario","text":"Goal Scenario Type Quick single calculation Simple Angle-dependent analysis Incident Rotational behavior Azimuthal k-space dispersion relations Dispersion"},{"location":"user-guide/scenarios/#frequency-ranges","title":"Frequency Ranges","text":"<p>For <code>Incident</code> and <code>Azimuthal</code> scenarios, frequency ranges are automatically determined by the material:</p> <ul> <li>Calcite: 1300-1600 cm\u207b\u00b9 (upper) or 860-920 cm\u207b\u00b9 (lower)</li> <li>Quartz: 410-600 cm\u207b\u00b9</li> <li>Sapphire: 210-1000 cm\u207b\u00b9</li> <li>Gallium Oxide: 350-800 cm\u207b\u00b9</li> </ul>"},{"location":"user-guide/scenarios/#example-comparing-scenarios","title":"Example: Comparing Scenarios","text":"<pre><code>from hyperbolic_optics.structure import Structure\nfrom hyperbolic_optics.plots import plot_kx_frequency, plot_mueller_dispersion\n\n# Same material, different scenarios\nbase_layers = [\n    {\"type\": \"Ambient Incident Layer\", \"permittivity\": 25.0},\n    {\"type\": \"Isotropic Middle-Stack Layer\", \"thickness\": 0.5},\n    {\n        \"type\": \"Semi Infinite Anisotropic Layer\",\n        \"material\": \"Calcite\",\n        \"rotationX\": 0,\n        \"rotationY\": 70,\n        \"rotationZ\": 0\n    }\n]\n\n# Incident scenario\npayload_incident = {\n    \"ScenarioData\": {\"type\": \"Incident\"},\n    \"Layers\": base_layers\n}\nstructure_inc = Structure()\nstructure_inc.execute(payload_incident)\nR_inc = abs(structure_inc.r_pp)**2\n\n# Dispersion scenario\npayload_disp = {\n    \"ScenarioData\": {\"type\": \"Dispersion\", \"frequency\": 1460.0},\n    \"Layers\": base_layers\n}\nstructure_disp = Structure()\nstructure_disp.execute(payload_disp)\nR_disp = abs(structure_disp.r_pp)**2\n\n# Plot both\nplot_kx_frequency(structure_inc, R_inc, save_name=\"incident\")\nplot_mueller_dispersion(structure_disp, R_disp, save_name=\"dispersion\")\n</code></pre>"}]}